<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<title>mkinitcpio (Español) - ArchWiki</title>
<link rel="stylesheet" href="../ArchWikiOffline.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<meta name="generator" content="MediaWiki 1.35.0">
<meta name="referrer" content="no-referrer-when-downgrade">
<meta name="robots" content="noindex,follow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="/opensearch_desc.php" title="ArchWiki (en)">
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.archlinux.org/api.php?action=rsd">
<link rel="license" href="http://www.gnu.org/copyleft/fdl.html">
<link rel="alternate" type="application/atom+xml" title="ArchWiki Atom feed" href="/index.php?title=Special:RecentChanges&amp;feed=atom">
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Mkinitcpio_Español rootpage-Mkinitcpio_Español skin-vector action-view skin-vector-legacy">
<div id="content" class="mw-body" role="main" style="margin: 0">
	<a id="top"></a>
	<div id="siteNotice" class="mw-body-content"></div>
	<div class="mw-indicators mw-body-content">
	</div>
	<h1 id="firstHeading" class="firstHeading" lang="en">mkinitcpio (Español)</h1>
	<div id="bodyContent" class="mw-body-content">
		<div id="siteSub" class="noprint">From ArchWiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="#searchInput">Jump to search</a>
		<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<div class="warningbox">The printable version is no longer supported and may have rendering errors. Please update your browser bookmarks and please use the default browser print function instead.</div>
<div class="mw-parser-output">
<p><span></span>
</p>
<div class="archwiki-template-meta-related-articles-start">
<p>Artículos relacionados</p>
<ul>
<li><a href="/title/Systemd_(Espa%C3%B1ol)" title="Systemd (Español)">Systemd (Español)</a></li>
<li><a href="/title/Kernel_modules_(Espa%C3%B1ol)" class="mw-redirect" title="Kernel modules (Español)">Kernel modules (Español)</a></li>
</ul>
</div>
<p><b>mkinitcpio</b> es un creador de <a href="https://en.wikipedia.org/wiki/es:initrd" class="extiw" title="wikipedia:es:initrd">initramfs</a> de última generación.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading">
<input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none"><div class="toctitle" lang="en" dir="ltr">
<h2 id="mw-toc-heading">Contents</h2>
<span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span>
</div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Introducci%C3%B3n"><span class="tocnumber">1</span> <span class="toctext">Introducción</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Instalaci%C3%B3n"><span class="tocnumber">2</span> <span class="toctext">Instalación</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Creaci%C3%B3n_de_la_imagen_y_activaci%C3%B3n"><span class="tocnumber">3</span> <span class="toctext">Creación de la imagen y activación</span></a></li>
<li class="toclevel-1 tocsection-4">
<a href="#Configuraci%C3%B3n"><span class="tocnumber">4</span> <span class="toctext">Configuración</span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="#M%C3%93DULOS"><span class="tocnumber">4.1</span> <span class="toctext">MÓDULOS</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#BINARIOS_y_ARCHIVOS"><span class="tocnumber">4.2</span> <span class="toctext">BINARIOS y ARCHIVOS</span></a></li>
<li class="toclevel-2 tocsection-7">
<a href="#HOOKS"><span class="tocnumber">4.3</span> <span class="toctext">HOOKS</span></a>
<ul>
<li class="toclevel-3 tocsection-8"><a href="#Build_hooks"><span class="tocnumber">4.3.1</span> <span class="toctext">Build hooks</span></a></li>
<li class="toclevel-3 tocsection-9"><a href="#Runtime_hooks"><span class="tocnumber">4.3.2</span> <span class="toctext">Runtime hooks</span></a></li>
<li class="toclevel-3 tocsection-10"><a href="#Hooks_m%C3%A1s_comunes"><span class="tocnumber">4.3.3</span> <span class="toctext">Hooks más comunes</span></a></li>
<li class="toclevel-3 tocsection-11"><a href="#Hooks_desatendidos"><span class="tocnumber">4.3.4</span> <span class="toctext">Hooks desatendidos</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-12"><a href="#COMPRESION"><span class="tocnumber">4.4</span> <span class="toctext">COMPRESION</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#COMPRESSION_OPTIONS"><span class="tocnumber">4.5</span> <span class="toctext">COMPRESSION_OPTIONS</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-14">
<a href="#Personalizar_el_tiempo_de_ejecuci%C3%B3n"><span class="tocnumber">5</span> <span class="toctext">Personalizar el tiempo de ejecución</span></a>
<ul>
<li class="toclevel-2 tocsection-15"><a href="#init"><span class="tocnumber">5.1</span> <span class="toctext">init</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="#Usar_RAID"><span class="tocnumber">5.2</span> <span class="toctext">Usar RAID</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Usar_la_red"><span class="tocnumber">5.3</span> <span class="toctext">Usar la red</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#Utilizar_LVM"><span class="tocnumber">5.4</span> <span class="toctext">Utilizar LVM</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="#Utilizar_root_cifrado"><span class="tocnumber">5.5</span> <span class="toctext">Utilizar root cifrado</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="#/usr_en_una_partici%C3%B3n_separada"><span class="tocnumber">5.6</span> <span class="toctext">/usr en una partición separada</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-21">
<a href="#Soluci%C3%B3n_de_problemas"><span class="tocnumber">6</span> <span class="toctext">Solución de problemas</span></a>
<ul>
<li class="toclevel-2 tocsection-22"><a href="#Extraer_la_imagen"><span class="tocnumber">6.1</span> <span class="toctext">Extraer la imagen</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-23"><a href="#V%C3%A9ase_tambi%C3%A9n"><span class="tocnumber">7</span> <span class="toctext">Véase también</span></a></li>
<li class="toclevel-1 tocsection-24"><a href="#Referencias"><span class="tocnumber">8</span> <span class="toctext">Referencias</span></a></li>
</ul>
</div>

<h2>
<span id="Introducci.C3.B3n"></span><span class="mw-headline" id="Introducción">Introducción</span>
</h2>
<p>mkinitcpio es un script bash utilizado para generar un ramdisk inicial. En <span class="plainlinks archwiki-template-man" title="$ man 8 mkinitcpio"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/mkinitcpio.8">mkinitcpio(8)</a></span>:
</p>
<dl><dd><i>El ramdisk inicial es básicamente un entorno muy pequeño ("pre-userspace"), que carga varios módulos del kernel y establece los pasos preliminares necesarios antes de entregar el control a init. De esta manera usted puede tener, por ejemplo, sistemas de archivos cifrados y sistemas de archivos en el software RAID. Mkinitcpio también permite extensiones personalizadas con los hooks, la detección automática en tiempo de ejecución, y muchas otras características.</i></dd></dl>
<p>Tradicionalmente, el kernel es el responsable de la detección de hardware y las tareas de inicialización a principios del <a href="/title/Boot_process_(Espa%C3%B1ol)" class="mw-redirect" title="Boot process (Español)">proceso de arranque</a>, antes de montar el sistema de archivos root y pasar el control a <code> init</code>. Sin embargo, con los avances de la tecnología, estas actividades se han vuelto cada vez más complejas.
</p>
<p>A día de  hoy, el sistema de ficheros root se puede instalar en una amplia gama de hardware, de SCSI a SATA pasando por USB, el cual es monitoreado por una serie de controladores de unidades de diferentes fabricantes. Además, el sistema de ficheros root se puede comprimir o cifrar, en un software RAID o grupo de volumen lógico. La forma más fácil de manejar este rango de complejidad, es pasar la gestión al entorno userspace: el ramdisk inicial.
</p>
<p>Consulte: <a rel="nofollow" class="external text" href="https://web.archive.org/web/20150906053013/http://archlinux.me/brain0/2010/02/13/early-userspace-in-arch-linux/">/dev/brain0 » Blog Archive » Early Userspace in Arch Linux</a>.
</p>
<p>mkinitcpio es un instrumento modular para la construcción de una imagen init ramfs cpio, que ofrece muchas ventajas en comparación con métodos alternativos, entre ellos:
</p>
<ul>
<li>El uso de <a rel="nofollow" class="external text" href="https://www.busybox.net/">BusyBox</a>, que proporciona una base mínima y ligera para el entorno de userspace.</li>
<li>Apoyo de <b><a href="/title/Udev" title="Udev">udev</a></b> para detectar automáticamente el hardware durante la fase de ejecución, evitando así la carga de módulos innecesarios.</li>
<li>Usar init script extensibles sobre la base hook; los hooks pueden ser fácilmente personalizados incluidos en los paquetes <a href="/title/Pacman" title="Pacman">pacman</a>.</li>
<li>Apoyo de <b>LVM2</b>, <b>dm-crypt</b>, tanto para volúmenes legacy y LUKS, <b>mdadm</b>, <b>swsusp</b> y <b>suspend2</b> para la recuperación y el arranque desde dispositivos USB de almacenamiento masivo.</li>
<li>La capacidad de permitir que muchas características se puedan configurar desde la línea de comandos del kernel, sin la necesidad de reconstruir la imagen.</li>
</ul>
<p>mkinitcpio ha sido desarrollado por Arch Linux y con la ayuda de la comunidad de diversas formas. Consulte <a rel="nofollow" class="external text" href="https://projects.archlinux.org/mkinitcpio.git/">public Git repository</a>.
</p>
<h2>
<span id="Instalaci.C3.B3n"></span><span class="mw-headline" id="Instalación">Instalación</span>
</h2>
<p>El paquete <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=mkinitcpio">mkinitcpio</a></span> está disponible en los <a href="/title/Official_repositories" title="Official repositories">repositorios oficiales</a>, y se instala por defecto en tanto que se incluye en el grupo <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=base">base</a></span>.
</p>
<p>Para los usuarios que prefieren instalar la última versión de desarrollo Git de mkinitcpio:
</p>
<pre>$ git clone <a rel="nofollow" class="external free" href="git://projects.archlinux.org/mkinitcpio.git">git://projects.archlinux.org/mkinitcpio.git</a>
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> ¡Usted debe seguir <b>seriamente</b> la lista de correo del proyecto en Arch <a rel="nofollow" class="external text" href="https://mailman.archlinux.org/mailman/listinfo/arch-projects">arch-projects mailing list</a> si va a utilizar la versión de GIT de mkinitcpio!</div>
<h2>
<span id="Creaci.C3.B3n_de_la_imagen_y_activaci.C3.B3n"></span><span class="mw-headline" id="Creación_de_la_imagen_y_activación">Creación de la imagen y activación</span>
</h2>
<p>Por defecto, el script mkinitcpio genera dos imágenes después de instalar o actualizar el kernel: <code>/boot/initramfs-linux.img</code> y <code>/boot/initramfs-linux-fallback.img</code>. La imagen <i>fallback</i> utiliza el mismo archivo de configuración que la imagen <i>predeterminada</i>, con la excepción del hook <b>autodetect</b> que se omite durante la creación, incluyendo, por tanto, una amplia gama de módulos. El hook de detección (<b>autodetect</b>) detecta automáticamente los módulos necesarios y personaliza la imagen para un hardware específico, lo que reduce el initramfs.
</p>
<p>Los usuarios pueden crear cuantas imágenes initramfs deseen, con perfiles de configuración diferentes. La imagen deseada se debe especificar para el <a href="/title/Arch_boot_process_(Espa%C3%B1ol)#Gestor_de_arranque" title="Arch boot process (Español)">gestor de arranque</a>, a menudo en su archivo de configuración. Después de realizar los cambios en el fichero de configuración, la imagen debe ser regenerada. Para el valor del kernel de Arch Linux, <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=linux">linux</a></span>, ésto se hace mediante la ejecución de este comando como root:
</p>
<pre># mkinitcpio -p linux
</pre>
<p>La opción <code>-p</code> indica un "preset" para ser utilizado; la mayoría de los paquetes kernel proveen un mkinitcpio predefinido, que se encuentra en <code>/etc/mkinitcpio.d</code> (por ejemplo <code>/etc/mkinitcpio.d/linux.preset</code> para <code>linux</code>). Un preset es una definición por defecto de cómo crear una imagen initramfs en lugar de especificar el archivo de configuración y el archivo de salida en cada ocasión.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Advertencia:</strong> El archivo <i>preset</i> se utiliza para regenerar el initramfs de forma automática después de una actualización del kernel; tenga cuidado si lo modifica</div>
<p>Los usuarios pueden crear manualmente una imagen con un archivo de configuración alternativo. Por ejemplo, la siguiente orden va a generar una imagen initramfs de acuerdo con las instrucciones de <code>/etc/mkinitcpio-custom.conf</code> y guardarlo en <code>/boot/linux-custom.img</code>.
</p>
<pre># mkinitcpio -c /etc/mkinitcpio-custom.conf -g /boot/linux-custom.img
</pre>
<p>Para crear la imagen de un kernel diferente al actualmente en ejecución, agregar la versión del kernel a la línea de órdenes.  Puede ver las versiones del kernel disponibles en <code>/usr/lib/modules</code>.
</p>
<pre># mkinitcpio -g /boot/linux.img -k 3.0.0-ARCH
</pre>
<h2>
<span id="Configuraci.C3.B3n"></span><span class="mw-headline" id="Configuración">Configuración</span>
</h2>
<p>El archivo de configuración principal de <b>mkinitcpio</b> es <code>/etc/mkinitcpio.conf</code>. Además, las definiciones preestablecidas son proporcionadas por los paquetes del kernel en el directorio <code>/etc/mkinitcpio.d</code> (por ejemplo <code>/etc/mkinitcpio.d/linux.preset</code>).
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Advertencia:</strong> <b>NO</b>  son activadas por defecto <b>lvm2</b>, <b>mdadm</b> y <b>encrypt</b>. Por favor, lea atentamente esta sección para las instrucciones, si estos hooks son obligatorios.</div>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Usuarios con varios controladores de disco de hardware que utilizan los nombres de los propios nodos, pero módulos del kernel diversos  (por ejemplo, dos SCSI/SATA y dos controladores IDE) deben asegurarse de que el orden correcto de los módulos se especifica en <code>/etc/mkinitcpio.conf</code>. De lo contrario, la posición de la partición root puede variar, dando lugar a kernel panic. Una alternativa más plausible sería usar nombres de los dispositivos que no cambien <a href="/title/Persistent_block_device_naming" title="Persistent block device naming">Persistent block device naming</a>, para asegurar que vengan siempre correctamente montados.</div>
<p>Los usuarios pueden modificar seis variables en el fichero de configuración:
</p>
<dl>
<dt><code>MODULES</code></dt>
<dd>Módulos del kernel que se cargan antes de que los hooks se ejecuten al inicio.</dd>
<dt><code>BINARIES</code></dt>
<dd>Binarios suplementarios para incluir la imagen initramfs.</dd>
<dt><code>FILES</code></dt>
<dd>Los archivos adicionales que se incluirán en la imagen initramfs.</dd>
<dt><code>HOOKS</code></dt>
<dd>Los hooks son los scripts que se ejecutan en el ramdisk inicial.</dd>
<dt><code>COMPRESSION</code></dt>
<dd>Se utiliza para comprimir la imagen initramfs.</dd>
<dt><code>COMPRESSION_OPTIONS</code></dt>
<dd>Las opciones de la línea de comandos para el programa <code>COMPRESSION</code>.</dd>
</dl>
<h3>
<span id="M.C3.93DULOS"></span><span class="mw-headline" id="MÓDULOS">MÓDULOS</span>
</h3>
<p>La matriz MODULES se utiliza para especificar los módulos a cargar antes de ejecutar cualquier otra cosa. 
</p>
<p>Los módulos con el sufijo <code>?</code> no devuelven un error si no se les encuentra. Esto puede ser muy útil si está creando un kernel personalizado que compile los módulos escritos explícitamentes en los Hooks, o en el archivo de configuración.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Si utiliza <b>reiser4</b>,  éste <i>debe</i> ser añadido a la lista de los módulos. Adicionalmente, si va a necesitar un sistema de archivos durante el proceso de arranque, inexistente durante la ejecución de <b>mkinitcpio</b>, —como en el caso de una clave de cifrado LUKS en un sistema de archivos <b>ext2</b>, pero sin ningún sistema de archivos <b>ext2</b> montado cuando se ejecuta mkinitcpio—, el módulo de aquel sistema de archivos se debe añadir a la lista de MODULES. Consulte <a href="/title/System_Encryption_with_LUKS_for_dm-crypt#Storing_the_Key_File" class="mw-redirect" title="System Encryption with LUKS for dm-crypt">aquí</a><sup>[<a href="/title/Help:Procedures#Fix_broken_section_links" title="Help:Procedures">broken link</a>: invalid section]</sup> para obtener más detalles</div>
<h3><span class="mw-headline" id="BINARIOS_y_ARCHIVOS">BINARIOS y ARCHIVOS</span></h3>
<p>Estas opciones permiten al usuario añadir archivos a la imagen. Tanto <code>BINARIES</code> como <code>FILES</code> se agregan antes de que los hooks se ejecutan, y se puede usar para sobrescribir los archivos utilizados o suministrados por el hook. Los binarios son auto-localizados, ya que deben ser almacenados en un <code>PATH</code> estándar y son analizadores de dependencias, por lo que las necesidades de cada biblioteca y dependencias se sumarán en consecuencia. Los <code>FILES</code> se agregarán <i>como están</i>. Por ejemplo:
</p>
<pre>FILES="/etc/modprobe.d/modprobe.conf"
</pre>
<pre>BINARIES="kexec"
</pre>
<h3><span class="mw-headline" id="HOOKS">HOOKS</span></h3>
<p>La configuración de los <code>HOOKS</code> es la más importante configuración del archivo. Los hooks son pequeños scripts que describen lo que se agregará a la imagen. Algunos hooks, también contienen un componente de tiempo de ejecución, que proporcionan un comportamiento adicional, como iniciar un demonio o ensamblar un dispositivo de bloque apilado. Los hooks son mencionados por su nombre, y se ejecutan en el orden establecido en la línea <code>HOOKS</code> del archivo de configuración.
</p>
<p>Los ajustes por defecto para los <code>HOOKS</code> deberían ser suficientes para la mayoría de las configuraciones de discos únicos. Para los dispositivos root que se apilan o dispositivos multibloques como <a href="/title/LVM" title="LVM">LVM</a>, <a href="/title/Software_RAID_and_LVM" class="mw-redirect" title="Software RAID and LVM">mdadm</a> o <a href="/title/LUKS" class="mw-redirect" title="LUKS">LUKS</a>, consulte las páginas wiki respectivas para la configuración adicional necesaria.
</p>
<h4><span class="mw-headline" id="Build_hooks">Build hooks</span></h4>
<p>Los hooks compilados (<i>«build hooks»</i>) se encuentran en <code>/usr/lib/initcpio/install</code>. Estos archivos se obtienen por la shell bash durante el tiempo de ejecución de mkinitcpio y contienen dos funciones: <code>build</code> y <code>help</code>. La función <code>build</code> describe los módulos, archivos y binarios que se añadirán a la imagen. Una API, documentado por mkinitcpio (8), sirve para facilitar la adición de estos elementos. La función <code>help</code>  genera una descripción de lo que el hook puede conseguir.
</p>
<p>Para obtener una lista de todos los hooks disponibles:
</p>
<pre>$ mkinitcpio -L
</pre>
<p>El uso de la opción <code>-H</code> con mkinitcpio ayuda a mostrar información sobre un hook específico, por ejemplo:
</p>
<pre>$ mkinitcpio -H udev
</pre>
<h4><span class="mw-headline" id="Runtime_hooks">Runtime hooks</span></h4>
<p>Los hooks con temporizador (<i>«runtime hooks»</i>) se encuentran en <code>/usr/lib/initcpio/hooks</code>. Para cualquier runtime hook, siempre debe haber un build hook del mismo nombre, que llama a la función <code>add_runscript</code>, la cual añade runtime hook a la imagen. Estos archivos se obtienen por busybox ash shell durante el espacio de usuario inicial (<i>«early userspace»</i>). Con la excepción de los hooks de limpieza (<i>cleanup hooks</i>), los demás hooks siempre se ejecutan en el orden configurado en que aparecen en la lista <code>HOOKS</code>. Los runtime hooks pueden contener varias funciones:
</p>
<p><code>run_earlyhook</code>:  Las funciones con este nombre se ejecutarán una vez que los sistemas de archivos API se han montado y la línea de comandos del kernel ha sido analizada. Esta es la fase donde se inician normalmente demonios adicionales, como udev, que se necesitan para el proceso de arranque inicial.
</p>
<p><code>run_hook</code>: Las funciones con este nombre se ejecutan poco después de los primeros hooks. Este es el punto más normal de actuación de los hooks, dado que las operaciones como montaje de dispositivos de bloques apilados deberían tener lugar aquí.
</p>
<p><code>run_latehook</code>: Las funciones con este nombre se ejecutan después de que el dispositivo raíz se ha montado. Esto se debe utilizar, con moderación, para la configuración adicional del dispositivo raíz, o para el montaje de otros sistemas de archivos, como <code>/usr</code>.
</p>
<p><code>run_cleanuphook</code>: Las funciones con este nombre se ejecutan lo más tarde posible, y en el orden contrario a como se muestran en la línea <code>HOOKS</code> del archivo de configuración. Estos hooks se deben utilizar para cualquier limpieza de última hora, como al cierre de cualquier demonio iniciado por un hook temprano.
</p>
<h4>
<span id="Hooks_m.C3.A1s_comunes"></span><span class="mw-headline" id="Hooks_más_comunes">Hooks más comunes</span>
</h4>
<p>A continuación se muestra una tabla de los hooks más comunes y cómo afectan a la creación de la imagen y su tiempo de ejecución. Tenga en cuenta que esta tabla no es completa, ya que los paquetes pueden proporcionar hooks personalizados.
</p>
<table class="wikitable">
<caption>
<b>Hooks actuales</b>
</caption>
<tbody>
<tr>
<th>Hook</th>
<th>Instalación</th>
<th>Tiempo de ejecución
</th>
</tr>
<tr>
<td><b>base</b></td>
<td>Establece todos los directorios iniciales e instala los servicios básicos y bibliotecas. Agregue siempre este hook, a menos que sepa exactamente lo que está haciendo.</td>
<td>--
</td>
</tr>
<tr>
<td><b>systemd</b></td>
<td>Este instalará una configuración systemd básica en su initramfs, y está destinado a sustituir los hooks «base», «usr», «udev» y «timestamp». Otros hooks (como encryption) tendrán que ser adaptados, y puede que no funcionen según lo previsto. A partir de systemd 207, este hook no funciona como es debido cuando se combina con lvm2 y puede romper su arranque. También puede que desee todavía incluyen el hook «base» (antes de este hook) para asegurar que existe un shell de rescate en su initramfs.</td>
<td>--
</td>
</tr>
<tr>
<td><b>btrfs</b></td>
<td>Establece los módulos necesarios  para activar Btrfs para root y la utilización de subvolúmenes.</td>
<td>Ejecuta «el escaneo del dispositivo btrfs» para ensamblar un multidispositivo con sistema de archivos root btrfs cuando ningún hook udev está presente.
</td>
</tr>
<tr>
<td><b>udev</b></td>
<td>Añade udevd, udevadm y un pequeño conjunto de las reglas udev a la imagen.</td>
<td>Inicia el demonio udev y los procesos uevents del kernel; los cuales crean los nodos de los dispositivos. Ya que simplifica el proceso de arranque al no requerir que el usuario especifique explícitamente los módulos necesarios, el uso de este hook es recomendable.
</td>
</tr>
<tr>
<td><b>autodetect</b></td>
<td>Reduce la imagne initramfs a un tamaño más pequeño mediante la creación de una lista blanca de los módulos mediante el escaneo de sysfs.  Verifique que los módulos incluidos son los correctos y no falta ninguno. Este hook se debe iniciar antes que el subsistema de otro hook, para aprovechar al máximo la detección automática. Cada hook especificado en la línea HOOKS, antes de "autodetect", se instalará por completo.</td>
<td>--
</td>
</tr>
<tr>
<td><b>modconf</b></td>
<td>Carga los archivos de configuración de modprobe desde <code>/etc/modprobe.d</code> y <code>/usr/lib/modprobe.d</code>
</td>
<td>--
</td>
</tr>
<tr>
<td><b>block</b></td>
<td>Agrega todos los módulos de los dispositivos de bloque, anteriormente proporcionados separadamente por los hooks <b>fw</b>, <b>mmc</b>, <b>pata</b>, <b>sata</b>, <b>scsi</b> , <b>usb</b> y <b>virtio</b>.</td>
<td>--
</td>
</tr>

<tr>
<td><b>pcmcia</b></td>
<td>Agrega los módulos necesarios para dispositivos PCMCIA. Necesitará instalar el  paquete <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=pcmciautils">pcmciautils</a></span><sup>[<a href="/title/Help:Procedures#Fix_broken_package_links" title="Help:Procedures">enlace roto</a>: package not found]</sup> para usar esta opción.</td>
<td>--
</td>
</tr>
<tr>
<td><b>net</b></td>
<td>Agrega los módulos necesarios para un dispositivo de red. Para dispositivos PCMCIA agregue también el hook <b>PCMCIA</b>.</td>
<td>Proporciona control para un sistema de ficheros raíz basados en NFS.
</td>
</tr>
<tr>
<td><b>dmraid</b></td>
<td>Proporciona soporte para proveedores de dispositivos root fakeRAID. Debe instalar el paquete <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=dmraid">dmraid</a></span> para poder usar esta opción</td>
<td>Localiza y monta los dispositivos de bloque fakeRAID usando <code>dmraid</code>.
</td>
</tr>
<tr>
<td><b>mdadm</b></td>
<td>Proporciona soporte para el montaje de las matrices RAID de <code>/etc/mdadm.conf</code>, o la detección automática durante el arranque. Debe tener <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=mdadm">mdadm</a></span> instalado para utilizar esta opción. El hook <b>mdadm_udev</b> es preferible a este.</td>
<td>Busca y monta los dispositivos de bloque con software RAID usando <code>mdassemble</code>.
</td>
</tr>
<tr>
<td><b>madadm_udev</b></td>
<td>Proporciona soporte para el montaje de sistemas RAID a través de udev. Si utiliza este hook con una matriz FakeRAID, es recomendable incluir <code>mdmon</code> en la sección binaries y añadir el hook <b>shutdown</b> a fin de evitar reconstruir innecesariamente RAID al arrancar.</td>
<td>Localiza y monta los dispositivos de bloque con software RAID usando <code>udev</code> y <code>mdadm</code> asegurando el montaje. Este es el método preferido de montaje mdadm  (en lugar de utilizar el hook mdadm anterior).
</td>
</tr>
<tr>
<td><b>keyboard</b></td>
<td>Añade los módulos necesarios para los dispositivos de teclado. Utilice esta opción si tiene un teclado USB y lo necesita en el espacio de usuario inicial (ya sea para introducir contraseñas de cifrado o para su uso en un shell interactiva). As a side-effect modules for some non-keyboard input devices might be added to, but this should not be relied on.</td>
<td>--
</td>
</tr>
<tr>
<td><b>keymap</b></td>
<td>Añade la distribución de teclado y la tipografía a la connsola según lo establecido en  <code>/etc/vconsole.conf</code>.</td>
<td>Carga la distribución de teclado especificado y la tipografía de la consola de <code>/etc/vconsole.conf</code> durante la fase del espacio de usuario inicial.
</td>
</tr>
<tr>
<td><b>consolefont</b></td>
<td>Agrega el tipo de letra de consola especificado en <code>/etc/vconsole.conf</code> a initramfs.</td>
<td>Carga el tipo de letra especificado para la consola en <code>/etc/vconsole.conf</code> durante la fase temprana del espacio de usuario.
</td>
</tr>
<tr>
<td><b>sd-vconsole</b></td>
<td>Agrega la distribución del teclado y el tipo de fuente de la consola especificados en <code>/etc/vconsole.conf</code> a initramfs basado en systemd.</td>
<td>Carga la distribución del teclado y el tipo de fuente de la consola especificados durante la fase temprana del espacio de usuario.
</td>
</tr>
<tr>
<td><b>encrypt</b></td>
<td>Agrega el módulo <code>dm_crypt</code> del kernel y la herramienta <code>cryptsetup</code> a la imagen. Tendrá que tener instalado el paquete <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=cryptsetup">cryptsetup</a></span> para usar esta opción.</td>
<td>Detecta y desbloquea una partición de root cifrada. Vea <a href="#Personalizar_el_tiempo_de_ejecuci%C3%B3n">#Personalizar el tiempo de ejecución</a> para ajustar la configuración.
</td>
</tr>
<tr>
<td><b>sd-encrypt</b></td>
<td>Este hook  permite un dispositivo root encriptado con initramfs systemd.
<p>Véase la página del manual de systemd-cryptsetup-generator(8) para conocer las opciones disponibles 
en línea de órdes del kernel. Alternativamente, si el archivo <code>/etc/crypttab.initramfs</code>
existe, se añadirá a initramfs como <code>/etc/crypttab</code>. Véase la
página del manual de crypttab(5) para obtener información
sobre la sintaxis de crypttab.
</p>
</td>
<td>--
</td>
</tr>
<tr>
<td><b>lvm2</b></td>
<td>Agrega el mapeador del dispositivo al módulo del kernel y la herramienta <code>lvm</code> a la imagen. Tendrá que tener instalado el paquete <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=lvm2">lvm2</a></span> para usar esta opción.</td>
<td>Habilita todos los grupos de los volúmenes LVM2. Esto es necesario si el sistema de archivos raíz está en <a href="/title/LVM" title="LVM">LVM</a>.
</td>
</tr>
<tr>
<td><b>fsck</b></td>
<td>Añade binarios de fsck y ayudas para el sistema de archivos específico. Si se coloca después del hook <b>autodetect</b> sólo se añade la ayuda para el sistema de archivos raiz. Utilizar este hook es <b>muy</b> recomendable, y es necesario si tiene una partición <code>/usr</code> separada.</td>
<td>Lanza fsck en el dispositivo root (y <code>/usr</code> si son distintos) antes del montaje.
</td>
</tr>
<tr>
<td><b>resume</b></td>
<td>--</td>
<td>Pretende volver a restaurar (resume) el sistema desde el estado de "suspensión en disco". Funciona conjuntamente con <i>swsusp</i> y <i><a href="/title/Suspend2" class="mw-redirect" title="Suspend2">suspend2</a></i>. Vea <a href="#Personalizar_el_tiempo_de_ejecuci%C3%B3n">#Personalizar el tiempo de ejecución</a> para ajustar configuración.
</td>
</tr>
<tr>
<td><b>filesystems</b></td>
<td>Este incluye los módulos necesarios del sistema de archivos en la imagen. Este hook es <b>necesario</b>, a menos que especifique los módulos del filesystem en la línea MODULES.</td>
<td>--
</td>
</tr>
<tr>
<td><b>shutdown</b></td>
<td>Añade soporte al apagado en initramfs. Si se tiene una partición <code>/usr</code> separada o root cifrada, este hook es fundamental.</td>
<td>Desmonta y separa los dispositivos en el apagado.
</td>
</tr>
<tr>
<td><b>usr</b></td>
<td>Añade soporte para la partición <code>/usr</code> separada.</td>
<td>Monta la partición <code>/usr</code> después de la partición raiz, para que quede correctamente montada.
</td>
</tr>
</tbody>
</table>
<h4><span class="mw-headline" id="Hooks_desatendidos">Hooks desatendidos</span></h4>
<p>A partir de <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=mkinitcpio">mkinitcpio</a></span> 0.13.0, el hook <code>usbinput</code> está en desuso en favor del hook <code>keyboard</code>.
</p>
<p>A partir de <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=mkinitcpio">mkinitcpio</a></span> 0.12.0, los hooks siguientes están en desuso. Si va a usar cualquiera de estos hooks, necesitará reemplazarlos con una sola instancia del hook <code>block</code>.
</p>
<ul>
<li><code>fw</code></li>
<li><code>mmc</code></li>
<li><code>pata</code></li>
<li><code>sata</code></li>
<li><code>scsi</code></li>
<li><code>usb</code></li>
<li><code>virtio</code></li>
</ul>
<p>Para obtener más información, puede revisar Git commit <a rel="nofollow" class="external text" href="https://projects.archlinux.org/mkinitcpio.git/commit/?id=97368c0e78f3a4fe4d62f7aedde88d4be13bfdba">97368c0e78</a> o véase la <a rel="nofollow" class="external text" href="https://mailman.archlinux.org/pipermail/arch-projects/2012-November/003426.html">lista de correos de arch-projects</a>.
</p>
<h3><span class="mw-headline" id="COMPRESION">COMPRESION</span></h3>
<p>El kernel soporta varios formatos para la compresión de las initramfs, gzip, bzip2, lzma, xz (también conocido como lzma2) y lzo. En la mayoría de los casos, gzip o lzop proporcionan el mejor equilibrio entre el tamaño de la imagen comprimida y la velocidad de descompresión.
</p>
<pre>COMPRESSION="gzip"
COMPRESSION="bzip2"  # since kernel 2.6.30
COMPRESSION="lzma"   # since kernel 2.6.30
COMPRESSION="lzop"   # since kernel 2.6.34
COMPRESSION="xz"     # since kernel 2.6.38
COMPRESSION="lz4c"   # since kernel 3.11
</pre>
<p>La falta de parámetro <code>COMPRESSION</code> dará como resultado un archivo initramfs comprimido en gzip . Para crear una imagen sin comprimir, especifica <code>COMPRESSION=cat</code> en la configuración o use la opción <code>-z cat</code> en la línea de comandos.
</p>
<p>Asegúrese de tener instalada la utilidad de compresión de archivos correcta para el método que desee utilizar.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Advertencia:</strong> La compresión lz4 <b>requiere</b> <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=mkinitcpio">mkinitcpio</a></span>&gt;=16-2.</div>
<h3><span class="mw-headline" id="COMPRESSION_OPTIONS">COMPRESSION_OPTIONS</span></h3>
<p>Estos son indicadores ulteriores que se pueden pasar al programa especificado por <code>COMPRESSION</code>, tales como:
</p>
<pre>COMPRESSION_OPTIONS='-9'
</pre>
<p>En general, esto no debería ser necesario, en cuanto que mkinitcpio asegurará que cualquier método de compresión soportará los indicadores necesarios para producir una imagen funcional.
</p>
<h2>
<span id="Personalizar_el_tiempo_de_ejecuci.C3.B3n"></span><span class="mw-headline" id="Personalizar_el_tiempo_de_ejecución">Personalizar el tiempo de ejecución</span>
</h2>
<p>Las opciones de configuración sobre el tiempo de ejecución pueden ser enviados a <code>init</code> y algunos hooks a través de la línea de comandos del kernel. Los parámetros de la línea de comandos del kernel son a menudo proporcionados por el gestor de arranque. Las opciones que se exponen a continuación se pueden añadir a la línea de comandos del kernel para modificar el comportamiento predefinido. Vea <a href="/title/Kernel_parameters" title="Kernel parameters">Kernel parameters</a> y <a href="/title/Arch_boot_process" title="Arch boot process">Arch boot process</a> para más información.
</p>
<h3><span class="mw-headline" id="init">init</span></h3>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Las siguientes opciones alteran el comportamiento predeterminado de <code>init</code> en el entorno de initramfs. Vea <code>/usr/lib/initcpio/init</code> para obtener más información</div>
<dl>
<dt><code>root</code></dt>
<dd>Este es el parámetro más importante a especificar al kernel. Determina qué dispositivo debe estar instalado como root. mkinitcpio es flexible y permite una sintaxis diferente. Por ejemplo</dd>
</dl>
<pre>root=/dev/sda1                                                # /dev node
root=LABEL=CorsairF80                                         # label
root=UUID=ea1c4959-406c-45d0-a144-912f4e86b207                # UUID
root=/dev/disk/by-path/pci-0000:00:1f.2-scsi-0:0:0:0-part1    # udev symlink (requiere el hook <b>udev</b> )
root=801                                                      # hex-encoded major/minor number
</pre>
<dl>
<dt><code>break</code></dt>
<dd>Si se especifica <code>break</code> o <code>break=premount</code>, <code>init</code> hace una pausa inicial en el proceso de arranque  (después de cargar el módulos pero antes de montar la raíz) y ejecuta un shell interactivo que se puede utilizar para resolver cualquier problema. Este shell puede ser lanzado después de montar la raíz especificando <code>break=postmount</code>. La fase boot continúa después de cerrar la sesión.</dd>
</dl>
<dl>
<dt><code>disablehooks</code></dt>
<dd>Deshabilita los hooks en tiempo de ejecución mediante la adición de <code>disablehooks=hook1{,hook2,...}</code>. Por ejemplo: <pre>disablehooks=resume</pre>
</dd>
</dl>
<dl>
<dt><code>earlymodules</code></dt>
<dd>Cambia el orden en que se carguen los módulos, especificando los módulos que debe cargar primero <code>earlymodules=mod1{,mod2,...}</code>. (Esto podría ser utilizado, por ejemplo, para asegurar el orden correcto de múltiples interfaces de red).</dd>
</dl>
<dl>
<dt><code>rootdelay=N</code></dt>
<dd>Pausa durante <code>N</code> segundos antes de montar el sistema root, poniendo <code>rootdelay</code>. (Esto podría ser utilizado, por ejemplo, para el lanzamiento de un disco duro USB que es lento en la fase de arranque).</dd>
</dl>
<p>Vea también: <a href="/title/Boot_debugging" class="mw-redirect" title="Boot debugging">Depurar con GRUB e init</a>
</p>
<h3><span class="mw-headline" id="Usar_RAID">Usar RAID</span></h3>
<p>Primero se debe agregar el hook <code>mdadm</code> a la matriz de <code>HOOKS</code>, y luego cada módulo raid que se requiera a la matriz de MODULES en <code>/etc/mkinitcpio.conf</code>.
</p>
<p><b>Parámetros del kernel:</b> Con el hook <code>mdadm</code>, ya no será necesario configurar la matriz RAID en los parámetros de <a href="/title/GRUB" title="GRUB">GRUB</a>. El hook <code>mdadm</code> utilizará el archivo <code>/etc/mdadm.conf</code>, o detectará automáticamente las matrices durante el arranque inicial.
</p>
<p>Si este parámetro se configura a través de udev, debe utilizar el hook <code>mdadm_udev</code>. Los desarrolladores prefieren este método de montaje <code>/etc/mdadm.conf</code> en cuanto que lee el nombre de los dispositivos conectados, en su caso.
</p>
<h3><span class="mw-headline" id="Usar_la_red">Usar la red</span></h3>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Advertencia:</strong> NFSv4 ya no es soportado.</div>
<p><b>Paquetes requeridos:</b>
</p>
<p>La red requiere que el paquete <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=mkinitcpio-nfs-utils">mkinitcpio-nfs-utils</a></span> esté instalado de los <a href="/title/Official_repositories" title="Official repositories">repositorios oficiales.</a>
</p>
<p><b>Parámetros del kernel:</b>
</p>
<p><b>ip=</b>
</p>
<p>La especificación de una interfaz puede ser en formato corto, que es sólo el nombre de una interfaz ("eth0", o lo que sea), o un formato largo. El formato alargado puede estar constituido por siete elementos, separados por dos puntos:
</p>
<pre> ip=&lt;client-ip&gt;:&lt;server-ip&gt;:&lt;gw-ip&gt;:&lt;netmask&gt;:&lt;hostname&gt;:&lt;device&gt;:&lt;autoconf&gt;
 nfsaddrs= es un alias para ip= y se puede utilizar también.
</pre>
<p><i>Explicación de los parámetros</i>:
</p>
<pre> &lt;client-ip&gt;   IP del cliente. Si está vacío, la dirección será
               determinada por RARP/BOOTP/DHCPP. El tipo de protocolo
               utilizado dependerá del parámetro &lt;autoconf&gt; . Si este
               parámetro no está vacío, se utiliza el autoconf.
 
 &lt;server-ip&gt;   IP del servidor NFS. Si RARP se utiliza para
               determinar la dirección del cliente, y este parámetro
               no está vacío, será aceptada sólo si el servidor
               especificado responde. Para utilizar diferentes RARP y NFS
               especificar el servidor RARP aquí (o dejarlo en blanco),
               y especifique el servidor NFS, en "nfsroot", el parámetro
               (Ver a continuación). Si esta entrada está en blanco se utilizará la dirección del servidor
               RARP/BOOTP/DHCP que respondiera a la solicitud.
 
 &lt;gw-ip&gt;       puerta de enlace si el servidor está en una subred
               diferente. Si está vacío, no se utilizarán las puertas de enlace y
               el servidor será, presumiblemente, el de la red local, a menos
               que no se reciba algún valor de BOOTP/DHCP.
 
 &lt;netmask&gt;     Máscara de red para la interfaz de red local. Si se deja en blanco,
               la máscara de red se deriva de la dirección IP del cliente que asume
               el direccionamiento "classful", a menos que sea cancelado por
               respuesta de BOOTP/DHCP.
 
 &lt;hostname&gt;    El nombre del cliente. Si está vacío, la dirección
               IP del cliente se utiliza en la notación ASCII, o el
               valor recibido por BOOTP/DHCP.
 
 &lt;device&gt;      Nombre del dispositivo de red para su uso. Si está vacío, todos los
               dispositivos se utilizan para las solicitudes de RARP/BOOTP/DHCP, y
               el primero en recibir una respuesta se configura. Si está utilizando
               un solo dispositivo, puede dejar esta entrada en blanco.
 
 &lt;autoconf&gt;    Método a utilizar para la configuración automática. Si incluye tanto
               "rarp", "bootp", como "dhcp" el protocolo especificado será
               utilizado. Si el valor es "both", "all" o vacío, todos los
               protocolos se utilizarán. "off", "static" o "none" significa no configurar automáticamente.
</pre>
<p><i>Ejemplos:</i> 
</p>
<pre> ip=127.0.0.1:::::lo:none     --&gt; Permitir interfaz de bucle invertido.
 ip=192.168.1.1:::::eth2:none --&gt; Permitir la interfaz estática eth2.
 ip=:::::eth0:dhcp            --&gt; Habilitar el protocolo dhcp para configurar eth0.
</pre>
<p><b>BOOTIF=</b>
</p>
<p>Si tiene varias tarjetas de red, este parámetro puede incluir la dirección MAC de la interfaz que está arrancando. Esto suele ser útil cuando la interfaz puede cambiar de numeración, o en conjunción con pxelinux IPAPPEND 2 o la opción IPAPPEND 3.
Si no se da, eth0 va a ser utilizado.
</p>
<p><i>Ejemplo:</i>
</p>
<pre> BOOTIF=01-A1-B2-C3-D4-E5-F6  # Note the prepended "01-" and capital letters.
</pre>
<p><b>nfsroot=</b>
</p>
<p>Si el parámetro "nfsroot" no se da en la línea de comandos, se utiliza el valor por defecto <code>/tftpboot/%s</code>.
</p>
<pre> nfsroot=[&lt;server-ip&gt;:]&lt;root-dir&gt;[,&lt;nfs-options&gt;]
</pre>
<p><i>Explicación de los parámetros</i>:
</p>
<pre> &lt;server-ip&gt;   Especifica la dirección IP del servidor NFS. Si no se especifica,
               la dirección por defecto está determinado por "ip" variable
               (Ver abajo). Una utilidad de este valor es, por ejemplo
               la capacidad de utilizar diferentes servidores de RARP y NFS.
               En general, se puede dejar en blanco.
 
 &lt;root-dir&gt;    nombre de la carpeta en el servidor para montar como root. Si hay
               un "%s" en la cadena, el símbolo será sustituido por la
               representación ASCII de la dirección IP del cliente.
               
 &lt;nfs-options&gt; Opciones estándar NFS. Todas las opciones están separadas por comas.
               Si ninguna opción se proporciona, se utilizará
               siguiendo las opciones por defecto:
                       port            = as given by server portmap daemon
                       rsize           = 1024
                       wsize           = 1024
                       timeo           = 7
                       retrans         = 3
                       acregmin        = 3
                       acregmax        = 60
                       acdirmin        = 30
                       acdirmax        = 60
                       flags           = hard, nointr, noposix, cto, ac
</pre>
<p><b>root=/dev/nfs</b>
</p>
<p>Si usted no utiliza los parámetros de <code>nfsroot</code> debe configurar <code>root=/dev/nfs</code> a partir de un NFS de root para la configuración automática.
</p>
<h3><span class="mw-headline" id="Utilizar_LVM">Utilizar LVM</span></h3>
<p>Si el dispositivo raíz se encuentra en LVM, usted tiene que agregar el hook <b>lvm2</b>, y cambiar el dispositivo raíz en la línea de comandos del kernel con el formato:
</p>
<pre> root=/dev/mapper/&lt;volume group name&gt;-&lt;logical volume name&gt;
</pre>
<p>por ejemplo:
</p>
<pre>root=/dev/mapper/myvg-root
</pre>
<p>Además, si el dispositivo root puede iniciar lentamente (por ejemplo, un dispositivo USB) y/o recibe un error de "volume group not found" ("grupo de volúmenes que no se encuentra")  durante el arranque, es posible que deba añadir lo siguiente a la línea de comandos del kernel:
</p>
<pre> lvmwait=/dev/mapper/&lt;volume group name&gt;&lt;logical volume name&gt;
</pre>
<p>por ejemplo:
</p>
<pre>lvmwait=/dev/mapper/myvg-root
</pre>
<p>Esto permite que el proceso de arranque espere hasta que LVM se las arregla para hacer que el dispositivo esté disponible.
</p>
<h3><span class="mw-headline" id="Utilizar_root_cifrado">Utilizar root cifrado</span></h3>
<p>Si el volumen de la raíz está cifrada, debe agregar el hook <code>encrypt</code>. 
</p>
<p>Para un root encriptado, use algo similar a:
</p>
<pre> root=/dev/mapper/root cryptdevice=/dev/sda5:root
</pre>
<p>En este caso, <code>/dev/sda5</code> es el dispositivo cifrado, y le damos un nombre arbitrario de <code>root</code>, lo que significa que nuestro dispositivo raíz, una vez desbloqueado, se monta como <code>/dev/mapper/root</code>. En el arranque, se le pedirá la contraseña para desbloquear éste. Vea <a href="/title/LUKS#Configuration_of_initcpio" class="mw-redirect" title="LUKS">LUKS#Configuration_of_initcpio</a><sup>[<a href="/title/Help:Procedures#Fix_broken_section_links" title="Help:Procedures">broken link</a>: invalid section]</sup> para más detalles sobre el uso de root encriptado.
</p>
<h3>
<span id=".2Fusr_en_una_partici.C3.B3n_separada"></span><span class="mw-headline" id="/usr_en_una_partición_separada">/usr en una partición separada</span>
</h3>
<p>Si durante la instalación de Arch Linux usted eligió montar <code>/usr</code> en una partición separada, debe tener en cuenta varias cosas:
</p>
<ul>
<li>Añadir el hook <code>shutdown</code>. Apagado, initscripts se basará en una copia guardada de initramfs y permitirá a <code>/usr</code> (y a la raíz) ser debidamente desmontada desde el VFS.</li>
<li>Añadir el hook <code>fsck</code>. Recomendado para todos, fundamental si quiere un <i>fsck</i>  al iniciar la partición <code>/usr</code>. Sin este hook, <code>/etc/rc.sysinit</code> comenzará <i>fsck</i> con <code>/usr</code> montada y en consecuencia fallará.</li>
<li>A partir de mkinitcpio 0.9.0: Agregue el hook <code>usr</code>, además de los hooks de arriba. Esto montará la partición <code>/usr</code>  después de 	que la partición raíz está montada. Antes de 0.9.0, el montaje de <code>/usr</code> sería automática si se encuentra en la raíz real <code>/etc/fstab</code>.</li>
</ul>
<h2>
<span id="Soluci.C3.B3n_de_problemas"></span><span class="mw-headline" id="Solución_de_problemas">Solución de problemas</span>
</h2>
<h3><span class="mw-headline" id="Extraer_la_imagen">Extraer la imagen</span></h3>
<p>Si usted es curioso y quiere saber qué hay dentro de la imagen initrd, se puede extraer, para una mirada al interior de los archivos.
</p>
<p>La imagen initrd es un archivo SVR4 CPIO, generado por el comando <code>find</code> y <code>bsdcpio</code> y se comprime con un de los formatos de compresión   compatibles con el kernel, llamados <b>gzip</b>, <b>bzip2</b>, <b>lzma</b>, <b>lzo</b> o <b>xz</b>.
</p>
<p>mkinitcpio incluye una herramienta llamada <code>lsinitcpio</code>, que muestra y extrae el contenido de la imagen initramfs.
</p>
<p>Usted puede listar los archivos de la imagen con:
</p>
<pre>$ lsinitcpio /boot/initramfs-linux.img
</pre>
<p>Y extraerlos en la carpeta actual:
</p>
<pre>$ lsinitcpio -x /boot/initramfs-linux.img
</pre>
<p>Usted también puede tener una lista un poco más amigable de las partes más importantes de la imagen:
</p>
<pre>$lsinitcpio -a /boot/initramfs-linux.imq
</pre>
<h2>
<span id="V.C3.A9ase_tambi.C3.A9n"></span><span class="mw-headline" id="Véase_también">Véase también</span>
</h2>
<ul><li>
<a href="/title/Boot_debugging" class="mw-redirect" title="Boot debugging">Boot debugging</a> - Depurar con GRUB</li></ul>
<h2><span class="mw-headline" id="Referencias">Referencias</span></h2>
<ul>
<li>Documentación del kernel de Linux: <a rel="nofollow" class="external text" href="https://www.kernel.org/doc/html/latest/filesystems/ramfs-rootfs-initramfs.html#what-is-initramfs">initramfs</a>
</li>
<li>Documentación del kernel de Linux: <a rel="nofollow" class="external text" href="https://www.kernel.org/doc/html/latest/admin-guide/initrd.html">initrd</a>
</li>
<li>Artículo de Wikipedia: <a rel="nofollow" class="external text" href="https://es.wikipedia.org/wiki/initrd">initrd</a>
</li>
</ul>
</div>
</div>
<div id="catlinks" class="catlinks" data-mw="interface">
<div id="mw-normal-catlinks" class="mw-normal-catlinks">
<a href="/title/Special:Categories" title="Special:Categories">Categories</a>: <ul>
<li><a href="/title/Category:Boot_process_(Espa%C3%B1ol)" title="Category:Boot process (Español)">Boot process (Español)</a></li>
<li><a href="/title/Category:Kernel_(Espa%C3%B1ol)" title="Category:Kernel (Español)">Kernel (Español)</a></li>
<li><a href="/title/Category:Arch_projects_(Espa%C3%B1ol)" title="Category:Arch projects (Español)">Arch projects (Español)</a></li>
<li><a href="/title/Category:Commands_(Espa%C3%B1ol)" title="Category:Commands (Español)">Commands (Español)</a></li>
</ul>
</div>
<div id="mw-hidden-catlinks" class="mw-hidden-catlinks mw-hidden-cats-hidden">Hidden categories: <ul>
<li><a href="/title/Category:Pages_with_broken_section_links" title="Category:Pages with broken section links">Pages with broken section links</a></li>
<li><a href="/title/Category:Pages_with_broken_package_links" title="Category:Pages with broken package links">Pages with broken package links</a></li>
</ul>
</div>
</div>
	</div>
</div>

<footer id="footer" class="mw-footer" role="contentinfo" style="margin: 0">
	<ul id="footer-info">
		<li>Retrieved from "<a dir="ltr" href="https://wiki.archlinux.org/index.php?title=Mkinitcpio_(Espa%C3%B1ol)&amp;oldid=664177">https://wiki.archlinux.org/index.php?title=Mkinitcpio_(Español)&amp;oldid=664177</a>"</li>
		<li id="footer-info-lastmod"> This page was last edited on 25 April 2021, at 12:08.</li>
		<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3 or later</a> unless otherwise noted.</li>
	<br>
</ul>
	<ul id="footer-places">
		<li id="footer-places-privacy"><a href="/title/ArchWiki:Privacy_policy" title="ArchWiki:Privacy policy">Privacy policy</a></li>
		<li id="footer-places-about"><a href="/title/ArchWiki:About" title="ArchWiki:About">About ArchWiki</a></li>
		<li id="footer-places-disclaimer"><a href="/title/ArchWiki:General_disclaimer" title="ArchWiki:General disclaimer">Disclaimers</a></li>
	</ul>
	<ul id="footer-icons" class="noprint">
		<li id="footer-copyrightico">
	</ul>
	<div style="clear: both;"></div>
</footer>



</body>
</html>
