<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<title>QEMU (Español) - ArchWiki</title>
<link rel="stylesheet" href="../ArchWikiOffline.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<meta name="generator" content="MediaWiki 1.35.0">
<meta name="referrer" content="no-referrer-when-downgrade">
<meta name="robots" content="noindex,follow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="/opensearch_desc.php" title="ArchWiki (en)">
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.archlinux.org/api.php?action=rsd">
<link rel="license" href="http://www.gnu.org/copyleft/fdl.html">
<link rel="alternate" type="application/atom+xml" title="ArchWiki Atom feed" href="/index.php?title=Special:RecentChanges&amp;feed=atom">
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-QEMU_Español rootpage-QEMU_Español skin-vector action-view skin-vector-legacy">
<div id="content" class="mw-body" role="main" style="margin: 0">
	<a id="top"></a>
	<div id="siteNotice" class="mw-body-content"></div>
	<div class="mw-indicators mw-body-content">
	</div>
	<h1 id="firstHeading" class="firstHeading" lang="en">QEMU (Español)</h1>
	<div id="bodyContent" class="mw-body-content">
		<div id="siteSub" class="noprint">From ArchWiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="#searchInput">Jump to search</a>
		<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<div class="warningbox">The printable version is no longer supported and may have rendering errors. Please update your browser bookmarks and please use the default browser print function instead.</div>
<div class="mw-parser-output">
<div class="archwiki-template-meta-related-articles-start">
<p>Artículos relacionados</p>
<ul>
<li><a href="/title/Category:Hypervisors" title="Category:Hypervisors">Category:Hypervisors</a></li>
<li><a href="/title/Libvirt" title="Libvirt">Libvirt</a></li>
</ul>
</div>
<p>De acuerdo con <a rel="nofollow" class="external text" href="https://wiki.qemu.org/Main_Page">la wiki de QEMU</a>, "QEMU es un emulador genérico y de código abierto de máquinas virtuales."
</p>
<p>Cuando se utiliza como un emulador de máquina, QEMU puede correr sistemas operativos y programas hechos para una máquina en particular (por ej. una placa ARM) en una máquina diferente (e.j. tu PC x86). Usando la traducción dinámica, se consigue un rendimiento muy bueno.
</p>
<p>QEMU puede usar hipervisores como <a href="/title/Xen" title="Xen">Xen</a> o <a href="/title/KVM" title="KVM">KVM</a> para utilizar las extensiones del procesador para la virtualización. Cuando se utiliza como virtualizador, QEMU alcanza un performance cercano a el rendimiento nativo ejecutando el código de invitado directamente en el CPU host.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading">
<input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none"><div class="toctitle" lang="en" dir="ltr">
<h2 id="mw-toc-heading">Contents</h2>
<span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span>
</div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Instalaci%C3%B3n"><span class="tocnumber">1</span> <span class="toctext">Instalación</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#front-ends_para_QEMU"><span class="tocnumber">2</span> <span class="toctext">front-ends para QEMU</span></a></li>
<li class="toclevel-1 tocsection-3">
<a href="#Creando_un_nuevo_sistema_virtualizado"><span class="tocnumber">3</span> <span class="toctext">Creando un nuevo sistema virtualizado</span></a>
<ul>
<li class="toclevel-2 tocsection-4">
<a href="#Creando_una_imagen_de_disco_duro"><span class="tocnumber">3.1</span> <span class="toctext">Creando una imagen de disco duro</span></a>
<ul>
<li class="toclevel-3 tocsection-5"><a href="#Superposici%C3%B3n_de_im%C3%A1genes_de_almacenamiento"><span class="tocnumber">3.1.1</span> <span class="toctext">Superposición de imágenes de almacenamiento</span></a></li>
<li class="toclevel-3 tocsection-6"><a href="#Cambiar_el_tama%C3%B1o_de_una_imagen"><span class="tocnumber">3.1.2</span> <span class="toctext">Cambiar el tamaño de una imagen</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-7"><a href="#Preparando_el_medio_de_instalaci%C3%B3n"><span class="tocnumber">3.2</span> <span class="toctext">Preparando el medio de instalación</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Instalando_el_sistema_operativo"><span class="tocnumber">3.3</span> <span class="toctext">Instalando el sistema operativo</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-9">
<a href="#Ejecuci%C3%B3n_del_sistema_virtualizado"><span class="tocnumber">4</span> <span class="toctext">Ejecución del sistema virtualizado</span></a>
<ul>
<li class="toclevel-2 tocsection-10"><a href="#Activar_KVM"><span class="tocnumber">4.1</span> <span class="toctext">Activar KVM</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#Habilitar_soporte_IOMMU_(Intel_VT-d/AMD-Vi)"><span class="tocnumber">4.2</span> <span class="toctext">Habilitar soporte IOMMU (Intel VT-d/AMD-Vi)</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-12">
<a href="#Mover_datos_entre_el_host_y_el_Sistema_Operativo_hu%C3%A9sped"><span class="tocnumber">5</span> <span class="toctext">Mover datos entre el host y el Sistema Operativo huésped</span></a>
<ul>
<li class="toclevel-2 tocsection-13"><a href="#Red"><span class="tocnumber">5.1</span> <span class="toctext">Red</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="#Servidor_SMB_incorporado_de_QEMU"><span class="tocnumber">5.2</span> <span class="toctext">Servidor SMB incorporado de QEMU</span></a></li>
<li class="toclevel-2 tocsection-15">
<a href="#Montaje_de_una_partici%C3%B3n_dentro_de_una_imagen_de_disco_raw"><span class="tocnumber">5.3</span> <span class="toctext">Montaje de una partición dentro de una imagen de disco raw</span></a>
<ul>
<li class="toclevel-3 tocsection-16"><a href="#Con_la_especificaci%C3%B3n_manual_del_desplazamiento_de_bytes"><span class="tocnumber">5.3.1</span> <span class="toctext">Con la especificación manual del desplazamiento de bytes</span></a></li>
<li class="toclevel-3 tocsection-17"><a href="#Con_las_particiones_autodetecting_del_m%C3%B3dulo_de_bucle_(loop)"><span class="tocnumber">5.3.2</span> <span class="toctext">Con las particiones autodetecting del módulo de bucle (loop)</span></a></li>
<li class="toclevel-3 tocsection-18"><a href="#Con_kpartx"><span class="tocnumber">5.3.3</span> <span class="toctext">Con kpartx</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-19"><a href="#Montar_una_partici%C3%B3n_dentro_de_una_imagen_qcow2"><span class="tocnumber">5.4</span> <span class="toctext">Montar una partición dentro de una imagen qcow2</span></a></li>
<li class="toclevel-2 tocsection-20">
<a href="#Utilizar_cualquier_partici%C3%B3n_real_como_la_%C3%BAnica_partici%C3%B3n_primaria_de_una_imagen_de_disco_duro"><span class="tocnumber">5.5</span> <span class="toctext">Utilizar cualquier partición real como la única partición primaria de una imagen de disco duro</span></a>
<ul>
<li class="toclevel-3 tocsection-21"><a href="#Especificar_el_kernel_y_el_initrd_manualmente"><span class="tocnumber">5.5.1</span> <span class="toctext">Especificar el kernel y el initrd manualmente</span></a></li>
<li class="toclevel-3 tocsection-22"><a href="#Simular_disco_virtual_con_MBR_usando_RAID_lineal"><span class="tocnumber">5.5.2</span> <span class="toctext">Simular disco virtual con MBR usando RAID lineal</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-23">
<a href="#Redes"><span class="tocnumber">6</span> <span class="toctext">Redes</span></a>
<ul>
<li class="toclevel-2 tocsection-24"><a href="#Advertencia_de_direcci%C3%B3n_a_nivel_de_enlace"><span class="tocnumber">6.1</span> <span class="toctext">Advertencia de dirección a nivel de enlace</span></a></li>
<li class="toclevel-2 tocsection-25"><a href="#Redes_en_modo_de_usuario"><span class="tocnumber">6.2</span> <span class="toctext">Redes en modo de usuario</span></a></li>
<li class="toclevel-2 tocsection-26">
<a href="#Tap_de_red_con_QEMU"><span class="tocnumber">6.3</span> <span class="toctext">Tap de red con QEMU</span></a>
<ul>
<li class="toclevel-3 tocsection-27"><a href="#Red_de_host_solamente"><span class="tocnumber">6.3.1</span> <span class="toctext">Red de host solamente</span></a></li>
<li class="toclevel-3 tocsection-28"><a href="#Red_interna"><span class="tocnumber">6.3.2</span> <span class="toctext">Red interna</span></a></li>
<li class="toclevel-3 tocsection-29"><a href="#Redes_puenteadas_usando_qemu-bridge-helper"><span class="tocnumber">6.3.3</span> <span class="toctext">Redes puenteadas usando qemu-bridge-helper</span></a></li>
<li class="toclevel-3 tocsection-30"><a href="#Creaci%C3%B3n_manual_del_puente"><span class="tocnumber">6.3.4</span> <span class="toctext">Creación manual del puente</span></a></li>
<li class="toclevel-3 tocsection-31"><a href="#Compartici%C3%B3n_de_red_entre_dispositivo_f%C3%ADsico_y_un_dispositivo_de_toque_a_trav%C3%A9s_de_iptables"><span class="tocnumber">6.3.5</span> <span class="toctext">Compartición de red entre dispositivo físico y un dispositivo de toque a través de iptables</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-32">
<a href="#Trabajo_en_red_con_VDE2"><span class="tocnumber">6.4</span> <span class="toctext">Trabajo en red con VDE2</span></a>
<ul>
<li class="toclevel-3 tocsection-33"><a href="#%C2%BFQu%C3%A9_es_VDE?"><span class="tocnumber">6.4.1</span> <span class="toctext">¿Qué es VDE?</span></a></li>
<li class="toclevel-3 tocsection-34"><a href="#Basics"><span class="tocnumber">6.4.2</span> <span class="toctext">Basics</span></a></li>
<li class="toclevel-3 tocsection-35"><a href="#Startup_scripts"><span class="tocnumber">6.4.3</span> <span class="toctext">Startup scripts</span></a></li>
<li class="toclevel-3 tocsection-36"><a href="#M%C3%A9todo_alternativo"><span class="tocnumber">6.4.4</span> <span class="toctext">Método alternativo</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-37">
<a href="#Puente_VDE2"><span class="tocnumber">6.5</span> <span class="toctext">Puente VDE2</span></a>
<ul>
<li class="toclevel-3 tocsection-38"><a href="#Conceptos_b%C3%A1sicos"><span class="tocnumber">6.5.1</span> <span class="toctext">Conceptos básicos</span></a></li>
<li class="toclevel-3 tocsection-39"><a href="#Startup_scripts_2"><span class="tocnumber">6.5.2</span> <span class="toctext">Startup scripts</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-40">
<a href="#Gr%C3%A1ficos"><span class="tocnumber">7</span> <span class="toctext">Gráficos</span></a>
<ul>
<li class="toclevel-2 tocsection-41"><a href="#std"><span class="tocnumber">7.1</span> <span class="toctext">std</span></a></li>
<li class="toclevel-2 tocsection-42">
<a href="#qxl"><span class="tocnumber">7.2</span> <span class="toctext">qxl</span></a>
<ul>
<li class="toclevel-3 tocsection-43"><a href="#SPICE"><span class="tocnumber">7.2.1</span> <span class="toctext">SPICE</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-44"><a href="#vmware"><span class="tocnumber">7.3</span> <span class="toctext">vmware</span></a></li>
<li class="toclevel-2 tocsection-45"><a href="#virtio"><span class="tocnumber">7.4</span> <span class="toctext">virtio</span></a></li>
<li class="toclevel-2 tocsection-46"><a href="#cirrus"><span class="tocnumber">7.5</span> <span class="toctext">cirrus</span></a></li>
<li class="toclevel-2 tocsection-47"><a href="#none"><span class="tocnumber">7.6</span> <span class="toctext">none</span></a></li>
<li class="toclevel-2 tocsection-48"><a href="#vnc"><span class="tocnumber">7.7</span> <span class="toctext">vnc</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-49">
<a href="#Audio"><span class="tocnumber">8</span> <span class="toctext">Audio</span></a>
<ul>
<li class="toclevel-2 tocsection-50"><a href="#Host"><span class="tocnumber">8.1</span> <span class="toctext">Host</span></a></li>
<li class="toclevel-2 tocsection-51"><a href="#Invitado"><span class="tocnumber">8.2</span> <span class="toctext">Invitado</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-52">
<a href="#Instalaci%C3%B3n_de_controladores_virtio"><span class="tocnumber">9</span> <span class="toctext">Instalación de controladores virtio</span></a>
<ul>
<li class="toclevel-2 tocsection-53"><a href="#Preparando_a_Arch_Linux_como_invitado"><span class="tocnumber">9.1</span> <span class="toctext">Preparando a Arch Linux como invitado</span></a></li>
<li class="toclevel-2 tocsection-54">
<a href="#Preparar_un_invitado_de_Windows"><span class="tocnumber">9.2</span> <span class="toctext">Preparar un invitado de Windows</span></a>
<ul>
<li class="toclevel-3 tocsection-55">
<a href="#Bloquear_controladores_de_dispositivo"><span class="tocnumber">9.2.1</span> <span class="toctext">Bloquear controladores de dispositivo</span></a>
<ul>
<li class="toclevel-4 tocsection-56"><a href="#Nueva_instalaci%C3%B3n_de_Windows"><span class="tocnumber">9.2.1.1</span> <span class="toctext">Nueva instalación de Windows</span></a></li>
<li class="toclevel-4 tocsection-57"><a href="#Cambiar_la_m%C3%A1quina_virtual_existente_de_Windows_para_utilizar_virtio"><span class="tocnumber">9.2.1.2</span> <span class="toctext">Cambiar la máquina virtual existente de Windows para utilizar virtio</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-58"><a href="#Controladores_de_red"><span class="tocnumber">9.2.2</span> <span class="toctext">Controladores de red</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-59"><a href="#Preparaci%C3%B3n_de_FreeBSD_como_invitado"><span class="tocnumber">9.3</span> <span class="toctext">Preparación de FreeBSD como invitado</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-60">
<a href="#Consejos_y_trucos"><span class="tocnumber">10</span> <span class="toctext">Consejos y trucos</span></a>
<ul>
<li class="toclevel-2 tocsection-61">
<a href="#Inicio_de_las_m%C3%A1quinas_virtuales_QEMU_en_el_arranque"><span class="tocnumber">10.1</span> <span class="toctext">Inicio de las máquinas virtuales QEMU en el arranque</span></a>
<ul>
<li class="toclevel-3 tocsection-62"><a href="#Con_libvirt"><span class="tocnumber">10.1.1</span> <span class="toctext">Con libvirt</span></a></li>
<li class="toclevel-3 tocsection-63"><a href="#Script_personalizado"><span class="tocnumber">10.1.2</span> <span class="toctext">Script personalizado</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-64"><a href="#Integraci%C3%B3n_del_rat%C3%B3n"><span class="tocnumber">10.2</span> <span class="toctext">Integración del ratón</span></a></li>
<li class="toclevel-2 tocsection-65"><a href="#Dispositivo_USB_del_host_de_paso"><span class="tocnumber">10.3</span> <span class="toctext">Dispositivo USB del host de paso</span></a></li>
<li class="toclevel-2 tocsection-66"><a href="#Habilitar_KSM"><span class="tocnumber">10.4</span> <span class="toctext">Habilitar KSM</span></a></li>
<li class="toclevel-2 tocsection-67"><a href="#Multi-monitor_support"><span class="tocnumber">10.5</span> <span class="toctext">Multi-monitor support</span></a></li>
<li class="toclevel-2 tocsection-68"><a href="#Copiar_y_pegar"><span class="tocnumber">10.6</span> <span class="toctext">Copiar y pegar</span></a></li>
<li class="toclevel-2 tocsection-69">
<a href="#Notas_espec%C3%ADficas_de_Windows"><span class="tocnumber">10.7</span> <span class="toctext">Notas específicas de Windows</span></a>
<ul>
<li class="toclevel-3 tocsection-70"><a href="#Inicio_r%C3%A1pido"><span class="tocnumber">10.7.1</span> <span class="toctext">Inicio rápido</span></a></li>
<li class="toclevel-3 tocsection-71"><a href="#Protocolo_de_escritorio_remoto"><span class="tocnumber">10.7.2</span> <span class="toctext">Protocolo de escritorio remoto</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-72">
<a href="#Soluci%C3%B3n_de_problemas"><span class="tocnumber">11</span> <span class="toctext">Solución de problemas</span></a>
<ul>
<li class="toclevel-2 tocsection-73"><a href="#La_m%C3%A1quina_virtual_virtual_corre_muy_lento"><span class="tocnumber">11.1</span> <span class="toctext">La máquina virtual virtual corre muy lento</span></a></li>
<li class="toclevel-2 tocsection-74"><a href="#El_cursor_del_rat%C3%B3n_est%C3%A1_nervioso_o_err%C3%A1tico"><span class="tocnumber">11.2</span> <span class="toctext">El cursor del ratón está nervioso o errático</span></a></li>
<li class="toclevel-2 tocsection-75"><a href="#El_cursor_no_es_visible"><span class="tocnumber">11.3</span> <span class="toctext">El cursor no es visible</span></a></li>
<li class="toclevel-2 tocsection-76"><a href="#No_se_puede_mover_/_adjuntar_el_cursor"><span class="tocnumber">11.4</span> <span class="toctext">No se puede mover / adjuntar el cursor</span></a></li>
<li class="toclevel-2 tocsection-77"><a href="#El_teclado_parece_roto_%C3%B3_las_teclas_de_flecha_no_funcionan"><span class="tocnumber">11.5</span> <span class="toctext">El teclado parece roto ó las teclas de flecha no funcionan</span></a></li>
<li class="toclevel-2 tocsection-78"><a href="#Pantalla_de_invitado_estirada_en_el_tama%C3%B1o_de_la_ventana"><span class="tocnumber">11.6</span> <span class="toctext">Pantalla de invitado estirada en el tamaño de la ventana</span></a></li>
<li class="toclevel-2 tocsection-79"><a href="#ioctl(KVM_CREATE_VM)_failed:_16_Device_or_resource_busy"><span class="tocnumber">11.7</span> <span class="toctext">ioctl(KVM_CREATE_VM) failed: 16 Device or resource busy</span></a></li>
<li class="toclevel-2 tocsection-80"><a href="#Mensaje_de_error_libgfapi"><span class="tocnumber">11.8</span> <span class="toctext">Mensaje de error libgfapi</span></a></li>
<li class="toclevel-2 tocsection-81"><a href="#Kernel_panic_en_entornos_live"><span class="tocnumber">11.9</span> <span class="toctext">Kernel panic en entornos live</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-82"><a href="#Ver_tambi%C3%A9n"><span class="tocnumber">12</span> <span class="toctext">Ver también</span></a></li>
</ul>
</div>

<h2>
<span id="Instalaci.C3.B3n"></span><span class="mw-headline" id="Instalación">Instalación</span>
</h2>
<p><a href="/title/Help:Reading_(Espa%C3%B1ol)#Instalaci.C3.B3n_de_paquetes" title="Help:Reading (Español)">Instale</a> el paquete <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu">qemu</a></span> (ó <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-headless">qemu-headless</a></span> para la versión sin GUI) y los paquetes opcionales para tus necesidades:
</p>
<ul>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-arch-extra">qemu-arch-extra</a></span> - Soporte extra para arquitecturas</li>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-block-gluster">qemu-block-gluster</a></span> - Soporte para bloque glusterfs</li>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-block-iscsi">qemu-block-iscsi</a></span> - Soporte para bloque iSCSI</li>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-block-rbd">qemu-block-rbd</a></span> - Soporte para bloque RBD</li>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=samba">samba</a></span> - SMB/ Soporte para servidor CIFS</li>
</ul>
<h2><span class="mw-headline" id="front-ends_para_QEMU">front-ends para QEMU</span></h2>
<p>A diferencia de otros programas de virtualización como <a href="/title/VirtualBox" title="VirtualBox">VirtualBox</a> y <a href="/title/VMware" title="VMware">VMware</a>, QEMU no proporciona una interfaz gráfica de usuario para administrar máquinas virtuales (a parte de la ventana que aparece cuando se ejecuta una máquina virtual), tampoco proporciona una forma de crear una máquina virtual persistente con valores guardados. Todos los parámetros para ejecutar una máquina virtual deben especificarse en la línea de comandos en cada puesta en marcha, a menos que haga un script personalizadp para iniciar su máquina(s) virtual. Sin embargo, hay  varios front-end GUI para QEMU: 
</p>
<ul>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/qemu-launcher/">qemu-launcher</a></span><sup><small>AUR</small></sup>
</li>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/qtemu/">qtemu</a></span><sup><small>AUR</small></sup>
</li>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/aqemu/">aqemu</a></span><sup><small>AUR</small></sup>
</li>
</ul>
<p>front-ends con soporte para QEMU están disponibles por <a href="/title/Libvirt" title="Libvirt">libvirt</a>.
</p>
<h2><span class="mw-headline" id="Creando_un_nuevo_sistema_virtualizado">Creando un nuevo sistema virtualizado</span></h2>
<h3><span class="mw-headline" id="Creando_una_imagen_de_disco_duro">Creando una imagen de disco duro</span></h3>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Sugerencia:</strong> Consulte la <a rel="nofollow" class="external text" href="https://en.wikibooks.org/wiki/QEMU/Images">Wiki de QEMU</a> para más información sobre imágenes de QEMU.</div>
<p>Para ejecutar QMEU necesitarás una imagen de disco duro, a menos que estés cargando un sistema en vivo desde el CD-ROM ó la red (y no para instalar un sistema operativo en una imagen de disco duro). Una imagen de disco es un archivo que almacena los contenidos del disco duro emulado.
</p>
<p>Una imagen de disco puede ser en "crudo", de manera que, literalemte, byte por byte es lo mismo que el cliente ve, y siempre utilizará toda la capacidad del disco duro del disco duro invitado en el host. Este método proporciona la menor sobrecarga de Entrada / Salida, pero puede desperdiciar una gran cantidad de espacio, ya que el espacio no utilizado por el invitado no se puede utilizar en el host.  
</p>
<p>Por otra parte, la imagen de disco duro puede estar en un formato tal como el de <i>qcow2</i> el cuál únicamente asigna espacio a el archivo de la imagen cuando el SO invitado está escribiendo en los sectores del disco virtual. La imagen aparece como el tamaño total del sistema operativo huésped, a pesar que puede tomar hasta una cantidad muy pequeña de espacio en el sistema host. El uso de este formato en lugar de el "crudo" probablemente afecte el rendimiento. 
</p>
<p>QEMU proporciona el <code>qemu-img</code> comando para crear imagenes de disco.
Por ejemplo, para crear una imagen de 4GB en formato "crudo":
</p>
<pre>$ qemu-img create -f raw <i>image_file</i> 4G
</pre>
<p>Se puede uiltizar <code>-f qcow2</code> para crear un disco <i>qcow2</i> en su lugar. 
</p>
<p>También puedes simplemente crear una imagen "cruda" meidante la creación de un archivo del tamaño necesitado usando <code>dd</code> ó <code>fallocate</code>.}}
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Advertencia:</strong> Si almacenas una imágen de disco en un sistema de archivos <a href="/title/Btrfs" title="Btrfs">Btrfs</a>, deberías considerar deshabilitar <a href="/title/Btrfs#Copy-on-Write_(CoW)" title="Btrfs">Copy-on-Write</a> para el directorio antes de crear imágenes.</div>
<h4>
<span id="Superposici.C3.B3n_de_im.C3.A1genes_de_almacenamiento"></span><span class="mw-headline" id="Superposición_de_imágenes_de_almacenamiento">Superposición de imágenes de almacenamiento</span>
</h4>
<p>Puede crear una imagen de almacenamiento una vez (la imagen de respaldo) y hacer que QEMU mantenga mutaciones a esta imagen en una imagen de superposición. Esto le permite volver a un estado anterior de esta imagen de almacenamiento. Puede volver a crear una nueva imagen de superposición en el momento en que desea revertir en función de la imagen de respaldo original.
</p>
<p>Para crear una imagen de superposición, ingrese el comando:
</p>
<p> $ Qemu-img create -o backing_file = <i> img1.raw </i>, backing_fmt = <i> raw </i> -f <i> qcow2 </i> <i> img1.cow </i>
</p>
<p>Después de eso, puede ejecutar su máquina virtual como de costumbre (ver <a href="#Ejecuci%C3%B3n_del_sistema_virtualizado">#Ejecución del sistema virtualizado</a>):
</p>
<p> $ Qemu-system-i386 <i> img1.cow </i>
</p>
<p>La imagen de respaldo se dejará intacta y se registrarán mutaciones en este almacenamiento en el archivo de imagen de superposición.
</p>
<p>Cuando cambia la ruta de acceso a la imagen de respaldo, se requiere reparación.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Advertencia:</strong>  La ruta del sistema de archivos absoluto de la imagen de respaldo se almacena en el archivo de imagen de superposición (binario)). Cambiar el trayecto de la imagen de respaldo requiere un esfuerzo.</div>
<p>Asegúrese de que la ruta de la imagen de respaldo original sigue conduciendo a esta imagen. Si es necesario, haga un enlace simbólico en la ruta original a la nueva ruta. A continuación, emita un comando como:
</p>
<p> $ Qemu-img rebase -b <i> /new/img1.raw </i> <i> /new/img1.cow </i>
</p>
<p>A su discreción, usted puede alternativamente realizar un rebase 'inseguro' donde no se comprueba la ruta anterior a la imagen de respaldo:
</p>
<p> $ Qemu-img rebase -u -b <i> /new/img1.raw </i> <i> /new/img1.cow </i>
</p>
<h4>
<span id="Cambiar_el_tama.C3.B1o_de_una_imagen"></span><span class="mw-headline" id="Cambiar_el_tamaño_de_una_imagen">Cambiar el tamaño de una imagen</span>
</h4>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Advertencia:</strong> Cambiar el tamaño de una imagen que contiene un sistema de arranque NTFS podría hacer el sistema operativo instalado <b>no arrancable</b>. Para una explicación completa y solucioón alternativa mira <a rel="nofollow" class="external autonumber" href="https://web.archive.org/web/20180319230757/http://tjworld.net/wiki/Howto/ResizeQemuDiskImages">[1]</a>.</div>
<p>El ejecutable <code>qemu-img</code> tiene la opción <code>resize</code>, que permite redimensionar fácilmente una imagen de disco duro. Funciona tanto para  <i>raw</i> como para <i>qcow2</i>. Por ejemplo, para aumentar el espacio de imagen en 10GB, ingresa:
</p>
<pre>$ qemu-img resize <i>disk_image</i> +10G
</pre>
<p>Después de ampliar la imagen de disco, debe utilizar el sistema de archivos y las herramientas de particionamiento dentro de la máquina virtual para comenzar a utilizar el nuevo espacio. Al reducir una imagen de disco, primero debe reducir los sistemas de archivos y los tamaños de partición asignados usando el sistema de archivos y las herramientas de partición dentro de la máquina virtual y luego reducir la imagen del disco en consecuencia, de lo contrario reducir la imagen del disco resultará en ¡pérdida de datos!
</p>
<h3>
<span id="Preparando_el_medio_de_instalaci.C3.B3n"></span><span class="mw-headline" id="Preparando_el_medio_de_instalación">Preparando el medio de instalación</span>
</h3>
<p>Para instalar un sistema operativo en su imagen de disco, necesita el medio de instalación (por ejemplo, disco óptico, unidad USB o imagen ISO) para el sistema operativo. El soporte de instalación no debe montarse porque QEMU accede directamente al medio.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Sugerencia:</strong>  Si utiliza un disco óptico, es una buena idea volcar primero los medios a un archivo porque esto mejora el rendimiento y no requiere que tenga acceso directo a los dispositivos (es decir, puede ejecutar QEMU como un usuario normal sin tener Para cambiar permisos de acceso en el archivo de dispositivo del medio). Por ejemplo, si el nodo de dispositivo de CD-ROM tiene el nombre <code>/dev/cdrom</code>, puede volcarlo a un archivo de comandos: <pre>$ dd if=/dev/cdrom of=<i>Cd_image.iso</i></pre>
</div>
<h3><span class="mw-headline" id="Instalando_el_sistema_operativo">Instalando el sistema operativo</span></h3>
<p>Esta es la primera vez que necesitará iniciar el emulador. Para instalar el sistema operativo en la imagen de disco, debe adjuntar la imagen de disco y el medio de instalación a la máquina virtual y hacer que arranque desde el soporte de instalación.
</p>
<p>Por ejemplo, en invitados i386, para instalar desde un archivo ISO de arranque como CD-ROM y una imagen de disco sin formato:
</p>
<p> $ Qemu-system-i386 -cdrom <i> iso_image </i> - orden de arranque = d -drive file = <i> disk_image </i>, format = raw
</p>
<p>Consulte <code> qemu (1)</code> para obtener más información sobre cómo cargar otros tipos de medios (como disquetes, imágenes de disco o unidades físicas) y <a href="#Ejecuci%C3%B3n_del_sistema_virtualizado">#Ejecución del sistema virtualizado</a> para otras opciones útiles.
</p>
<p>Una vez que el sistema operativo haya finalizado de instalar, la imagen de QEMU se puede iniciar directamente (ver <a href="#Ejecuci%C3%B3n_del_sistema_virtualizado">#Ejecución del sistema virtualizado</a>).
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Advertencia:</strong>  De forma predeterminada, sólo se asignan 128 MB de memoria a la máquina. La cantidad de memoria se puede ajustar con el interruptor <code> -m</code>, por ejemplo <code> -m 512M</code> o <code> -m 2G</code>.</div>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Sugerencia:</strong> 
<ul>
<li>En lugar de especificar <code>-boot order = x</code>, algunos usuarios pueden sentirse más cómodos usando un menú de arranque: <code>-boot menu = on</code>, al menos durante la configuración y la experimentación.</li>
<li>Si necesita reemplazar disquetes o CD como parte del proceso de instalación, puede usar el monitor de la máquina QEMU (presione <code> Ctrl + Alt + 2</code> en la ventana de la máquina virtual) para quitar y conectar dispositivos de almacenamiento a un máquina virtual. Escriba <code> info block</code> para ver los dispositivos de bloque y use el comando <code> change</code> para intercambiar un dispositivo. Pulse <code> Ctrl + Alt + 1</code> para volver a la máquina virtual.</li>
</ul>
</div>
<h2>
<span id="Ejecuci.C3.B3n_del_sistema_virtualizado"></span><span class="mw-headline" id="Ejecución_del_sistema_virtualizado">Ejecución del sistema virtualizado</span>
</h2>
<p>Los binarios <code>qemu-system-*</code> (por e.j. <code>qemu-system-i386</code> ó <code>qemu-system-x86_64</code>, dependiendo de la arquitectura del huésped) se usan para ejecutar el sistema virtualizado. El uso es:
</p>
<pre>$ qemu-system-i386 <i>options</i> <i>disk_image</i>
</pre>
<p>Las opciones son las mismas para todos los binarios <code>qemu-system-*</code>, mira <code>qemu(1)</code> para más información sobre todas las opciones.
</p>
<p>Por defecto, QEMU mostrará la salida de video de la máquina virtual en una ventana. Una cosa a considerar: al hacer click dentro de la ventana de QMEU, el puntero del cursor será capturado. Para liberarlo presione <code>Ctrl+Alt+g</code>.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Advertencia:</strong> QEMU nunca debe ejecutarse como root. Si se debe iniciar en root, deberá usar la opción <code>-runas</code> para que QEMU utilice privilegios de root.</div>
<h3><span class="mw-headline" id="Activar_KVM">Activar KVM</span></h3>
<p>KVM debe ser soportado por su procesador y kernel, y necesariamente los <a href="/title/Kernel_modules" class="mw-redirect" title="Kernel modules">kernel modules</a> deben ser cargados. Mira <a href="/title/KVM" title="KVM">KVM</a> para más información.
</p>
<p>Para iniciar QEMU en modo KVM, adjunta <code>-enable-kvm</code> a las opciones de inicio adicionales. Para verificar si KVM está activado para ejecutar una máquina virtual, ingresa a la wiki de QEMU <a rel="nofollow" class="external text" href="https://en.wikibooks.org/wiki/QEMU/Monitor">Monitor</a>, usando <code>Ctrl+Alt+Shift+2</code>, e ingresando <code>info kvm</code>.  
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> 
<ul>
<li>Si inicia su máquina virtual con una herramienta GUI y experimenta un rendimiento muy malo, debe verificar el soporte adecuado de KVM.</li>
<li>KVM necesita activarse en orden de iniciar adecuadamente Windows 7 y Windows 8 sin <i>pantallazo azul</i>.</li>
</ul>
</div>
<h3>
<span id="Habilitar_soporte_IOMMU_.28Intel_VT-d.2FAMD-Vi.29"></span><span class="mw-headline" id="Habilitar_soporte_IOMMU_(Intel_VT-d/AMD-Vi)">Habilitar soporte IOMMU (Intel VT-d/AMD-Vi)</span>
</h3>
<p>Usando IOMMU (unidad de gestión de memoria de entrada y salida) se abre a las caraterísticas como el paso del PCI y la protección de la memoria de dispositivos defectuosos o maliciosos, mira <a href="https://en.wikipedia.org/wiki/Input-output_memory_management_unit#Advantages" class="extiw" title="wikipedia:Input-output memory management unit">wikipedia:Input-output memory management unit#Advantages</a> y <a rel="nofollow" class="external text" href="https://www.quora.com/Memory-Management-computer-programming/Could-you-explain-IOMMU-in-plain-English">Memory Management (computer programming): Could you explain IOMMU in plain English?</a>.
</p>
<p>Para habilitar IOMMU:
</p>
<ol>
<li>Asegure que AMD-Vi/Intel VT-d es soportado por el CPU y es habilitado en la configuración de BIOS.</li>
<li>Agregue <code>intel_iommu=on</code> si tienes un procesador Intel ó <code>amd_iommu=on</code> si tienes un procesador AMD en los parámetros del kernel (<a href="/title/Kernel_parameters" title="Kernel parameters">kernel parameters</a>)</li>
<li>Reinicie y asegure que IOMMU está habilitado verificando <code>dmesg</code> para <code>DMAR</code>: <code>[0.000000] DMAR: IOMMU enabled</code>
</li>
<li>Añade <code>-device intel-iommu</code> para crear el dispositivo IOMMU:</li>
</ol>
<pre>$ qemu-system-i386 -enable-kvm -machine q35,accel=kvm -device intel-iommu ..
</pre>
<h2>
<span id="Mover_datos_entre_el_host_y_el_Sistema_Operativo_hu.C3.A9sped"></span><span class="mw-headline" id="Mover_datos_entre_el_host_y_el_Sistema_Operativo_huésped">Mover datos entre el host y el Sistema Operativo huésped</span>
</h2>
<h3><span class="mw-headline" id="Red">Red</span></h3>
<p>Los datos pueden compartirse entre el host y el sistema operativo huésped usando cualquier protocolo de red que pueda transferir archivos, como <a href="/title/NFS" title="NFS">NFS</a>, <a href="/title/SMB" class="mw-redirect" title="SMB">SMB</a>, <a href="https://en.wikipedia.org/wiki/Network_Block_Device" class="extiw" title="wikipedia:Network Block Device">NBD</a>, HTTP, <a href="/title/Very_Secure_FTP_Daemon" title="Very Secure FTP Daemon">FTP</a>, ó <a href="/title/SSH" class="mw-redirect" title="SSH">SSH</a>, siempre que haya configurado la red apropiadamente y haya habilitado los servicios apropiados. 
</p>
<p>La red por defecto del modo de usuario permite al huésped acceder al sistema operativo host en la dirección IP 10.0.2.2. Todos los servidores que se estén ejecutando en el sistema operativo anfitrión, como un servidor SSH o un servidor SMB, estarán accesibles en esta dirección IP. Así que en los invitados, puede montar los directorios exportados en el host a través de <a href="/title/SMB" class="mw-redirect" title="SMB">SMB</a> o <a href="/title/NFS" title="NFS">NFS</a>, o puede acceder al servidor HTTP del host, etc.
No será posible que el sistema operativo anfitrión acceda a los servidores que se ejecutan en el sistema operativo invitado, pero esto puede hacerse con otras configuraciones de red (consulte <a href="#Tap_de_red_con_QEMU">#Tap de red con QEMU</a>).
</p>
<h3><span class="mw-headline" id="Servidor_SMB_incorporado_de_QEMU">Servidor SMB incorporado de QEMU</span></h3>
<p>La documentación de QEMU dice que tiene un servidor SMB "incorporado", pero en realidad acaba de iniciar <a href="/title/Samba" title="Samba">Samba</a> con un archivo <code> smb.conf</code> generado automáticamente ubicado en <code>/tmp/qemu- Smb.<i>Pid</i>-0/smb.conf</code> y lo hace accesible para el invitado en una dirección IP diferente (10.0.2.4 por defecto). Esto sólo funciona para la red de usuarios, y esto no es necesariamente muy útil ya que el invitado también puede acceder al servicio normal <a href="/title/Samba" title="Samba">Samba</a> en el host si ha configurado acciones en él.
</p>
<p>Para habilitar esta característica, inicie QEMU con un comando como:
</p>
<pre>$ qemu-system-i386 <i>disk_image</i> -net nic -net user,smb=<i>shared_dir_path</i>
</pre>
<p>donde <code><i>shared_dir_path</i></code> es un directorio que quieres compartir entre huésped y el host.
</p>
<p>Luego, en el invitado, podrá acceder al directorio compartido del host 10.0.2.4 con el nombre de recurso "qemu". Por ejemplo, en el Explorador de Windows iría a <code> \\ 10.0.2.4 \ qemu</code>.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> 
<ul>
<li>Si estás usando opciones de compartir varias veces como <code>-net user, smb=<i> shared_dir_path1 </i> -net user, smb=<i> shared_dir_path2 </i></code> ó <code>-net user , Smb = <i> shared_dir_path1 </i>, smb = <i> shared_dir_path2 </i></code> entonces solo compartirá el último definido.</li>
<li>Si no puede acceder a la carpeta compartida y el sistema invitado es Windows, compruebe que está habilitado el protocolo <a rel="nofollow" class="external text" href="http://ecross.mvps.org/howto/enable-netbios-over-tcp-ip-with-windows.htm">NetBIOS </a> Y que un cortafuegos no bloquea los puertos <a rel="nofollow" class="external autonumber" href="https://technet.microsoft.com/en-us/library/cc940063.aspx">[2]</a> utilizados por el protocolo NetBIOS.</li>
</ul>
</div>
<h3>
<span id="Montaje_de_una_partici.C3.B3n_dentro_de_una_imagen_de_disco_raw"></span><span class="mw-headline" id="Montaje_de_una_partición_dentro_de_una_imagen_de_disco_raw">Montaje de una partición dentro de una imagen de disco raw</span>
</h3>
<p>Cuando la máquina virtual no se está ejecutando, es posible montar las particiones que están dentro de un archivo de imagen de disco sin formato configurándolas como dispositivos de bucle invertido. Esto no funciona con imágenes de disco en formatos especiales, como qcow2, aunque se pueden montar usando <code>qemu-nbd</code>.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Advertencia:</strong>  Debe asegurarse de desmontar las particiones antes de ejecutar la máquina virtual de nuevo. De lo contrario, es muy probable que ocurra la corrupción de datos.</div>
<h4>
<span id="Con_la_especificaci.C3.B3n_manual_del_desplazamiento_de_bytes"></span><span class="mw-headline" id="Con_la_especificación_manual_del_desplazamiento_de_bytes">Con la especificación manual del desplazamiento de bytes</span>
</h4>
<p>Una forma de montar una partición de imagen de disco es montar la imagen de disco en un cierto desplazamiento usando un comando como el siguiente:
</p>
<pre>$ mount -o loop, offset = 32256 <i>disk_image</i> <i>mountpoint</i>
</pre>
<p>La opción <code>offset = 32256</code> se pasa realmente al programa <code>losetup</code> para configurar un dispositivo de bucle invertido que empieza en el desplazamiento de byte 32256 del archivo y continúa hasta el final. A continuación, se monta este dispositivo de bucle invertido. También puede utilizar la opción <code>sizelimit</code> para especificar el tamaño exacto de la partición, pero esto normalmente no es necesario.
</p>
<p>Dependiendo de la imagen del disco, la partición necesaria no se puede iniciar en el desplazamiento 32256. Ejecute <code>fdisk -l <i> disk_image </i></code> para ver las particiones de la imagen. Fdisk da las compensaciones de inicio y fin en sectores de 512 bytes, así que multiplique por 512 para obtener el desplazamiento correcto para pasar a <code>mount</code>.
</p>
<h4>
<span id="Con_las_particiones_autodetecting_del_m.C3.B3dulo_de_bucle_.28loop.29"></span><span class="mw-headline" id="Con_las_particiones_autodetecting_del_módulo_de_bucle_(loop)">Con las particiones autodetecting del módulo de bucle (loop)</span>
</h4>
<p>El controlador de bucle de Linux realmente admite particiones en dispositivos de bucle invertido, pero está desactivado de forma predeterminada. Para habilitarlo, haga lo siguiente:
</p>
<ul>
<li>Deshacerse de todos los dispositivos de bucle invertido (desmontar todas las imágenes montadas, etc.).</li>
<li>
<a href="/title/Kernel_modules#_Manual_module_handling" class="mw-redirect" title="Kernel modules">Unload</a> el módulo de kernel <code>loop</code> y cargarlo con el conjunto de parámetros <code>max_part = 15</code>. Además, el número máximo de dispositivos de bucle puede controlarse con el parámetro <code> max_loop</code>.</li>
</ul>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Sugerencia:</strong> Puede poner una entrada en <code>/etc/modprobe.d</code> para cargar el módulo de bucle con <code>max_part=15</code> cada vez, o puede poner <code>loop.max_part = 15</code> en la línea de comandos del kernel, dependiendo de si tiene o no el módulo <code>loop.ko</code> integrado en su kernel.</div>
<p>Configure su imagen como un dispositivo de bucle invertido:
</p>
<pre>$ losetup -f -P <i>disk_image</i>
</pre>
<p>Entonces, si el dispositivo creado fue <code>/dev/loop0</code>, se habrán creado automáticamente dispositivos adicionales <code>/dev/loop0pX</code>, donde X es el número de la partición. Estos dispositivos de loopback de partición se pueden montar directamente. Por ejemplo:
</p>
<pre>$ mount /dev/loop0p1 <i>punto de montaje</i>
</pre>
<p>Para montar la imagen de disco con <i> udisksctl </i>, vea <a href="/title/Udisks#Mount_loop_devices" title="Udisks">Udisks#Mount loop devices</a>.
</p>
<h4><span class="mw-headline" id="Con_kpartx">Con kpartx</span></h4>
<p><i> 'Kpartx' </i> del paquete <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=multipath-tools">multipath-tools</a></span> puede leer una tabla de particiones en un dispositivo y crear un nuevo dispositivo para cada partición. Por ejemplo:
 # Kpartx -a <i> disk_image </i>
</p>
<p>Esto configurará el dispositivo de bucle invertido y creará los dispositivos de partición necesarios en <code>/dev/mapper/</code>.
</p>
<h3>
<span id="Montar_una_partici.C3.B3n_dentro_de_una_imagen_qcow2"></span><span class="mw-headline" id="Montar_una_partición_dentro_de_una_imagen_qcow2">Montar una partición dentro de una imagen qcow2</span>
</h3>
<p>Puede montar una partición dentro de una imagen qcow2 usando <code>qemu-nbd</code>. Mira <a rel="nofollow" class="external text" href="https://en.wikibooks.org/wiki/QEMU/Images#Mounting_an_image_on_the_host">Wikibooks</a>.
</p>
<h3>
<span id="Utilizar_cualquier_partici.C3.B3n_real_como_la_.C3.BAnica_partici.C3.B3n_primaria_de_una_imagen_de_disco_duro"></span><span class="mw-headline" id="Utilizar_cualquier_partición_real_como_la_única_partición_primaria_de_una_imagen_de_disco_duro">Utilizar cualquier partición real como la única partición primaria de una imagen de disco duro</span>
</h3>
<p>A veces, puede que desee utilizar una de las particiones del sistema desde dentro de QEMU. El uso de una partición sin procesar para una máquina virtual mejorará el rendimiento, ya que las operaciones de lectura y escritura no pasan por la capa del sistema de archivos del host físico. Esta partición también proporciona una forma de compartir datos entre el host y el invitado.
</p>
<p>En Arch Linux, los archivos de dispositivo para las particiones sin procesar son, por defecto, propiedad de <i> root </i> y del grupo <i> disk </i>. Si desea que un usuario no root pueda leer y escribir en una partición en bruto, debe cambiar el propietario del archivo de dispositivo de la partición para ese usuario.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Advertencia:</strong> 
<ul>
<li>Aunque es posible, no se recomienda permitir que las máquinas virtuales alteren los datos críticos en el sistema host, como la partición raíz.</li>
<li>No debe montar un sistema de archivos en una partición de lectura-escritura en el host y el invitado al mismo tiempo. De lo contrario, se producirá corrupción de datos.</li>
</ul>
</div>
<p>Después de hacerlo, puede adjuntar la partición a una máquina virtual QEMU como un disco virtual.
</p>
<p>Sin embargo, las cosas son un poco más complicadas si desea tener la máquina virtual <i>completa</i> contenida en una partición. En ese caso, no habría ningún archivo de imagen de disco para arrancar realmente la máquina virtual, ya que no se puede instalar un cargador de arranque en una partición que está formateada como un sistema de archivos y no como un dispositivo particionado con un MBR. Una máquina virtual de este tipo se puede iniciar especificando el kernel y el initramfs manualmente o simulando un disco con un MBR usando RAID lineal.
</p>
<h4><span class="mw-headline" id="Especificar_el_kernel_y_el_initrd_manualmente">Especificar el kernel y el initrd manualmente</span></h4>
<p>QEMU es compatible con cargar <a href="/title/Kernels" class="mw-redirect" title="Kernels">Linux kernels</a> e <a href="/title/Initramfs" class="mw-redirect" title="Initramfs">init ramdisks</a> directamente, evitando así los cargadores de arranque como <a href="/title/GRUB" title="GRUB">GRUB</a>. A continuación, se puede iniciar con la partición física que contiene el sistema de archivos raíz como el disco virtual, que no parecen ser particionados. Esto se hace emitiendo un comando similar al siguiente:
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong>  En este ejemplo, se trata de las imágenes del <b>host</b> que se están utilizando, no del invitado. Si desea utilizar las imágenes del huésped, monte <code>/dev/sda3</code> de sólo lectura (para proteger el sistema de archivos del host) y especifique <code>/full/path/to/images</code> ó usar algún truco kexec en el invitado para recargar el kernel del invitado (extiende el tiempo de arranque).</div>
<pre>$ Qemu-system-i386 -kernel /boot/vmlinuz-linux -initrd /boot/initramfs-linux.img -append root=/dev/sda/dev/sda3
</pre>
<p>En el ejemplo anterior, la partición física que se utiliza para el sistema de archivos raíz del huésped es <code>/dev/sda3</code> en el host, pero aparece como <code>/dev/sda</code> en el invitado.
</p>
<p>Por supuesto, puede especificar cualquier kernel e initrd que desee, y no sólo los que vienen con Arch Linux.
</p>
<p>Cuando hay varios <a href="/title/Kernel_parameters" title="Kernel parameters">kernel parameters</a> que se pasan a la opción <code>-append</code>, necesitan ser citados usando comillas simples o dobles. Por ejemplo:
</p>
<pre>$ ... -append 'root=/dev/sda1 console=ttyS0'
</pre>
<h4><span class="mw-headline" id="Simular_disco_virtual_con_MBR_usando_RAID_lineal">Simular disco virtual con MBR usando RAID lineal</span></h4>
<p>Una forma más complicada de tener una máquina virtual usar una partición física, mientras que mantener esa partición formateada como un sistema de archivos y no sólo tener la partición invitado la partición como si fuera un disco, es simular un MBR para que pueda Arranque utilizando un gestor de arranque tal como GRUB.
</p>
<p>Puede hacerlo utilizando el RAID del software en modo lineal (necesita el controlador de kernel <code>linear.ko</code>) y un dispositivo de loopback: el truco consiste en añadir previamente un registro maestro de arranque (MBR) Real que desea incrustar en una imagen de disco RAEM QEMU.
</p>
<p>Suponga que tiene una partición simple <code>/</code> con algún sistema de archivos en la que desea formar parte de una imagen de disco QEMU. En primer lugar, crear un pequeño archivo para mantener el MBR:
</p>
<pre>$ dd if=/dev/zero of=<i>/path/to/mbr</i> count=32
</pre>
<p>Aquí, se crea un archivo de 16 KB (32 * 512 bytes). Es importante no hacerlo demasiado pequeño (incluso si el MBR sólo necesita un bloque de 512 bytes), ya que cuanto menor sea, menor será el tamaño del chasis del dispositivo RAID de software, lo que podría tener un impacto En el rendimiento. A continuación, configura un dispositivo de bucle invertido en el archivo MBR:
</p>
<pre># losetup -f <i>/path/to/mbr</i>
</pre>
<p>Supongamos que el dispositivo resultante es <code>/dev/loop0</code>, porque ya no habríamos estado usando otros bucle. El siguiente paso es crear la imagen de disco "fusionada" MBR + <code>/dev/hdaN</code> utilizando RAID de software:
</p>
<pre># modprobe lineal
</pre>
<pre># mdadm --build --verbose /dev/md0 --chunk=16 --level=linear --raid-devices=2 /dev/loop0/dev/hda<i>N</i>
</pre>
<p>El resultante <code>/dev/md0</code> es lo que utilizará como una imagen de disco cruda QEMU (no olvide establecer los permisos para que el emulador pueda acceder a él). El último paso (y algo complicado) es configurar la configuración del disco (geometría del disco y tabla de particiones) para que el punto de inicio de la partición primaria en el MBR coincida con el de {{ic|/dev/hda<i>N</i>} Dentro <code>/dev/md0</code> (un desplazamiento de exactamente 16 * 512 = 16384 bytes en este ejemplo). Hacer esto usando <code>fdisk</code> en la máquina host, no en el emulador: la rutina de detección de disco crudo predeterminada de QEMU a menudo da lugar a offsets redondeados no kilobyte (como 31.5 KB, como en la sección anterior) que No puede ser administrado por el código RAID de software. Por lo tanto, desde el anfitrión:
</p>
<pre>$ fdisk /dev/md0
</pre>
<p>Pulse <code>X</code> para entrar en el menú de expertos. Establezca el número de sectores por pista para que el tamaño de un cilindro coincida con el tamaño de su archivo MBR. Para dos cabezas y un tamaño de sector de 512, el número de sectores por pista debe ser 16, por lo que obtenemos cilindros de tamaño 2x16x512 = 16k.
</p>
<p>Ahora, presione <code>R</code> para regresar al menú principal.
</p>
<p>Presione <code>P</code> y compruebe que el tamaño del cilindro es ahora 16k.
</p>
<p>Ahora, cree una única partición primaria correspondiente a <code>/dev/hda<i>N</i></code>. Debe comenzar en el cilindro 2 y terminar en el extremo del disco (tenga en cuenta que el número de cilindros ahora difiere de lo que era cuando se introdujo fdisk.
</p>
<p>Finalmente, escribe el resultado al archivo: ya está. Ahora tiene una partición que puede montar directamente desde su host, así como parte de una imagen de disco QEMU:
</p>
<pre>$ Qemu-system-i386 -hdc /dev/md0 <i>[...]</i>
</pre>
<p>Por supuesto, puede configurar con seguridad cualquier cargador de arranque en esta imagen de disco utilizando QEMU, siempre que la partición original <code>/dev/hda<i>N</i></code> contenga las herramientas necesarias.
</p>
<h2><span class="mw-headline" id="Redes">Redes</span></h2>
<p>El rendimiento de la red virtual debería ser mejor con los dispositivos de derivación (tap) y puentes que con la red en modo de usuario o vde porque los dispositivos de derivación y los puentes se implementan en el kernel.
</p>
<p>Además, el rendimiento de la red se puede mejorar asignando a las máquinas virtuales un dispositivo de red <a rel="nofollow" class="external text" href="https://wiki.libvirt.org/page/Virtio">virtio</a> en lugar de la emulación predeterminada de una NIC e1000. Consulte <a href="#Instalaci%C3%B3n_de_controladores_virtio">#Instalación de controladores virtio</a> para obtener más información.
</p>
<h3>
<span id="Advertencia_de_direcci.C3.B3n_a_nivel_de_enlace"></span><span class="mw-headline" id="Advertencia_de_dirección_a_nivel_de_enlace">Advertencia de dirección a nivel de enlace</span>
</h3>
<p>Al asignar el argumento <code>-net nic</code> a QEMU, asignará por defecto a una máquina virtual una interfaz de red con la dirección de enlace <code>52:54:00:12:34:56</code>. Sin embargo, cuando se utiliza la creación de redes puenteadas con varias máquinas virtuales, es esencial que cada máquina virtual tenga una dirección única de nivel de enlace (MAC) en el lado de la máquina virtual del dispositivo de derivación. De lo contrario, el puente no funcionará correctamente, ya que recibirá paquetes de varias fuentes que tienen la misma dirección de nivel de enlace. Este problema se produce incluso si los propios dispositivos de derivación tienen direcciones de nivel de enlace únicas porque la dirección de nivel de enlace de origen no se vuelve a escribir a medida que los paquetes pasan a través del dispositivo de derivación.
</p>
<p>Asegúrese de que cada máquina virtual tiene una dirección única de nivel de enlace, pero siempre debe comenzar con <code>52:54:</code>. Utilice la opción siguiente, reemplazar <i>X</i> por un dígito hexadecimal arbitrario:
</p>
<pre>$ qemu-system-i386 -net nic,macaddr=52:54:<i>XX:XX:XX:XX</i> -net vde <i>disk_image</i>
</pre>
<p>Generar direcciones únicas de nivel de enlace se puede realizar de varias maneras:
</p>
<ol>
<li>Especificar manualmente la dirección única de nivel de enlace para cada NIC. El beneficio es que el servidor DHCP asignará la misma dirección IP cada vez que se ejecute la máquina virtual, pero es inutilizable para un gran número de máquinas virtuales.
</li>
<li>Generar dirección de nivel de enlace aleatoria cada vez que se ejecuta la máquina virtual. Prácticamente cero probabilidad de colisiones, pero la desventaja es que el servidor DHCP asignará una dirección IP diferente cada vez. Puede utilizar el siguiente comando en una secuencia de comandos para generar una dirección de nivel de enlace aleatoria en una variable <code>macaddr</code>:

<pre>printf -v macaddr "52:54:%02x:%02x:%02x:%02x" $(( $RANDOM &amp; 0xff)) $(( $RANDOM &amp; 0xff )) $(( $RANDOM &amp; 0xff)) $(( $RANDOM &amp; 0xff ))
qemu-system-i386 -net nic,macaddr="$macaddr" -net vde <i>disk_image</i></pre>
</li>
<li>Utilice el siguiente script <code>qemu-mac-hasher.py</code> para generar la dirección de nivel de enlace desde el nombre de la máquina virtual mediante una función de hash. Dado que los nombres de las máquinas virtuales son únicos, este método combina los beneficios de los métodos antes mencionados: genera la misma dirección de nivel de enlace cada vez que se ejecuta el script, aunque preserva la probabilidad prácticamente nula de colisiones.

<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">qemu-mac-hasher.py</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">#!/usr/bin/env python

import sys
import zlib

if len(sys.argv) != 2:
    print("usage: %s &lt;VM Name&gt;" % sys.argv[0])
    sys.exit(1)

crc = zlib.crc32(sys.argv[1].encode("utf-8")) &amp; 0xffffffff
crc = str(hex(crc))[2:]
print("52:54:%s%s:%s%s:%s%s:%s%s" % tuple(crc))
</pre>
<p>En un script, puede utilizar por ejemplo:
</p>
<pre>vm_name="<i>VM Name</i>"
qemu-system-i386 -name "$vm_name" -net nic,macaddr=$(qemu-mac-hasher.py "$vm_name") -net vde <i>disk_image</i>
</pre>
</li>
</ol>
<h3><span class="mw-headline" id="Redes_en_modo_de_usuario">Redes en modo de usuario</span></h3>
<p>De forma predeterminada, sin ningún argumento <code>-netdev</code>, QEMU utilizará la red en modo usuario con un servidor DHCP incorporado. A sus máquinas virtuales se les asignará una dirección IP cuando ejecuten su cliente DHCP, y podrán acceder a la red del host físico a través de la mascarada de IP realizada por QEMU.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Advertencia:</strong>  Esto sólo funciona con los protocolos TCP y UDP, por lo que ICMP, incluido <code>ping</code>, no funcionará. No utilice <code>ping</code> para probar la conectividad de red.</div>
<p>Esta configuración predeterminada permite que sus máquinas virtuales accedan fácilmente a Internet, siempre que el host esté conectado a él, pero las máquinas virtuales no estarán directamente visibles en la red externa ni las máquinas virtuales podrán comunicarse entre sí si empieza Más de uno simultáneamente.
</p>
<p>La red de usuario en modo QEMU puede ofrecer más capacidades, como servidores TFTP o SMB incorporados, redirigir los puertos del host al huésped (por ejemplo, para permitir conexiones SSH al invitado) o conectar invitados a las VLAN para que puedan hablar entre sí. Consulte la documentación de QEMU en el indicador <code>-net user</code> para obtener más detalles.
</p>
<p>Sin embargo, la conexión en red en modo usuario tiene limitaciones tanto en la utilidad como en el rendimiento. Las configuraciones de red más avanzadas requieren el uso de dispositivos de derivación u otros métodos.
</p>
<h3><span class="mw-headline" id="Tap_de_red_con_QEMU">Tap de red con QEMU</span></h3>
<p>Los <a href="https://en.wikipedia.org/wiki/TUN/TAP" class="extiw" title="wikipedia:TUN/TAP">dispositivos tap</a> Son una característica del kernel de Linux que le permite crear interfaces de red virtuales que aparecen como interfaces de red reales. Los paquetes enviados a una interfaz de derivación se entregan a un programa de espacio de usuario, tal como QEMU, que se ha enlazado a la interfaz.
</p>
<p>QEMU puede utilizar la red de derivación para una máquina virtual de modo que los paquetes enviados a la interfaz de derivación se envíen a la máquina virtual y aparezcan como procedentes de una interfaz de red (normalmente una interfaz Ethernet) en la máquina virtual. Por el contrario, todo lo que la máquina virtual envía a través de su interfaz de red aparecerá en la interfaz de tap.
</p>
<p>Los dispositivos de toque son soportados por los controladores de puente de Linux, por lo que es posible conectar entre sí los dispositivos entre sí y posiblemente con otras interfaces de host como <code>eth0</code>. Esto es deseable si desea que sus máquinas virtuales puedan hablar entre sí, o si desea que otras máquinas en su LAN puedan hablar con las máquinas virtuales.
</p>
<p>{{Advertencia| Si conectas el dispositivo de toque y alguna interfaz de host, como <code>eth0</code>, las máquinas virtuales aparecerán directamente en la red externa, lo que los exponerá a posibles ataques. Dependiendo de los recursos a los que tengan acceso sus máquinas virtuales, es posible que tenga que tomar todas las <a href="/title/Firewalls" class="mw-redirect" title="Firewalls">precauciones</a> que normalmente tomaría al asegurar una computadora para proteger sus máquinas virtuales. Si el riesgo es demasiado grande, las máquinas virtuales tienen pocos recursos o se configuran varias máquinas virtuales, una solución mejor podría ser utilizar [[#Red de host solamente] y configurar NAT. En este caso sólo necesitará un firewall en el host en lugar de múltiples firewalls para cada huésped.}}
</p>
<p>Como se indica en la sección de conexión en red de modo de usuario, los dispositivos de derivación ofrecen un rendimiento de red más alto que el modo de usuario. Si el OS invitado admite el controlador de red virtio, el rendimiento de la red se incrementará considerablemente también. Suponiendo el uso del dispositivo tap0, que el controlador virtio se utiliza en el invitado, y que no se utilizan scripts para ayudar a iniciar / detener la creación de redes, a continuación es parte del comando qemu se debe ver:
</p>
<pre>-net nic, model=virtio -net tap, ifname=tap0, script=no, downscript=no
</pre>
<p>Pero si ya está utilizando un dispositivo de tap con virtio controlador de red, uno puede incluso aumentar el rendimiento de la red mediante la activación de vhost, como:
</p>
<pre>-net nic, model=virtio -net tap, ifname=tap0, script=no, downscript=no, vhost=on
</pre>
<p>Ver <a rel="nofollow" class="external free" href="http://www.linux-kvm.com/content/how-maximize-virtio-net-performance-vhost-net">http://www.linux-kvm.com/content/how-maximize-virtio-net-performance-vhost-net</a> para obtener más información.
</p>
<h4><span class="mw-headline" id="Red_de_host_solamente">Red de host solamente</span></h4>
<p>Si al puente se le da una dirección IP y se permite el tráfico destinado a ello, pero no hay una interfaz real (por ejemplo, <code>eth0</code>) conectada al puente, las máquinas virtuales podrán hablar entre sí y la Sistema anfitrión. Sin embargo, no podrán hablar con nada en la red externa, siempre y cuando no configure IP enmascarada en el host físico. Esta configuración se llama <i> red de host solamente </i> por otro software de virtualización como <a href="/title/VirtualBox" title="VirtualBox">VirtualBox</a>.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Sugerencia:</strong> 
<ul>
<li>Si desea configurar IP masquerading, ej. NAT para máquinas virtuales, consulte la página <a href="/title/Internet_sharing#Enable_NAT" title="Internet sharing">Internet sharing#Enable NAT</a>.</li>
<li>Es posible que desee tener un servidor DHCP que se ejecute en la interfaz de puente para dar servicio a la red virtual. Por ejemplo, para usar la subred <code>172.20.0.1/16</code> con <a href="/title/Dnsmasq" title="Dnsmasq">dnsmasq</a> como servidor DHCP:</li>
</ul>
<pre># ip addr add 172.20.0.1/16 dev br0
# ip link set br0 up
# dnsmasq --interface=br0 --bind-interfaces --dhcp-range=172.20.0.2,172.20.255.254
</pre>
</div>
<h4><span class="mw-headline" id="Red_interna">Red interna</span></h4>
<p>Si no le da al puente una dirección IP y agrega una regla <a href="/title/Iptables" title="Iptables">iptables</a> para eliminar todo el tráfico al puente en la cadena INPUT, las máquinas virtuales podrán hablar entre sí, pero no con el host físico ó la red exterior. Esta configuración se llama "red interna" por otro software de virtualización como <a href="/title/VirtualBox" title="VirtualBox">VirtualBox</a>. Deberá asignar direcciones IP estáticas a las máquinas virtuales o ejecutar un servidor DHCP en una de ellas.
</p>
<p>De forma predeterminada, iptables eliminaría los paquetes de la red de bridge. Es posible que necesite utilizar dicha regla iptables para permitir paquetes en una red puenteada:
</p>
<pre># iptables -I FORWARD -m physdev --physdev-is-bridged -j ACCEPT
</pre>
<h4><span class="mw-headline" id="Redes_puenteadas_usando_qemu-bridge-helper">Redes puenteadas usando qemu-bridge-helper</span></h4>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong>  Este método está disponible desde QEMU 1.1, consulte <a rel="nofollow" class="external free" href="https://wiki.qemu.org/Features/HelperNetworking">https://wiki.qemu.org/Features/HelperNetworking</a>.</div>
<p>Este método no requiere una secuencia de comandos de inicio y acepta fácilmente múltiples tomas y puentes múltiples. Utiliza el binario <code>/usr/lib/qemu/qemu-bridge-helper</code>, que permite crear dispositivos de derivación en un puente existente.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Sugerencia:</strong>  Consulte <a href="/title/Network_bridge" title="Network bridge">Network bridge</a> para obtener información sobre cómo crear un puente.</div>
<p>En primer lugar, cree un archivo de configuración que contenga los nombres de todos los puentes que QEMU utilizará:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/qemu/bridge.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">allow <i>bridge0</i>
allow <i>bridge1</i>
...</pre>
<p>Ahora inicie la VM. El uso más básico sería:
</p>
<pre>$ qemu-system-i386 -net nic -net bridge,br=<i>bridge0</i> <i>[...]</i>
</pre>
<p>Con múltiples taps, el uso más básico requiere especificar la VLAN para todos los NIC adicionales:
</p>
<pre>$ qemu-system-i386 -net nic -net bridge,br=<i>bridge0</i> -net nic,vlan=1 -net bridge,vlan=1,br=<i>bridge1</i> <i>[...]</i>
</pre>
<h4>
<span id="Creaci.C3.B3n_manual_del_puente"></span><span class="mw-headline" id="Creación_manual_del_puente">Creación manual del puente</span>
</h4>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Sugerencia:</strong>  Desde QEMU 1.1, el <a rel="nofollow" class="external text" href="https://wiki.qemu.org/Features/HelperNetworking">puente de red ayudante</a> puede establecer tun / tap up para usted sin necesidad de secuencias de comandos adicionales. Consulte <a href="#Redes_puenteadas_usando_qemu-bridge-helper">#Redes puenteadas usando qemu-bridge-helper</a>.</div>
<p>A continuación se describe cómo conectar una máquina virtual con una interfaz de host como <code> eth0</code>, que es probablemente la configuración más común. Esta configuración hace que parezca que la máquina virtual está ubicada directamente en la red externa, en el mismo segmento Ethernet que la máquina host física.
</p>
<p>Vamos a reemplazar el adaptador Ethernet normal con un adaptador de puente y enlazar el adaptador Ethernet normal a él.
</p>
<ul><li>Instale <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=bridge-utils">bridge-utils</a></span>, que proporciona <code>brctl</code> para manipular puentes.</li></ul>
<ul><li>Habilitar el reenvío IPv4:</li></ul>
<pre># sysctl net.ipv4.ip_forward=1
</pre>
<p>Para hacer el cambio permanente, cambie <code>net.ipv4.ip_forward = 0</code> a <code>net.ipv4.ip_forward = 1</code> en <code>/etc/sysctl.d/99-sysctl.conf</code>.
</p>
<ul><li>Cargue el módulo <code>tun</code> y configurelo para cargarlo en el arranque. Ver <a href="/title/Kernel_modules" class="mw-redirect" title="Kernel modules">Kernel modules</a> para más detalles.</li></ul>
<ul><li>Ahora cree el puente. Ver <a href="/title/Bridge_with_netctl" title="Bridge with netctl">Bridge with netctl</a> para más detalles. Recuerde nombrar su puente como <code>br0</code>, o modifique lo scripts a continuación del nombre del puente.</li></ul>
<ul><li>Cree el script que QEMU utiliza para abrir el adaptador de toma con los permisos <code>root:kvm</code> 750:</li></ul>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/qemu-ifup</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">#!/bin/sh

echo "Executing /etc/qemu-ifup"
echo "Bringing up $1 for bridged mode..."
sudo /usr/bin/ip link set $1 up promisc on
echo "Adding $1 to br0..."
sudo /usr/bin/brctl addif br0 $1
sleep 2
</pre>
<ul><li>Cree el guión que QEMU utiliza para derribar el adaptador de toma en <code>/etc/qemu-ifdown</code> con los permisos <code>root:kvm</code> 750:</li></ul>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/qemu-ifdown</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">#!/bin/sh

echo "Executing /etc/qemu-ifdown"
sudo /usr/bin/ip link set $1 down
sudo /usr/bin/brctl delif br0 $1
sudo /usr/bin/ip link delete dev $1
</pre>
<ul><li>Use <code>visudo</code> para añadir lo siguiente a el archivo <code>sudoers</code>:</li></ul>
<pre>Cmnd_Alias      QEMU=/usr/bin/ip,/usr/bin/modprobe,/usr/bin/brctl
%kvm     ALL=NOPASSWD: QEMU
</pre>
<ul><li>Se inicia QEMU con el siguiente script <code>run-qemu</code>:</li></ul>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">run-qemu</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">#!/bin/bash
USERID=$(whoami)

# Get name of newly created TAP device; see https://bbs.archlinux.org/viewtopic.php?pid=1285079#p1285079
precreationg=$(/usr/bin/ip tuntap list | /usr/bin/cut -d: -f1 | /usr/bin/sort)
sudo /usr/bin/ip tuntap add user $USERID mode tap
postcreation=$(/usr/bin/ip tuntap list | /usr/bin/cut -d: -f1 | /usr/bin/sort)
IFACE=$(comm -13 &lt;(echo "$precreationg") &lt;(echo "$postcreation"))

# This line creates a random MAC address. The downside is the DHCP server will assign a different IP address each time
printf -v macaddr "52:54:%02x:%02x:%02x:%02x" $(( $RANDOM &amp; 0xff)) $(( $RANDOM &amp; 0xff )) $(( $RANDOM &amp; 0xff)) $(( $RANDOM &amp; 0xff ))
# Instead, uncomment and edit this line to set a static MAC address. The benefit is that the DHCP server will assign the same IP address.
# macaddr='52:54:be:36:42:a9'

qemu-system-i386 -net nic,macaddr=$macaddr -net tap,ifname="$IFACE" $*

sudo ip link set dev $IFACE down &amp;&gt; /dev/null
sudo ip tuntap del $IFACE mode tap &amp;&gt; /dev/null
</pre>
<p>Para ejecutar una VM, haz algo como esto:
</p>
<pre>$ run-qemu -hda <i>myvm.img</i> -m 512 -vga std
</pre>
<ul><li>Se recomienda, por motivos de rendimiento y seguridad, deshabilitar el firewall <a rel="nofollow" class="external text" href="http://ebtables.netfilter.org/documentation/bridge-nf.html">en el puente</a>:</li></ul>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/sysctl.d/10-disable-firewall-on-bridge.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">net.bridge.bridge-nf-call-ip6tables = 0
net.bridge.bridge-nf-call-iptables = 0
net.bridge.bridge-nf-call-arptables = 0
</pre>
<p>Ejecute <code>sysctl -p /etc/sysctl.d/10-disable-firewall-on-bridge.conf</code> para aplicar los cambios inmediatamente.
</p>
<p>Ver <a rel="nofollow" class="external text" href="https://wiki.libvirt.org/page/Networking#Creating_network_initscripts">libvirt wiki</a> y <a rel="nofollow" class="external text" href="https://bugzilla.redhat.com/show_bug.cgi?id=512206">Fedora bug 512206</a>. Si obtiene errores de sysctl durante el inicio de archivos no existentes, haga que el módulo <code>bridge</code> se cargue al arrancar. Ver <a href="/title/Kernel_modules#Automatic_module_handling" class="mw-redirect" title="Kernel modules">Kernel modules#Automatic module handling</a><sup>[<a href="/title/Help:Procedures#Fix_broken_section_links" title="Help:Procedures">broken link</a>: invalid section]</sup>.
</p>
<p>Como alternativa, puede configurar <a href="/title/Iptables" title="Iptables">iptables</a> para permitir que todo el tráfico se reenvíe a través del puente mediante la adición de una regla como esta:
</p>
<pre>-I FORWARD -m physdev --physdev-is-bridged -j ACCEPT
</pre>
<h4>
<span id="Compartici.C3.B3n_de_red_entre_dispositivo_f.C3.ADsico_y_un_dispositivo_de_toque_a_trav.C3.A9s_de_iptables"></span><span class="mw-headline" id="Compartición_de_red_entre_dispositivo_físico_y_un_dispositivo_de_toque_a_través_de_iptables">Compartición de red entre dispositivo físico y un dispositivo de toque a través de iptables</span>
</h4>
<p>La conexión en puente funciona bien entre una interfaz cableada (por ejemplo, eth0), y es fácil de configurar. Sin embargo, si el host se conecta a la red a través de un dispositivo inalámbrico, el puente no es posible.
</p>
<p>Consulte <a href="/title/Network_bridge#Wireless_interface_on_a_bridge" title="Network bridge">Network bridge#Wireless interface on a bridge</a> como referencia.
</p>
<p>Una forma de superar esto es configurar un dispositivo de derivación con una IP estática, haciendo que linux maneje automáticamente el enrutamiento para ella y, a continuación, reenvíe el tráfico entre la interfaz de derivación y el dispositivo conectado a la red a través de las reglas de iptables.
</p>
<p>Consulte <a href="/title/Internet_sharing" title="Internet sharing">Internet sharing</a> como referencia.
</p>
<p>Allí puede encontrar lo que se necesita para compartir la red entre dispositivos, incluidos los de tap y tun. Lo siguiente sólo indica algunas de las configuraciones de host requeridas. Como se indica en la referencia anterior, el cliente debe configurarse para una IP estática, utilizando la IP asignada a la interfaz de derivación como puerta de enlace. La advertencia es que los servidores DNS del cliente pueden necesitar ser editados manualmente si cambian al cambiar de un dispositivo host conectado a la red a otro.
</p>
<p>Para permitir el reenvío de IP en cada inicio, es necesario agregar las siguientes líneas al archivo de configuración de sysctl dentro de /etc/sysctl.d:
</p>
<pre>net.ipv4.ip_forward = 1
net.ipv6.conf.default.forwarding = 1
net.ipv6.conf.all.forwarding = 1
</pre>
<p>Las reglas de iptables pueden verse así:
</p>
<pre># Forwarding from/to outside
iptables -A FORWARD -i ${INT} -o ${EXT_0} -j ACCEPT
iptables -A FORWARD -i ${INT} -o ${EXT_1} -j ACCEPT
iptables -A FORWARD -i ${INT} -o ${EXT_2} -j ACCEPT
iptables -A FORWARD -i ${EXT_0} -o ${INT} -j ACCEPT
iptables -A FORWARD -i ${EXT_1} -o ${INT} -j ACCEPT
iptables -A FORWARD -i ${EXT_2} -o ${INT} -j ACCEPT
# NAT/Masquerade (network address translation)
iptables -t nat -A POSTROUTING -o ${EXT_0} -j MASQUERADE
iptables -t nat -A POSTROUTING -o ${EXT_1} -j MASQUERADE
iptables -t nat -A POSTROUTING -o ${EXT_2} -j MASQUERADE
</pre>
<p>El anterior supone que hay 3 dispositivos conectados a la red compartiendo tráfico con un dispositivo interno, donde por ejemplo:
</p>
<pre>INT=tap0
EXT_0=eth0
EXT_1=wlan0
EXT_2=tun0
</pre>
<p>El anterior muestra un reenvío que permitiría compartir conexiones cableadas e inalámbricas con el dispositivo de derivación (tap).
</p>
<p>Las reglas de reenvío que se muestran son apátridas y para el reenvío puro. Se podría pensar en restringir el tráfico específico, poniendo un cortafuegos en el lugar para proteger al huésped y otros. Sin embargo, esto reduciría el rendimiento de la red, mientras que un simple puente no incluye nada de eso.
</p>
<p>Bonus: Si la conexión es cableada o inalámbrica, si se conecta a través de VPN a un sitio remoto con un dispositivo tun, suponiendo que el dispositivo tun abierto para esa conexión es tun0, y las reglas iptables anteriores se aplican, entonces la conexión remota se obtiene también Compartido con el huésped. Esto evita la necesidad de que el invitado también abra una conexión VPN. Una vez más, como la red de invitados debe ser estática, entonces si la conexión del host de forma remota de esta manera, uno probablemente tendrá que editar los servidores DNS en el invitado.
</p>
<h3><span class="mw-headline" id="Trabajo_en_red_con_VDE2">Trabajo en red con VDE2</span></h3>
<h4>
<span id=".C2.BFQu.C3.A9_es_VDE.3F"></span><span class="mw-headline" id="¿Qué_es_VDE?">¿Qué es VDE?</span>
</h4>
<p>VDE significa Virtual Distributed Ethernet. Comenzó como una mejora del interruptor <a href="/title/User-mode_Linux" title="User-mode Linux">uml</a> _. Es una caja de herramientas para administrar redes virtuales.
</p>
<p>La idea es crear interruptores virtuales, que son básicamente sockets, y "conectar" tanto máquinas físicas como máquinas virtuales en ellas. La configuración que mostramos aquí es bastante simple; Sin embargo, VDE es mucho más potente que esto, puede conectar conmutadores virtuales juntos, ejecutarlos en diferentes hosts y supervisar el tráfico en los switches. Usted está invitado a leer <a rel="nofollow" class="external text" href="https://web.archive.org/web/20190821040940/http://wiki.virtualsquare.org/wiki/index.php/Main_Page">la documentación del proyecto</a>.
</p>
<p>La ventaja de este método es que no tienes que agregar privilegios de sudo a tus usuarios. No se debe permitir que los usuarios regulares ejecuten modprobe.
</p>
<h4><span class="mw-headline" id="Basics">Basics</span></h4>
<p>El soporte de VDE puede ser <a href="/title/Pacman" title="Pacman">instalado</a> a través del paquete <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=vde2">vde2</a></span> en los <a href="/index.php?title=Repositorios_oficiales&amp;action=edit&amp;redlink=1" class="new" title="Repositorios oficiales (page does not exist)">repositorios oficiales</a>.
</p>
<p>En nuestra configuración, usamos tun/tap para crear una interfaz virtual en el host. Cargue el módulo <code>tun</code> (consulte <a href="/title/Kernel_modules" class="mw-redirect" title="Kernel modules">kernel modules</a> para obtener más detalles):
</p>
<pre># modprobe tun
</pre>
<p>Ahora crea el conmutador virtual:
</p>
<pre># vde_switch -tap tap0 -daemon -mod 660 -group users
</pre>
<p>Esta línea crea el switch, crea <code>tap0</code>, lo "enchufa" y permite a los usuarios del grupo <code>users</code> usarlo.
</p>
<p>La interfaz está conectada pero no está configurada todavía. Para configurarlo, ejecute este comando:
</p>
<pre># ip addr add 192.168.100.254/24 dev tap0
</pre>
<p>Ahora, sólo tiene que ejecutar KVM con estas opciones <code>-net</code> como usuario normal:
</p>
<pre>$ qemu-system-i386 -net nic -net vde -hda <i>[...]</i>
</pre>
<p>Configure la red para su invitado como lo haría en una red física.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Sugerencia:</strong>  es posible que desee configurar NAT en dispositivo de toque para acceder a Internet desde la máquina virtual. Consulte <a href="/title/Internet_sharing#Enable_NAT" title="Internet sharing">Internet sharing#Enable NAT</a> para obtener más información.</div>
<h4><span class="mw-headline" id="Startup_scripts">Startup scripts</span></h4>
<p>Ejemplo de script principal que inicia VDE:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/systemd/scripts/qemu-network-env</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">#!/bin/sh
# Preparación del entorno de red QEMU/VDE

# La configuración IP del dispositivo de derivación que se utilizará para
# La red de la máquina virtual:

TAP_DEV=tap0
TAP_IP=192.168.100.254
TAP_MASK=24
TAP_NETWORK=192.168.100.0

# Host interface
NIC=eth0

case "$1" in
  start)
        echo -n "Starting VDE network for QEMU: "

        # If you want tun kernel module to be loaded by script uncomment here
	#modprobe tun 2&gt;/dev/null
	## Wait for the module to be loaded
 	#while ! lsmod | grep -q "^tun"; do echo "Waiting for tun device"; sleep 1; done

        # Start tap switch
        vde_switch -tap "$TAP_DEV" -daemon -mod 660 -group users

        # Bring tap interface up
        ip address add "$TAP_IP"/"$TAP_MASK" dev "$TAP_DEV"
        ip link set "$TAP_DEV" up

        # Start IP Forwarding
        echo "1" &gt; /proc/sys/net/ipv4/ip_forward
        iptables -t nat -A POSTROUTING -s "$TAP_NETWORK"/"$TAP_MASK" -o "$NIC" -j MASQUERADE
        ;;
  stop)
        echo -n "Stopping VDE network for QEMU: "
        # Delete the NAT rules
        iptables -t nat -D POSTROUTING "$TAP_NETWORK"/"$TAP_MASK" -o "$NIC" -j MASQUERADE

        # Bring tap interface down
        ip link set "$TAP_DEV" down

        # Kill VDE switch
        pgrep -f vde_switch | xargs kill -TERM
        ;;
  restart|reload)
        $0 stop
        sleep 1
        $0 start
        ;;
  *)
        echo "Usage: $0 {start|stop|restart|reload}"
        exit 1
esac
exit 0
</pre>
<p>Ejemplo de servicio systemd utilizando el script anterior:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/systemd/system/qemu-network-env.service</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[Unit]
Description=Manage VDE Switch

[Service]
Type=oneshot
ExecStart=/etc/systemd/scripts/qemu-network-env start
ExecStop=/etc/systemd/scripts/qemu-network-env stop
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
</pre>
<p>Cambiar permisos de <code>qemu-network-env</code> para ser ejecutable
</p>
<pre># chmod u+x /etc/systemd/scripts/qemu-network-env
</pre>
<p>Puede iniciar <code>qemu-network-env.service</code> como de costumbre.
</p>
<h4>
<span id="M.C3.A9todo_alternativo"></span><span class="mw-headline" id="Método_alternativo">Método alternativo</span>
</h4>
<p>Si el método anterior no funciona o no quiere meterse con las configuraciones del kernel, TUN, dnsmasq e iptables, puede hacer lo siguiente para obtener el mismo resultado.
</p>
<pre># vde_switch -daemon -mod 660 -group users
# slirpvde --dhcp --daemon
</pre>
<p>A continuación, para iniciar la VM con una conexión a la red del host:
</p>
<pre>$ qemu-system-i386 -net nic,macaddr=52:54:00:00:EE:03 -net vde <i>disk_image</i>
</pre>
<h3><span class="mw-headline" id="Puente_VDE2">Puente VDE2</span></h3>
<p>Basado en <a rel="nofollow" class="external text" href="https://selamatpagicikgu.wordpress.com/2011/06/08/quickhowto-qemu-networking-using-vde-tuntap-and-bridge/">quickhowto: qemu networking using vde, tun/tap, and bridge</a> gráfico. Cualquier máquina virtual conectada a vde está expuesta externamente. Por ejemplo, cada máquina virtual puede recibir la configuración DHCP directamente desde su enrutador ADSL.
</p>
<h4>
<span id="Conceptos_b.C3.A1sicos"></span><span class="mw-headline" id="Conceptos_básicos">Conceptos básicos</span>
</h4>
<p>Recuerde que necesita el módulo <code>tun</code> y el paquete <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=bridge-utils">bridge-utils</a></span>.
</p>
<p>Cree el dispositivo vde2/tap:
</p>
<pre># vde_switch -tap tap0 -daemon -mod 660 -group users
# ip link set tap0 up
</pre>
<p>Cree el puente:
</p>
<pre># brctl addbr br0
</pre>
<p>Agregue dispositivos:
</p>
<pre># brctl addif br0 eth0
# brctl addif br0 tap0
</pre>
<p>Y configure la interfaz del puente:
</p>
<pre># dhcpcd br0
</pre>
<h4><span class="mw-headline" id="Startup_scripts_2">Startup scripts</span></h4>
<p>Todos los dispositivos deben estar configurados. Y sólo el puente necesita una dirección IP. Para dispositivos físicos en el puente (por ejemplo, <code>eth0</code>), esto puede hacerse con <a href="/title/Netctl" title="Netctl">netctl</a> utilizando un perfil Ethernet personalizado con:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/netctl/ethernet-noip</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Description='A more versatile static Ethernet connection'
Interface=eth0
Connection=ethernet
IP=no
</pre>
<p>El siguiente servicio systemd personalizado puede utilizarse para crear y activar una interfaz de toma VDE2 para su uso en el grupo de usuarios <code>users</code>.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/systemd/system/vde2@.service</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[Unit]
Description=Network Connectivity for %i
Wants=network.target
Before=network.target

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/bin/vde_switch -tap %i -daemon -mod 660 -group users
ExecStart=/usr/bin/ip link set dev %i up
ExecStop=/usr/bin/ip addr flush dev %i
ExecStop=/usr/bin/ip link set dev %i down

[Install]
WantedBy=multi-user.target
</pre>
<p>Y, por último, puede crear el puente interfaz con netctl.
</p>
<h2>
<span id="Gr.C3.A1ficos"></span><span class="mw-headline" id="Gráficos">Gráficos</span>
</h2>
<p>QEMU puede utilizar las siguientes salidas gráficas diferentes: <code>std</code>, <code>qxl</code>, <code>vmware</code>, <code>virtio</code>, <code>cirrus</code> y <code>none</code>.
</p>
<h3><span class="mw-headline" id="std">std</span></h3>
<p>Con <code>-vga std</code> puede obtener una resolución de hasta 2560 x 1600 píxeles sin necesidad de controladores invitados. Este es el valor predeterminado desde QEMU 2.2.
</p>
<h3><span class="mw-headline" id="qxl">qxl</span></h3>
<p>QXL Es un controlador de gráficos paravirtual con soporte 2D. Para usarlo, pase la opción <code>-vga qxl</code> e instale los controladores en el invitado. Es posible que desee utilizar SPICE para mejorar el rendimiento gráfico al utilizar QXL.
</p>
<p>En los invitados de Linux, los módulos del kernel <code>qxl</code> y <code>bochs_drm</code> deben ser inicializados para poder tener un rendimiento descente.
</p>
<h4><span class="mw-headline" id="SPICE">SPICE</span></h4>
<p>El proyecto <a rel="nofollow" class="external text" href="https://www.spice-space.org/">SPICE</a> tiene como objetivo proporcionar una solución completa de código abierto para el acceso remoto a máquinas virtuales de una manera transparente.
</p>
<p>SPICE sólo se puede utilizar cuando se utiliza QXL como la salida gráfica.
</p>
<p>El siguiente es un ejemplo de arranque con SPICE como protocolo de escritorio remoto:
</p>
<pre>$ qemu-system-i386 -vga qxl -spice port=5930,disable-ticketing -chardev spicevm 
</pre>
<p>Conéctese al invitado utilizando un cliente SPICE. En este momento se recomienda <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=spice-gtk">spice-gtk</a></span>, sin embargo otros <a rel="nofollow" class="external text" href="https://www.spice-space.org/download.html">clientes</a>, incluyendo otras plataformas, están disponibles:
</p>
<pre>$ spicy -h 127.0.0.1 -p 5930
</pre>
<p>El uso de <a href="https://en.wikipedia.org/wiki/Unix_socket" class="extiw" title="wikipedia:Unix socket">Unix sockets</a> en lugar de los puertos TCP no implica el uso de pila de red en el sistema host, por lo que es <a rel="nofollow" class="external text" href="https://unix.stackexchange.com/questions/91774/performance-of-unix-">Sockets-vs-tcp-ports según se informa</a> mejor para el rendimiento. Ejemplo:
</p>
<pre>$ qemu-system-x86_64 -vga qxl -device virtio-serial-pci -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 -chardev spicevmc,id=spicechannel0,name=vdagent -spice unix,addr=/tmp/vm_spice.socket,disable-ticketing
$ spicy --uri="spice+unix:///tmp/vm_spice.socket"
</pre>
<p>Para una mejor compatibilidad con varios monitores, compartir el portapapeles, etc., los paquetes siguientes deben estar instalados en el invitado:
</p>
<ul>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=spice-vdagent">spice-vdagent</a></span>: Spice agent xorg cliente que permite copiar y pegar entre el cliente y X-session y más</li>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=xf86-video-qxl">xf86-video-qxl</a></span> <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/xf86-video-qxl-git/">xf86-video-qxl-git</a></span><sup><small>AUR</small></sup>: Xorg X11 qxl controlador de vídeo</li>
<li>Para otros sistemas operativos, mire la sección Guest de la página <a rel="nofollow" class="external text" href="https://www.spice-space.org/download.html">SPICE-Space download</a>.</li>
</ul>
<h3><span class="mw-headline" id="vmware">vmware</span></h3>
<p>Aunque tiene pocos errores, tiene mejor rendimiento que std y cirrus. Instale los controladores de VMware <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=xf86-video-vmware">xf86-video-vmware</a></span> y <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=xf86-input-vmmouse">xf86-input-vmmouse</a></span> para los invitados de Arch Linux.
</p>
<h3><span class="mw-headline" id="virtio">virtio</span></h3>
<p><code>virtio-vga</code> / <code>virtio-gpu</code> Es un controlador de gráficos 3D paravirtual basado en <a rel="nofollow" class="external text" href="https://virgil3d.github.io/">virgl</a>. Actualmente un trabajo en curso, que sólo admite a invitados Linux (&gt;= 4.4) con <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=mesa">mesa</a></span> (&gt;= 11.2) compilados con la opción <code>--with-gallium-drivers=virgl</code>.
</p>
<p>Para activar la aceleración 3D en el sistema invitado, seleccione vga con <code>-vga virtio</code> y habilitar el contexto opengl en el dispositivo de visualización con <code>-display sdl,gl=on</code> ó <code>-display gtk,gl=on</code> Para la salida de pantalla sdl y gtk respectivamente. La configuración correcta se puede confirmar mirando el registro del kernel en el invitado:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># dmesg | grep drm </pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[drm] pci: virtio-vga detected
[drm] virgl 3d acceleration enabled
</pre>
<p>A partir de septiembre de 2016, el soporte para el protocolo de especias está en desarrollo y se puede probar la instalación de la versión de desarrollo de <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=spice">spice</a></span> (&gt;= 0.13.2) y la recompilación de qemu.
</p>
<p>Para más información visite <a rel="nofollow" class="external text" href="https://web.archive.org/web/20171216170334/https://www.kraxel.org/blog/tag/virgl/">blog de kraxel</a>.
</p>
<h3><span class="mw-headline" id="cirrus">cirrus</span></h3>
<p>El adaptador gráfico cirrus fue el predeterminado <a rel="nofollow" class="external text" href="https://wiki.qemu.org/ChangeLog/2.2#VGA">before 2.2</a>. <a rel="nofollow" class="external text" href="Https://www.kraxel.org/blog/2014/10/qemu-using-cirrus-considered-harmful/">no debería</a> utilizarse en sistemas modernos.
</p>
<h3><span class="mw-headline" id="none">none</span></h3>
<p>Esto es como un PC que no tiene tarjeta VGA en absoluto. Ni siquiera podrías acceder a ella con la opción <code>-vnc</code>. Además, esto es diferente de la opción <code>-nographic</code> que permite a QEMU emular una tarjeta VGA, pero deshabilita la visualización SDL.
</p>
<h3><span class="mw-headline" id="vnc">vnc</span></h3>
<p>Dado que usó la opción <code>-nographic</code>, puede agregar la opción <code>-vnc display</code> para que QEMU escuche en <code>display</code> y redirigir la pantalla VGA a la sesión VNC . Hay un ejemplo de esto en las configuraciones de ejemplo de la sección <a href="#Inicio_de_las_m%C3%A1quinas_virtuales_QEMU_en_el_arranque">#Inicio de las máquinas virtuales QEMU en el arranque</a>.
</p>
<pre>$ qemu-system-i386 -vga std -nographic -vnc :0
$ gvncviewer :0
</pre>
<p>Al usar VNC, puede experimentar problemas de teclado descritos (en detalles gory) <a rel="nofollow" class="external text" href="https://www.berrange.com/posts/2010/07/04/more-than-you-or-i-ever-wanted-to-know-about-virtual-keyboard-handling/">aquí</a>. La solución es "no" usar la opción <code>-k</code> en QEMU y usar <code>gvncviewer</code> de <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=gtk-vnc">gtk-vnc</a></span>. Ver también <a rel="nofollow" class="external text" href="https://www.mail-archive.com/libvir-list@redhat.com/msg13340.html">este</a> mensaje publicado en la lista de correo de libvirt.
</p>
<h2><span class="mw-headline" id="Audio">Audio</span></h2>
<h3><span class="mw-headline" id="Host">Host</span></h3>
<p>El controlador de audio utilizado por QEMU se establece con la variable de entorno <code>QEMU_AUDIO_DRV</code>:
</p>
<pre>$ export QEMU_AUDIO_DRV=pa
</pre>
<p>Ejecute el siguiente comando para obtener las opciones de configuración de QEMU relacionadas con PulseAudio:
</p>
<pre>$ qemu-system-x86_64 -audio-help | awk '/Name: pa/' RS=
</pre>
<p>Las opciones listadas se pueden exportar como variables de entorno, por ejemplo:
</p>
<pre>$ export QEMU_PA_SINK=alsa_output.pci-0000_04_01.0.analog-stereo.monitor
$ export QEMU_PA_SOURCE=input</pre>
<h3><span class="mw-headline" id="Invitado">Invitado</span></h3>
<p>Para obtener la lista de los controladores de audio de emulación compatibles:
</p>
<pre>$ qemu-system-x86_64 -soundhw help
</pre>
<p>Para usar (ej. <code>hda</code>) para el invitado utilice el comando <code>-soundhw hda</code> con QEMU.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong>  Los controladores emulados con tarjeta gráfica de vídeo para la máquina invitada también pueden causar un problema con la calidad del sonido. Pruebe uno por uno para que funcione. Puede listar las opciones posibles con <code>qemu-system-x86_64 -h </code>.</div>
<h2>
<span id="Instalaci.C3.B3n_de_controladores_virtio"></span><span class="mw-headline" id="Instalación_de_controladores_virtio">Instalación de controladores virtio</span>
</h2>
<p>QEMU ofrece a los clientes la posibilidad de utilizar dispositivos bloqueados y de red paravirtualizados utilizando los controladores <a rel="nofollow" class="external text" href="https://wiki.libvirt.org/page/Virtio">virtio</a>, que proporcionan un mejor rendimiento y menores gastos generales.
</p>
<p>Un dispositivo virtio bloque requiere la opción <code>-drive</code> en lugar del simple <code>-hd *</code> más <code>if=virtio</code>:
</p>
<pre>$ qemu-system-i386 -boot order=c -drive file=<i>disk_image</i>,if=virtio
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> <code>-boot order=c</code> es absolutamente necesario cuando se desea arrancar desde él. No hay detección automática como con <code>-hd*</code>.</div>
<ul><li>Casi de la misma manera para la red:</li></ul>
<pre>$ qemu-system-i386 -net nic,model=virtio
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong>  Esto sólo funcionará si la máquina invitada tiene controladores para dispositivos virtio. Linux lo hace, y los controladores necesarios están incluidos en Arch Linux, pero no hay garantía de que los dispositivos virtio funcionen con otros sistemas operativos.</div>
<h3><span class="mw-headline" id="Preparando_a_Arch_Linux_como_invitado">Preparando a Arch Linux como invitado</span></h3>
<p>Para utilizar los dispositivos virtio después de instalar un invitado de Arch Linux, se deben cargar en el invitado los siguientes módulos: <code>virtio</code>, <code>virtio_pci</code>, <code>virtio_blk</code>, <code>Virtio_net</code>, y <code>virtio_ring</code>. Para los huéspedes de 32 bits, no es necesario el módulo "virtio" específico.
</p>
<p>Si desea arrancar desde un disco virtio, el disco ramd inicial debe contener los módulos necesarios. De forma predeterminada, esto es manejado por el gancho <code>autodetect</code> de <a href="/title/Mkinitcpio" title="Mkinitcpio">mkinitcpio</a>. De lo contrario, utilice la matriz <code>MODULES</code> en <code>/etc/mkinitcpio.conf</code> para incluir los módulos necesarios y reconstruir el disco ramd inicial.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/mkinitcpio.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">MODULES="virtio virtio_blk virtio_pci virtio_net"</pre>
<p>Los discos Virtio se reconocen con el prefijo <code><b>v</b></code> (ej. <code><b>v</b> da</code>, {{ic|<b>v</b> db} }, etc.); Por lo tanto, los cambios deben realizarse al menos en <code>/etc/fstab</code> y <code>/boot/grub/grub.cfg</code> al arrancar desde un disco virtio.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Cuando se hace referencia a discos por <a href="/title/UUID" class="mw-redirect" title="UUID">UUID</a> en <code>/etc/fstab</code> y bootloader, no hay nada que hacer.</div>
<p>Se puede encontrar más información sobre la paravirtualización con KVM <a rel="nofollow" class="external text" href="https://www.linux-kvm.org/page/Boot_from_virtio_block_device">aquí</a>.
</p>
<p>También puede instalar <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-guest-agent">qemu-guest-agent</a></span> para implementar la compatibilidad con los comandos QMP que mejorarán las capacidades de administración del hipervisor. Después de instalar el paquete, puedes habilitar e iniciar el <code>qemu-ga.service</code>.
</p>
<h3><span class="mw-headline" id="Preparar_un_invitado_de_Windows">Preparar un invitado de Windows</span></h3>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> La única forma (fiable) de actualizar un cliente de Windows 8.1 a Windows 10 parece que es elegir temporalmente cpu core2duo, nx para la instalación <a rel="nofollow" class="external autonumber" href="https://ubuntuforums.org/showthread.php?t=2289210">[3]</a>. Después de la instalación, puede volver a otros ajustes de la CPU (8/8/2015).</div>
<h4><span class="mw-headline" id="Bloquear_controladores_de_dispositivo">Bloquear controladores de dispositivo</span></h4>
<h5>
<span id="Nueva_instalaci.C3.B3n_de_Windows"></span><span class="mw-headline" id="Nueva_instalación_de_Windows">Nueva instalación de Windows</span>
</h5>
<p>Windows no viene con los controladores virtio. Por lo tanto, tendrá que cargarlos durante la instalación. Hay básicamente dos maneras de hacer esto: vía disco blando o vía archivos de ISO. Ambas imágenes se pueden descargar desde el repositorio <a rel="nofollow" class="external text" href="https://fedoraproject.org/wiki/Windows_Virtio_Drivers">Fedora</a>.
</p>
<p>La opción del disquete es difícil porque necesitará presionar F6 (Shift-F6 en Windows más reciente) al inicio de la alimentación del QEMU. Esto es difícil ya que necesitas tiempo para conectar tu ventana de consola VNC. Puede intentar agregar un retardo a la secuencia de arranque. Consulte <code>man qemu-system</code> para obtener más detalles sobre la aplicación de un retardo en el arranque.
</p>
<p>La opción ISO para cargar los controladores es la forma preferida, pero está disponible sólo en Windows Vista y Windows Server 2008 y versiones posteriores. El procedimiento consiste en cargar la imagen con controladores virtio en un dispositivo de cdrom adicional junto con el dispositivo de disco principal y el instalador de Windows:
</p>
<pre>$ qemu-system-i386 ... \
-drive file=<i>/path/to/primary/disk.img</i>,index=0,media=disk,if=virtio \
-drive file=<i>/path/to/installer.iso</i>,index=2,media=cdrom \
-drive file=<i>/path/to/virtio.iso</i>,index=3,media=cdrom \
...
</pre>
<p>Durante la instalación, el instalador de Windows le pedirá su clave de producto y realizará algunas comprobaciones adicionales. Cuando llegue a la "¿Dónde desea instalar Windows?" Pantalla, dará una advertencia de que no se encuentran discos. Siga las instrucciones de ejemplo siguientes (basadas en Windows Server 2012 R2 con Actualización).
</p>
<ul>
<li>Seleccione la opción <code>Load Drivers</code>.</li>
<li>Desactive la casilla de "Ocultar los controladores que no son compatibles con el hardware de este equipo".</li>
<li>Haga clic en el botón Examinar y abra el CDROM para la virtio iso, normalmente llamada "virtio-win-XX".</li>
<li>Ahora vaya a <code>E:\viostor\[your-os]\amd64</code>, seleccione y pulse OK.</li>
<li>Click Next</li>
</ul>
<p>Ahora debería ver sus discos virtio listados aquí, listos para ser seleccionados, formateados e instalados.
</p>
<h5>
<span id="Cambiar_la_m.C3.A1quina_virtual_existente_de_Windows_para_utilizar_virtio"></span><span class="mw-headline" id="Cambiar_la_máquina_virtual_existente_de_Windows_para_utilizar_virtio">Cambiar la máquina virtual existente de Windows para utilizar virtio</span>
</h5>
<p>Modificar un invitado de Windows existente para arrancar desde disco virtio es un poco difícil.
</p>
<p>Puede descargar el controlador de disco virtio desde el <a rel="nofollow" class="external text" href="https://fedoraproject.org/wiki/Windows_Virtio_Drivers">repositorio de Fedora</a>.
</p>
<p>Ahora necesita crear una nueva imagen de disco, que llene la fuerza de Windows para buscar el controlador. Por ejemplo:
</p>
<pre>$ qemu-img create -f qcow2 <i>fake.qcow2</i> 1G
</pre>
<p>Ejecute el invitado original de Windows (con el disco de inicio todavía en modo IDE) con el disco falso (en modo virtio) y un CD-ROM con el controlador.
</p>
<pre>$ qemu-system-i386 -m 512 -vga std -drive file=<i>windows_disk_image</i>,if=ide -drive file=<i>fake.qcow2</i>,if=virtio -cdrom virtio-win-0.1-81.iso
</pre>
<p>Windows detectará el disco falso y tratará de encontrar un controlador para ello. Si falla, vaya al <i> Administrador de dispositivos </i>, busque la unidad SCSI con un icono de signo de exclamación (debe estar abierto), haga clic en <i> Actualizar controlador </i> y seleccione el CD-ROM virtual. No olvide seleccionar la casilla de verificación que dice que debe buscar directorios recursivamente.
</p>
<p>Cuando la instalación se realiza correctamente, puede apagar la máquina virtual y volver a iniciarla, ahora con el disco de arranque conectado en modo virtio:
</p>
<pre>$ qemu-system-i386 -m 512 -vga std -drive file=<i>windows_disk_image</i>,if=virtio
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Si encuentra la pantalla azul de Death, asegúrese de no olvidar el parámetro <code>-m</code> y de que no arranca con virtio en lugar de ide para la unidad del sistema antes de instalar los controladores.</div>
<h4><span class="mw-headline" id="Controladores_de_red">Controladores de red</span></h4>
<p>La instalación de los controladores de red virtio es un poco más fácil, simplemente agregue el argumento <code>-net</code> como se explicó anteriormente.
</p>
<pre>$ qemu-system-i386 -m 512 -vga std -drive file=<i>windows_disk_image</i>,if=virtio -net nic,model=virtio -cdrom virtio-win-0.1-74.iso
</pre>
<p>Windows detectará el adaptador de red y tratará de encontrar un controlador para ello. Si falla, vaya al <i>Administrador de dispositivos</i>, localice el adaptador de red con un icono de signo de exclamación (debe estar abierto), haga clic en <i>Actualizar controlador</i> y seleccione el CD-ROM virtual. No olvide seleccionar la casilla de verificación que dice que debe buscar directorios recursivamente.
</p>
<h3>
<span id="Preparaci.C3.B3n_de_FreeBSD_como_invitado"></span><span class="mw-headline" id="Preparación_de_FreeBSD_como_invitado">Preparación de FreeBSD como invitado</span>
</h3>
<p>Instale el puerto <code>emulators/virtio-kmod</code> si está utilizando FreeBSD 8.3 o posterior hasta 10.0-CURRENT donde están incluidos en el kernel. Después de la instalación, añada lo siguiente a su archivo <code>/boot/loader.conf</code>:
</p>
<pre>virtio_loader="YES"
virtio_pci_load="YES"
virtio_blk_load="YES"
if_vtnet_load="YES"
virtio_balloon_load="YES"
</pre>
<p>A continuación, modifique su <code>/etc/fstab</code> haciendo lo siguiente:
</p>
<pre>sed -i bak "s/ada/vtbd/g" /etc/fstab
</pre>
<p>Y verificar que <code>/etc/fstab</code> es consistente. Si algo sale mal, sólo arranque en un CD de rescate y copie <code>/etc/fstab.bak</code> de vuelta a <code>/etc/fstab</code>.
</p>
<h2><span class="mw-headline" id="Consejos_y_trucos">Consejos y trucos</span></h2>
<h3>
<span id="Inicio_de_las_m.C3.A1quinas_virtuales_QEMU_en_el_arranque"></span><span class="mw-headline" id="Inicio_de_las_máquinas_virtuales_QEMU_en_el_arranque">Inicio de las máquinas virtuales QEMU en el arranque</span>
</h3>
<h4><span class="mw-headline" id="Con_libvirt">Con libvirt</span></h4>
<p>Si se configura una máquina virtual con <a href="/title/Libvirt" title="Libvirt">libvirt</a>, se puede configurar a través de la interfaz gráfica de usuario de virt-manager para iniciar en el arranque de host, accediendo a las Opciones de arranque de la máquina virtual y seleccionando "Inicio de la máquina virtual en el arranque del host".
</p>
<h4><span class="mw-headline" id="Script_personalizado">Script personalizado</span></h4>
<p>Para ejecutar QEMU VMs al arrancar, puede usar las siguientes unidades systemd y config.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/systemd/system/qemu@.service</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[Unit]
Description=QEMU virtual machine

[Service]
Environment="type=system-x86_64" "haltcmd=kill -INT $MAINPID"
EnvironmentFile=/etc/conf.d/qemu.d/%i
ExecStart=/usr/bin/env qemu-${type} -name %i -nographic $args
ExecStop=/bin/sh -c ${haltcmd}
TimeoutStopSec=30
KillMode=none

[Install]
WantedBy=multi-user.target
</pre>
<p>{{Nota| De acuerdo con <code>systemd.service (5)</code> y <code>systemd.kill (5)</code> man, es necesario utilizar <code>KillMode=none</code> opción. De lo contrario, el proceso qemu principal se eliminará inmediatamente después de que se cierre el comando <code>ExecStop</code> (simplemente hace eco de una cadena) y su sistema de búsqueda no podrá apagarse correctamente.
</p>
<p>A continuación, cree archivos de configuración por-VM, denominados <code>/etc/conf.d/qemu.d/<i>vm_name</i></code>, con las siguientes variables establecidas:
</p>
<dl>
<dt>type</dt>
<dd>QEMU binary to call. If specified, will be prepended with <code>/usr/bin/qemu-</code> and that binary will be used to start the VM. I.e. you can boot e.g. <code>qemu-system-arm</code> images with <code>type="system-arm"</code>.</dd>
<dt>args</dt>
<dd>QEMU command line to start with. Will always be prepended with <code>-name ${vm} -nographic</code>.</dd>
<dt>haltcmd</dt>
<dd>Command to shut down a VM safely. I am using <code>-monitor telnet:..</code> and power off my VMs via ACPI by sending <code>system_powerdown</code> to monitor. You can use SSH or some other ways.</dd>
</dl>
<p>Ejemplo de configuración:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/conf.d/qemu.d/one</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">type="system-x86_64"

args="-enable-kvm -m 512 -hda /dev/mapper/vg0-vm1 -net nic,macaddr=DE:AD:BE:EF:E0:00 \
 -net tap,ifname=tap0 -serial telnet:localhost:7000,server,nowait,nodelay \
 -monitor telnet:localhost:7100,server,nowait,nodelay -vnc :0"

haltcmd="echo 'system_powerdown' | nc localhost 7100" # or netcat/ncat

# You can use other ways to shut down your VM correctly
#haltcmd="ssh powermanager@vm1 sudo poweroff"
</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/conf.d/qemu.d/two</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">args="-enable-kvm -m 512 -hda /srv/kvm/vm2.img -net nic,macaddr=DE:AD:BE:EF:E0:01 \
 -net tap,ifname=tap1 -serial telnet:localhost:7001,server,nowait,nodelay \
 -monitor telnet:localhost:7101,server,nowait,nodelay -vnc :1"

haltcmd="echo 'system_powerdown' | nc localhost 7101"
</pre>
<p>Para establecer qué máquinas virtuales se iniciarán al arrancar, habilite la unidad de <a href="/title/Systemd" title="Systemd">systemd</a> <code>qemu@<i>vm_name</i>.service</code>.
</p>
<h3>
<span id="Integraci.C3.B3n_del_rat.C3.B3n"></span><span class="mw-headline" id="Integración_del_ratón">Integración del ratón</span>
</h3>
<p>Para evitar que el ratón sea agarrado al hacer clic en la ventana del sistema operativo invitado, agregue la opción <code>-usbdevice tablet</code>. Esto significa que QEMU puede reportar la posición del ratón sin tener que agarrar el ratón. Esto también anula la emulación de ratón PS/2 cuando se activa. Por ejemplo:
</p>
<pre>$ qemu-system-i386 -hda <i>disk_image</i> -m 512 -vga std -usbdevice tablet
</pre>
<p>If that does not work, try the tip at <a href="#El_cursor_del_rat%C3%B3n_est%C3%A1_nervioso_o_err%C3%A1tico">#El cursor del ratón está nervioso o errático</a>.
</p>
<h3><span class="mw-headline" id="Dispositivo_USB_del_host_de_paso">Dispositivo USB del host de paso</span></h3>
<p>Para acceder al dispositivo físico USB conectado al host desde la VM, puede utilizar la opción: <code>-usbdevice host:<i>vendor_id</i>:<i>product_id</i></code>.
</p>
<p>Puedes encontrar <code>vendor_id</code> y <code>product_id</code> de tu dispositivo con el comando <code>lsusb</code>.
</p>
<p>Puesto que el chipset I440FX por defecto emulado por qemu cuentan con un solo controlador UHCI (USB 1), la opción <code>-usbdevice</code> intentará conectar su dispositivo físico a él. En algunos casos esto puede causar problemas con los dispositivos más nuevos. Una posible solución es emular el chipset <a rel="nofollow" class="external text" href="https://wiki.qemu.org/Features/Q35">ICH9</a>, que ofrece un controlador EHCI que soporta hasta 12 dispositivos, usando la opción <code>-machine type=q35</code>.
</p>
<p>Una solución menos invasiva es emular un controlador EHCI (USB 2) o XHCI (USB 3) con la opción <code>-device usb-ehci, id = ehci</code> o <code>-device nec -usb-xhci, id=xhci</code> respectivamente y luego adjuntar su dispositivo físico con la opción <code>-device usb-host,..</code> como sigue:
</p>
<pre>-device usb-host,bus=<b>controller_id</b>.0,vendorid=0x<b>vendor_id</b>,productid=0x<b>product_id</b>
</pre>
<p>También puede agregar la configuración <code>..., port =<i>&lt;n&gt;</i></code> a la opción anterior para especificar en qué puerto físico del controlador virtual que desea conectar su dispositivo, útil en El caso que desea agregar varios dispositivos usb a la VM.
</p>
<p>{{Nota|Si encuentra errores de permisos al ejecutar QEMU, consulte <a href="/title/Udev_(Espa%C3%B1ol)#Escribir_reglas_udev" title="Udev (Español)">Udev (Español)#Escribir reglas udev</a> para obtener información sobre cómo establecer permisos del dispositivo.
</p>
<h3><span class="mw-headline" id="Habilitar_KSM">Habilitar KSM</span></h3>
<p>Kernel Samepage Merging (KSM) es una característica del kernel de Linux que permite que una aplicación se registre con el kernel para que sus páginas se combinen con otros procesos que también se registren para que sus páginas se fusionen. El mecanismo KSM permite a las máquinas virtuales invitadas compartir páginas entre sí. En un entorno donde muchos de los sistemas operativos invitados son similares, esto puede resultar en ahorros significativos de memoria.
</p>
<p>Para activar KSM, simplemente ejecute:
</p>
<pre># echo 1 &gt; /sys/kernel/mm/ksm/run
</pre>
<p>Para hacerlo permanente, puede utilizar <a href="/title/Systemd#Temporary_files" title="Systemd">archivos temporales de systemd</a><sup>[<a href="/title/Help:Procedures#Fix_broken_section_links" title="Help:Procedures">broken link</a>: invalid section]</sup>:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/tmpfiles.d/ksm.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">w /sys/kernel/mm/ksm/run - - - - 1
</pre>
<p>Si KSM está en ejecución y hay páginas que se van a fusionar (es decir, al menos dos máquinas virtuales similares se están ejecutando), entonces <code>/sys/kernel/mm/ksm/pages_shared</code> debería ser distinto de cero. Consulte <a rel="nofollow" class="external free" href="https://www.kernel.org/doc/html/latest/vm/ksm.html">https://www.kernel.org/doc/html/latest/vm/ksm.html</a> para obtener más información.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Sugerencia:</strong>  Una manera fácil de ver lo bien que KSM está realizando es simplemente imprimir el contenido de todos los archivos de ese directorio: <pre>$ grep./Sys/kernel/mm/ksm/*</pre>
</div>
<h3><span class="mw-headline" id="Multi-monitor_support">Multi-monitor support</span></h3>
<p>El controlador QXL de Linux soporta cuatro cabezas (pantallas virtuales) de forma predeterminada. Esto se puede cambiar a través del parámetro kernel <code>qxl.heads = N</code>.
</p>
<p>El tamaño de memoria VGA predeterminado para los dispositivos QXL es de 16M (el tamaño de la VRAM es de 64M). Esto no es suficiente si desea habilitar dos monitores 1920x1200 ya que requiere 2 × 1920 × 4 (profundidad de color) × 1200 = 17.6 MiB memoria VGA. Esto se puede cambiar reemplazando <code>-vga qxl</code> por <code>-vga none -device qxl-vga, vgamem_mb=32</code>. Si alguna vez incrementas vgamem_mb más allá de 64M, también debes aumentar la opción <code>vram_size_mb</code>.
</p>
<h3><span class="mw-headline" id="Copiar_y_pegar">Copiar y pegar</span></h3>
<p>Para poder copiar y pegar entre el host y el invitado, debe habilitar el canal de comunicación del agente de especias. Requiere agregar un dispositivo virtio-serial al huésped, y abrir un puerto para el vdagent de la especia. También es necesario instalar el spice vdagent en invitado (<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=spice-vdagent">spice-vdagent</a></span> para invitados de Arch, <a rel="nofollow" class="external text" href="https://www.spice-space.org/download.html">Herramientas para invitados de Windows</a> para invitados de Windows). Asegúrese de que el agente se está ejecutando (y para el futuro, se iniciará automáticamente).
</p>
<p>Inicie QEMU con las siguientes opciones:
</p>
<pre>$ qemu-system-i386 -vga qxl -spice port=5930,disable-ticketing -device virtio-serial-pci -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 -chardev spicevmc,id=spicechannel0,name=vdagent
</pre>
<p>La opción <code>-device virtio-serial-pci</code> añade el dispositivo virtio-serial, <code>-device virtserialport, chardev=spicechannel0, nombre=com.redhat.spice.0</code> abre un puerto Para spice vdagent en ese dispositivo y <code>-chardev spicevmc, id=spicechannel0, nombre=vdagent</code> añade un spicevmc chardev para ese puerto.
</p>
<p>Es importante que la opción <code>chardev=</code> del dispositivo <code>virtserialport</code> coincida con la opción <code>id=</code> dada a la opción <code> chardev</code> (<code>spicechannel0</code> en este ejemplo). También es importante que el nombre del puerto sea <code>com.redhat.spice.0</code>, ya que es el espacio de nombres donde vdagent está buscando en el invitado. Y finalmente, especifique <code>name=vdagent</code> para que spice sepa para qué sirve este canal.
</p>
<h3>
<span id="Notas_espec.C3.ADficas_de_Windows"></span><span class="mw-headline" id="Notas_específicas_de_Windows">Notas específicas de Windows</span>
</h3>
<p>QEMU puede ejecutar cualquier versión de Windows desde Windows 95 a través de Windows 10.
</p>
<p>Es posible ejecutar <a href="/title/Windows_PE" title="Windows PE">Windows PE</a> en QEMU.
</p>
<h4>
<span id="Inicio_r.C3.A1pido"></span><span class="mw-headline" id="Inicio_rápido">Inicio rápido</span>
</h4>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Se requiere una cuenta de administrador para cambiar la configuración de energía.</div>
<p>Para invitados de Windows 8 (o posteriores), es mejor desactivar "Activar inicio rápido (recomendado)" en Opciones de energía del Panel de control, ya que hace que el invitado se bloquee durante cada arranque.
</p>
<p>El inicio rápido también puede necesitar deshabilitarse para que los cambios en la opción <code>-smp</code> se apliquen correctamente.
</p>
<h4><span class="mw-headline" id="Protocolo_de_escritorio_remoto">Protocolo de escritorio remoto</span></h4>
<p>Si utiliza un invitado de MS Windows, puede utilizar RDP para conectarse a su VM invitada. Si está utilizando una VLAN o no está en la misma red que el invitado, utilice:
</p>
<pre>$ qemu-system-i386 -nographic -net user,hostfwd=tcp::5555-:3389
</pre>
<p>A continuación, conéctese con <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=rdesktop">rdesktop</a></span> ó <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=freerdp">freerdp</a></span> al invitado. Por ejemplo:
</p>
<pre>$ xfreerdp -g 2048x1152 localhost:5555 -z -x lan
</pre>
<h2>
<span id="Soluci.C3.B3n_de_problemas"></span><span class="mw-headline" id="Solución_de_problemas">Solución de problemas</span>
</h2>
<h3>
<span id="La_m.C3.A1quina_virtual_virtual_corre_muy_lento"></span><span class="mw-headline" id="La_máquina_virtual_virtual_corre_muy_lento">La máquina virtual virtual corre muy lento</span>
</h3>
<p>Hay algunas técnicas que se pueden usar para implementar rendimiento en la máquina virtual, por ejemplo:
</p>
<ul>
<li>Use la opción <code>-cpu host</code> para hacer que QEMU emule la CPU del host. Si no se hace esto, podría intentar emular un CPU más genérico.</li>
<li>Especialmente para los invitados de Windows, habilite <a rel="nofollow" class="external text" href="https://blog.wikichoon.com/2014/07/enabling-hyper-v-enlightenments-with-kvm.html">Iluminaciones de Hyper-V</a>: <code>-Host de la CPU, hv_relaxed, hv_spinlocks=0x1fff, hv_vapic, hv_time</code>.</li>
<li>Si la máquina host tiene varias CPUs, asigne al invitado más CPUs usando la opción <code>-smp</code>.</li>
<li>Asegúrese de haber asignado a la máquina virtual suficiente memoria. De forma predeterminada, QEMU sólo asigna 128 MiB de memoria a cada máquina virtual. Utilice la opción <code>-m</code> para asignar más memoria. Por ejemplo, <code>-m 1024</code> ejecuta una máquina virtual con 1024 MiB de memoria.</li>
<li>Utilice KVM si es posible: agregue <code>-machine type=pc, accel=kvm</code> al comando de arranque QEMU que utilice.</li>
<li>Si es compatible con los controladores del sistema operativo invitado, utilice <a rel="nofollow" class="external text" href="https://wiki.libvirt.org/page/Virtio">virtio</a> para dispositivos de red y/o bloque. Por ejemplo:</li>
</ul>
<pre>$ qemu-system-i386 -net nic, model=virtio -net tap, if=tap0, script=no-drive file=<i>disk_image</i>,media=disco, if=virtio
</pre>
<ul>
<li>Utilizar dispositivos TAP en lugar de redes en modo usuario. Consulte <a href="#Tap_de_red_con_QEMU">#Tap de red con QEMU</a>.</li>
<li>Si el sistema operativo invitado está haciendo escritura pesada en su disco, puede beneficiarse de ciertas opciones de montaje en el sistema de archivos del host. Por ejemplo, puede montar un <a href="/title/Ext4" title="Ext4">sistema de archivos ext4</a> con la opción <code>barrier=0</code>. Debe leer la documentación de las opciones que cambie porque a veces las opciones de mejora de rendimiento para los sistemas de archivos tienen el costo de integridad de los datos.</li>
<li>Si tiene una imagen de disco sin procesar, puede deshabilitar la caché:</li>
</ul>
<pre>$ qemu-system-i386 -drive file=<i>disk_image</i>, if=virtio, cache=none
</pre>
<ul><li>Utilice el nativo Linux AIO:</li></ul>
<pre>$ qemu-system-i386 -drive file=<i>disk_image</i>, if=virtio, aio=native
</pre>
<ul><li>Si utiliza una imagen de disco qcow2, el rendimiento de E/S se puede mejorar considerablemente al garantizar que el caché L2 es de tamaño suficiente. La fórmula <a rel="nofollow" class="external autonumber" href="https://blogs.igalia.com/berto/2015/12/17/improving-disk-io-performance-in-qemu-2-5-with-the-qcow2-l2-cache/">[4]</a> para calcular La caché L2 es: l2_cache_size = disk_size * 8 / cluster_size. Suponiendo que la imagen qcow2 se creó con el tamaño de clúster predeterminado de 64 K, esto significa que para cada 8 GB de tamaño de la imagen qcow2, 1 MB de caché L2 es mejor para el rendimiento. QEMU utiliza sólo 1 MB por defecto; Especificar una caché más grande se hace en la línea de comandos QEMU. Por ejemplo, para especificar 4 MB de caché (adecuado para un disco de 32 GB con un tamaño de clúster de 64 KB):</li></ul>
<pre>$ qemu-system-i386 -drive file=<i>disk_image</i>,format=qcow2, l2-cache-size=4M
</pre>
<ul>
<li>Si está ejecutando varias máquinas virtuales al mismo tiempo que todas tienen el mismo sistema operativo instalado, puede ahorrar memoria al habilitar <a href="https://en.wikipedia.org/wiki/Kernel_SamePage_Merging_(KSM)" class="extiw" title="wikipedia:Kernel SamePage Merging (KSM)">kernel de la misma página de fusión</a>. Consulte <a href="#Habilitar_KSM">#Habilitar KSM</a>.</li>
<li>En algunos casos, la memoria se puede recuperar de correr máquinas virtuales ejecutando un controlador de globo de memoria en el sistema operativo invitado y lanzando QEMU con la opción <code>-balloon virtio</code>.</li>
<li>Es posible utilizar una capa de emulación para un controlador ICH-9 AHCI (aunque puede ser inestable). La emulación AHCI soporta [[Wikipedia: Native_Command_Queuing] NCQ], por lo que varias peticiones de lectura o escritura pueden estar pendientes al mismo tiempo:</li>
</ul>
<pre>$ qemu-system-i386 -drive id=disc, file=<i>disk_image</i>, if=none -device ich9-ahci, id=ahci -device ide-drive, drive=disk, bus=ahci.0
</pre>
<p>Mira <a rel="nofollow" class="external free" href="https://www.linux-kvm.org/page/Tuning_KVM">https://www.linux-kvm.org/page/Tuning_KVM</a> para más información.
</p>
<h3>
<span id="El_cursor_del_rat.C3.B3n_est.C3.A1_nervioso_o_err.C3.A1tico"></span><span class="mw-headline" id="El_cursor_del_ratón_está_nervioso_o_errático">El cursor del ratón está nervioso o errático</span>
</h3>
<p>Si el cursor "brinca" descontroladamente, podría ayudar ingresar este comando en la terminal antes de iniciar QEMU
</p>
<pre>$ export SDL_VIDEO_X11_DGAMOUSE=0
</pre>
<p>Si funciono, puedes agregarlo a tu <code>~/.bashrc</code> archivo.
</p>
<h3><span class="mw-headline" id="El_cursor_no_es_visible">El cursor no es visible</span></h3>
<p>Añade <code>-show-cursor</code> a las opciones de QEMU para poder ver el cursor.
</p>
<p>Si persiste, asegurate de configurar la pantalla apropiadamente
</p>
<p>Por ejemplo: <code>-vga qxl</code>
</p>
<h3>
<span id="No_se_puede_mover_.2F_adjuntar_el_cursor"></span><span class="mw-headline" id="No_se_puede_mover_/_adjuntar_el_cursor">No se puede mover / adjuntar el cursor</span>
</h3>
<p>Reemplaza <code>-usbdevice tablet</code> con <code>-usb</code> como opción en QEMU.
</p>
<h3>
<span id="El_teclado_parece_roto_.C3.B3_las_teclas_de_flecha_no_funcionan"></span><span class="mw-headline" id="El_teclado_parece_roto_ó_las_teclas_de_flecha_no_funcionan">El teclado parece roto ó las teclas de flecha no funcionan</span>
</h3>
<p>Probablemente notarás que algunas de tus teclas no funcionan ó "presionan" la tecla equivocada (en particular, las flechas), preferentemente, necesitas especificar la distribución de tu teclado como una opción. La distribución del teclado puede encontrarse en <code>/usr/share/qemu/keymaps</code>.
</p>
<pre>$ qemu-system-i386 -k <i>keymap</i> <i>disk_image</i>
</pre>
<h3>
<span id="Pantalla_de_invitado_estirada_en_el_tama.C3.B1o_de_la_ventana"></span><span class="mw-headline" id="Pantalla_de_invitado_estirada_en_el_tamaño_de_la_ventana">Pantalla de invitado estirada en el tamaño de la ventana</span>
</h3>
<p>Para restarurar el tamaño por defecto de la ventanta, presiona <code>Ctrl+Alt+u</code>.
</p>
<h3>
<span id="ioctl.28KVM_CREATE_VM.29_failed:_16_Device_or_resource_busy"></span><span class="mw-headline" id="ioctl(KVM_CREATE_VM)_failed:_16_Device_or_resource_busy">ioctl(KVM_CREATE_VM) failed: 16 Device or resource busy</span>
</h3>
<p>Si un mensaje de error como este es listado en el arranque de QUEMU con la opción <code>-enable-kvm</code>:
</p>
<pre>ioctl(KVM_CREATE_VM) failed: 16 Device or resource busy
failed to initialize KVM: Device or resource busy
</pre>
<p>Significa que otro <a href="/title/Hypervisor" class="mw-redirect" title="Hypervisor">hypervisor</a> está actualmente activo. No se recomienda ó no es poible correr varios hypervisores en paralelo.
</p>
<h3><span class="mw-headline" id="Mensaje_de_error_libgfapi">Mensaje de error libgfapi</span></h3>
<p>El mensaje de error listado en el arranque:
</p>
<pre>Failed to open module: libgfapi.so.0: cannot open shared object file: No such file or directory
</pre>
<p>No es un problema, sólo significa que hace falta la dependencia opcional de GlusterFS
</p>
<h3><span class="mw-headline" id="Kernel_panic_en_entornos_live">Kernel panic en entornos live</span></h3>
<p>Si inicia un sistema en vivo (ó bootea uno) podría encontrar esto:
</p>
<pre>end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown block(0,0)
</pre>
<p>Ó algún otro proceso de arranque (ej. no se puede desempaquetar initramfs, no puede iniciar un servicio foo).
</p>
<p>Intente iniciar la Máquina Virtual con el <code>-m VALOR</code> switch y un tamaño apropiado de RAM, si la RAM es muy poca probablemente encontrará problemas similares a los anteriores.
</p>
<h2>
<span id="Ver_tambi.C3.A9n"></span><span class="mw-headline" id="Ver_también">Ver también</span>
</h2>
<ul>
<li><a rel="nofollow" class="external text" href="https://qemu.org">Sitio web oficial de QEMU</a></li>
<li><a rel="nofollow" class="external text" href="https://www.linux-kvm.org">Sitio web oficial de KVM</a></li>
<li>
<a rel="nofollow" class="external text" href="https://web.archive.org/web/20200514080826/https://qemu.weilnetz.de/doc/qemu-doc.html">Documentación para el usuario del emulador QEMU</a> (en inglés)</li>
<li>
<a rel="nofollow" class="external text" href="https://en.wikibooks.org/wiki/QEMU">Wikilibro de QEMU</a> (en inglés)</li>
<li>[<a rel="nofollow" class="external free" href="http://alien.slackbook.org/dokuwiki/doku.php?id=slackware:qemu">http://alien.slackbook.org/dokuwiki/doku.php?id=slackware:qemu</a> Virtualización de hardware con QEMU por AlienBOB (última actualización en 2008) (en inglés)</li>
<li>
<a rel="nofollow" class="external text" href="http://blog.falconindy.com/articles/build-a-virtual-army.html">Construyendo un ejército virtual</a> por Falconindy (en inglés)</li>
<li><a rel="nofollow" class="external text" href="https://git.qemu.org/?p=qemu.git;a=tree;f=docs">Últimos documentos</a></li>
<li><a rel="nofollow" class="external text" href="https://qemu.weilnetz.de/">QEMU en Windows</a></li>
<li><a href="https://en.wikipedia.org/wiki/Qemu" class="extiw" title="wikipedia:Qemu">Wikipedia</a></li>
<li>
<a rel="nofollow" class="external text" href="https://wiki.debian.org/QEMU">QEMU - Wiki de Debian</a> (en inglés)</li>
<li><a rel="nofollow" class="external text" href="https://people.gnome.org/~markmc/qemu-networking.html">QEMU Networking on gnome.org</a></li>
<li>
<a rel="nofollow" class="external text" href="http://bsdwiki.reedmedia.net/wiki/networking_qemu_virtual_bsd_systems.html">Red virtual de QEMU en sistemas BSD</a> (en inglés)</li>
<li><a rel="nofollow" class="external text" href="https://www.gnu.org/software/hurd/hurd/running/qemu.html">QEMU on gnu.org</a></li>
<li>
<a rel="nofollow" class="external text" href="https://wiki.freebsd.org/qemu">QEMU en FreeBSD como host</a> (en inglés)</li>
</ul>
</div>
</div>
<div id="catlinks" class="catlinks" data-mw="interface">
<div id="mw-normal-catlinks" class="mw-normal-catlinks">
<a href="/title/Special:Categories" title="Special:Categories">Categories</a>: <ul>
<li><a href="/title/Category:Emulation_(Espa%C3%B1ol)" title="Category:Emulation (Español)">Emulation (Español)</a></li>
<li><a href="/title/Category:Hypervisors_(Espa%C3%B1ol)" title="Category:Hypervisors (Español)">Hypervisors (Español)</a></li>
</ul>
</div>
<div id="mw-hidden-catlinks" class="mw-hidden-catlinks mw-hidden-cats-hidden">Hidden category: <ul><li><a href="/title/Category:Pages_with_broken_section_links" title="Category:Pages with broken section links">Pages with broken section links</a></li></ul>
</div>
</div>
	</div>
</div>

<footer id="footer" class="mw-footer" role="contentinfo" style="margin: 0">
	<ul id="footer-info">
		<li>Retrieved from "<a dir="ltr" href="https://wiki.archlinux.org/index.php?title=QEMU_(Espa%C3%B1ol)&amp;oldid=669292">https://wiki.archlinux.org/index.php?title=QEMU_(Español)&amp;oldid=669292</a>"</li>
		<li id="footer-info-lastmod"> This page was last edited on 8 May 2021, at 11:32.</li>
		<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3 or later</a> unless otherwise noted.</li>
	<br>
</ul>
	<ul id="footer-places">
		<li id="footer-places-privacy"><a href="/title/ArchWiki:Privacy_policy" title="ArchWiki:Privacy policy">Privacy policy</a></li>
		<li id="footer-places-about"><a href="/title/ArchWiki:About" title="ArchWiki:About">About ArchWiki</a></li>
		<li id="footer-places-disclaimer"><a href="/title/ArchWiki:General_disclaimer" title="ArchWiki:General disclaimer">Disclaimers</a></li>
	</ul>
	<ul id="footer-icons" class="noprint">
		<li id="footer-copyrightico">
	</ul>
	<div style="clear: both;"></div>
</footer>



</body>
</html>
