<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<title>dm-crypt (Português)/Device encryption (Português) - ArchWiki</title>
<link rel="stylesheet" href="../ArchWikiOffline.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<meta name="generator" content="MediaWiki 1.35.0">
<meta name="referrer" content="no-referrer-when-downgrade">
<meta name="robots" content="noindex,follow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="/opensearch_desc.php" title="ArchWiki (en)">
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.archlinux.org/api.php?action=rsd">
<link rel="license" href="http://www.gnu.org/copyleft/fdl.html">
<link rel="alternate" type="application/atom+xml" title="ArchWiki Atom feed" href="/index.php?title=Special:RecentChanges&amp;feed=atom">
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Dm-crypt_Português_Device_encryption_Português rootpage-Dm-crypt_Português skin-vector action-view skin-vector-legacy">
<div id="content" class="mw-body" role="main" style="margin: 0">
	<a id="top"></a>
	<div id="siteNotice" class="mw-body-content"></div>
	<div class="mw-indicators mw-body-content">
	</div>
	<h1 id="firstHeading" class="firstHeading" lang="en">dm-crypt (Português)/Device encryption (Português)</h1>
	<div id="bodyContent" class="mw-body-content">
		<div id="siteSub" class="noprint">From ArchWiki</div>
		<div id="contentSub"><span class="subpages">&lt; <a href="/title/Dm-crypt_(Portugu%C3%AAs)" title="Dm-crypt (Português)">Dm-crypt (Português)</a></span></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="#searchInput">Jump to search</a>
		<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<div class="warningbox">The printable version is no longer supported and may have rendering errors. Please update your browser bookmarks and please use the default browser print function instead.</div>
<div class="mw-parser-output">
<p><span></span>
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Status de tradução:</strong> Esse artigo é uma tradução de <a href="/title/Dm-crypt/Device_encryption" title="Dm-crypt/Device encryption">Dm-crypt/Device encryption</a>. Data da última tradução: 2020-05-25. Você pode ajudar a sincronizar a tradução, se houver <a rel="nofollow" class="external text" href="https://wiki.archlinux.org/index.php?title=Dm-crypt/Device_encryption&amp;diff=0&amp;oldid=614703">alterações</a> na versão em inglês.</div>
<p>Esta página mostra como utilizar <i>dm-crypt</i> pela linha de comando para criptografar um sistema.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading">
<input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none"><div class="toctitle" lang="en" dir="ltr">
<h2 id="mw-toc-heading">Contents</h2>
<span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span>
</div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Prepara%C3%A7%C3%A3o"><span class="tocnumber">1</span> <span class="toctext">Preparação</span></a></li>
<li class="toclevel-1 tocsection-2">
<a href="#Uso_do_cryptsetup"><span class="tocnumber">2</span> <span class="toctext">Uso do cryptsetup</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Senhas_e_chaves_do_cryptsetup"><span class="tocnumber">2.1</span> <span class="toctext">Senhas e chaves do cryptsetup</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4">
<a href="#Op%C3%A7%C3%B5es_de_encripta%C3%A7%C3%A3o_com_dm-crypt"><span class="tocnumber">3</span> <span class="toctext">Opções de encriptação com dm-crypt</span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="#Op%C3%A7%C3%B5es_de_encripta%C3%A7%C3%A3o_para_o_modo_LUKS"><span class="tocnumber">3.1</span> <span class="toctext">Opções de encriptação para o modo LUKS</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Op%C3%A7%C3%B5es_de_encripta%C3%A7%C3%A3o_para_o_modo_plain"><span class="tocnumber">3.2</span> <span class="toctext">Opções de encriptação para o modo plain</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-7">
<a href="#Criptografando_dispositivos_com_cryptsetup"><span class="tocnumber">4</span> <span class="toctext">Criptografando dispositivos com cryptsetup</span></a>
<ul>
<li class="toclevel-2 tocsection-8">
<a href="#Criptografando_dispositivos_com_o_modo_LUKS"><span class="tocnumber">4.1</span> <span class="toctext">Criptografando dispositivos com o modo LUKS</span></a>
<ul>
<li class="toclevel-3 tocsection-9">
<a href="#Formatando_parti%C3%A7%C3%B5es_LUKS"><span class="tocnumber">4.1.1</span> <span class="toctext">Formatando partições LUKS</span></a>
<ul>
<li class="toclevel-4 tocsection-10"><a href="#Formatando_uma_parti%C3%A7%C3%A3o_com_LUKS_e_uma_keyfile"><span class="tocnumber">4.1.1.1</span> <span class="toctext">Formatando uma partição com LUKS e uma keyfile</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-11"><a href="#Abrindo/Mapeando_containers_LUKS_com_o_mapeador_de_dispositivos"><span class="tocnumber">4.1.2</span> <span class="toctext">Abrindo/Mapeando containers LUKS com o mapeador de dispositivos</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-12"><a href="#Criptografando_dispositivos_com_o_modo_plain"><span class="tocnumber">4.2</span> <span class="toctext">Criptografando dispositivos com o modo plain</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-13">
<a href="#A%C3%A7%C3%B5es_espec%C3%ADficas_do_cryptsetup_para_o_LUKS"><span class="tocnumber">5</span> <span class="toctext">Ações específicas do cryptsetup para o LUKS</span></a>
<ul>
<li class="toclevel-2 tocsection-14">
<a href="#Gerenciamento_de_chaves"><span class="tocnumber">5.1</span> <span class="toctext">Gerenciamento de chaves</span></a>
<ul>
<li class="toclevel-3 tocsection-15"><a href="#Adicionando_chaves_do_LUKS"><span class="tocnumber">5.1.1</span> <span class="toctext">Adicionando chaves do LUKS</span></a></li>
<li class="toclevel-3 tocsection-16"><a href="#Removendo_chaves_do_LUKS"><span class="tocnumber">5.1.2</span> <span class="toctext">Removendo chaves do LUKS</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-17">
<a href="#Backup_e_restaura%C3%A7%C3%A3o"><span class="tocnumber">5.2</span> <span class="toctext">Backup e restauração</span></a>
<ul>
<li class="toclevel-3 tocsection-18"><a href="#Backup_usando_o_cryptsetup"><span class="tocnumber">5.2.1</span> <span class="toctext">Backup usando o cryptsetup</span></a></li>
<li class="toclevel-3 tocsection-19"><a href="#Restaura%C3%A7%C3%A3o_usando_o_cryptsetup"><span class="tocnumber">5.2.2</span> <span class="toctext">Restauração usando o cryptsetup</span></a></li>
<li class="toclevel-3 tocsection-20"><a href="#Backup_e_restaura%C3%A7%C3%A3o_manual"><span class="tocnumber">5.2.3</span> <span class="toctext">Backup e restauração manual</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-21">
<a href="#Criptografando_dispositivos_novamente"><span class="tocnumber">5.3</span> <span class="toctext">Criptografando dispositivos novamente</span></a>
<ul>
<li class="toclevel-3 tocsection-22"><a href="#Criptografar_um_sistema_de_arquivos"><span class="tocnumber">5.3.1</span> <span class="toctext">Criptografar um sistema de arquivos</span></a></li>
<li class="toclevel-3 tocsection-23"><a href="#Criptografando_novamente_um_container_LUKS"><span class="tocnumber">5.3.2</span> <span class="toctext">Criptografando novamente um container LUKS</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-24">
<a href="#Redimensionando_os_dispositivos_criptografados"><span class="tocnumber">6</span> <span class="toctext">Redimensionando os dispositivos criptografados</span></a>
<ul>
<li class="toclevel-2 tocsection-25"><a href="#Sistema_de_arquivos_de_loopback"><span class="tocnumber">6.1</span> <span class="toctext">Sistema de arquivos de loopback</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-26">
<a href="#Keyfiles"><span class="tocnumber">7</span> <span class="toctext">Keyfiles</span></a>
<ul>
<li class="toclevel-2 tocsection-27">
<a href="#Tipos_de_keyfiles"><span class="tocnumber">7.1</span> <span class="toctext">Tipos de keyfiles</span></a>
<ul>
<li class="toclevel-3 tocsection-28"><a href="#Senha"><span class="tocnumber">7.1.1</span> <span class="toctext">Senha</span></a></li>
<li class="toclevel-3 tocsection-29"><a href="#Texto_rand%C3%B4mico"><span class="tocnumber">7.1.2</span> <span class="toctext">Texto randômico</span></a></li>
<li class="toclevel-3 tocsection-30"><a href="#Bin%C3%A1rio"><span class="tocnumber">7.1.3</span> <span class="toctext">Binário</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-31">
<a href="#Criando_uma_keyfile_com_caracteres_rand%C3%B4micos"><span class="tocnumber">7.2</span> <span class="toctext">Criando uma keyfile com caracteres randômicos</span></a>
<ul>
<li class="toclevel-3 tocsection-32">
<a href="#Guardando_a_keyfile_em_um_sistema_de_arquivos_filesystem"><span class="tocnumber">7.2.1</span> <span class="toctext">Guardando a keyfile em um sistema de arquivos filesystem</span></a>
<ul>
<li class="toclevel-4 tocsection-33"><a href="#Sobrescrevendo_com_seguran%C3%A7a_as_keyfiles_guardadas"><span class="tocnumber">7.2.1.1</span> <span class="toctext">Sobrescrevendo com segurança as keyfiles guardadas</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-34"><a href="#Guardando_a_keyfile_no_ramfs"><span class="tocnumber">7.2.2</span> <span class="toctext">Guardando a keyfile no ramfs</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-35"><a href="#Configurando_o_LUKS_para_utilizar_uma/outra_keyfile"><span class="tocnumber">7.3</span> <span class="toctext">Configurando o LUKS para utilizar uma/outra keyfile</span></a></li>
<li class="toclevel-2 tocsection-36">
<a href="#Manualmente_abrindo_uma_parti%C3%A7%C3%A3o_com_uma_keyfile"><span class="tocnumber">7.4</span> <span class="toctext">Manualmente abrindo uma partição com uma keyfile</span></a>
<ul>
<li class="toclevel-3 tocsection-37">
<a href="#Com_uma_keyfile_em_um_dispositivo_externo"><span class="tocnumber">7.4.1</span> <span class="toctext">Com uma keyfile em um dispositivo externo</span></a>
<ul>
<li class="toclevel-4 tocsection-38"><a href="#Configurando_o_mkinitcpio"><span class="tocnumber">7.4.1.1</span> <span class="toctext">Configurando o mkinitcpio</span></a></li>
<li class="toclevel-4 tocsection-39"><a href="#Configurando_os_par%C3%A2metros_do_kernel"><span class="tocnumber">7.4.1.2</span> <span class="toctext">Configurando os parâmetros do kernel</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-40"><a href="#Com_uma_keyfile_no_initramfs"><span class="tocnumber">7.4.2</span> <span class="toctext">Com uma keyfile no initramfs</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>

<h2>
<span id="Prepara.C3.A7.C3.A3o"></span><span class="mw-headline" id="Preparação">Preparação</span>
</h2>
<p>Antes de usar <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=cryptsetup">cryptsetup</a></span>, tenha certeza que o <a href="/title/M%C3%B3dulo_de_kernel" class="mw-redirect" title="Módulo de kernel">módulo de kernel</a> <code>dm_crypt</code> está carregado.
</p>
<h2><span class="mw-headline" id="Uso_do_cryptsetup">Uso do cryptsetup</span></h2>
<p><i>cryptsetup</i> é uma ferramenta da linha de comando para o <i>dm-crypt</i> criar, acessar e gerenciar dispositivos criptografados. Ela foi expandida para suportar diferentes tipos de encriptação que dependem do mapeador de dispositivos e módulos criptografados (<b>d</b>evice-<b>m</b>apper and the <b>crypt</b>ographic modules). A expansão mais notável foi o LUKS (Linux Unified Key Setup), que guarda todas as informações necessárias para o dm-crypt no próprio disco e abstrai a partição e gerenciamento de chaves com o objetivo de facilitar o uso. Dispositivos acessados via o mapeador de dispositivos são chamados de dispositivos de bloco (blockdevices). Para mais informações veja <a href="/title/Criptografia_de_dados_em_repouso#Encripta%C3%A7%C3%A3o_de_dispositivo_de_bloco" class="mw-redirect" title="Criptografia de dados em repouso">Criptografia de dados em repouso#Encriptação de dispositivo de bloco</a>.
</p>
<p>A ferramenta é usada da seguinte forma:
</p>
<pre># cryptsetup &lt;OPÇÕES&gt; &lt;ação&gt; &lt;opções-específicas-da-ação&gt; &lt;dispositivo&gt; &lt;dmnome&gt;
</pre>
<p>Existem opções e modo de encriptação padrão, que serão usados se nenhuma outra opção for especificada. Veja
</p>
<pre>$ cryptsetup --help 
</pre>
<p>Todos os parâmetros, opções e ações padrão serão listados. A lista completa das opções pode ser encontrada na página man.
Parâmetros podem ser opcionais ou não, dependendo do modo de encriptação e ação escolhidas, as seções a seguir possuem mais informação sobre elas. A velocidade é muito importante, portanto deve-se escolher com cuidado o algoritmo que vai utilizar. Mudar a cifra criptográfica de um dispositivo de bloco já criptografado é dificíl, por isso é importante verificar a performance do <i>dm-crypt</i> com diferentes parâmetros antes de instalar o sistema:
</p>
<pre>$ cryptsetup benchmark 
</pre>
<p>Lhe ajudará a decidir qual algoritmo e tamanho de chave você quer usar. Se algumas cifras AES se destacarem com uma grande diferença, estas provavelmente devem ter suporte de hardware na CPU.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Dica:</strong> Pode ser desejado praticar a encriptação em uma <a href="/title/Virtualiza%C3%A7%C3%A3o" class="mw-redirect" title="Virtualização">máquina virtual</a>.</div>
<h3><span class="mw-headline" id="Senhas_e_chaves_do_cryptsetup">Senhas e chaves do cryptsetup</span></h3>
<p>Um dispositivo de bloco criptografado é protegido por uma chave. Pode ser:
</p>
<ul>
<li>uma senha, veja <a href="/title/Seguran%C3%A7a#Senhas" class="mw-redirect" title="Segurança">Segurança#Senhas</a>.</li>
<li>uma keyfile, veja <a href="#Keyfiles">#Keyfiles</a>.</li>
</ul>
<p>Ambos os tipos de chave possuem tamanhos padrões máximos: senhas podem ser até 512 caracteres e keyfiles até 8192KiB.
</p>
<p>Uma importante distinção do <i>LUKS</i> a se notar é que a chave é usada para desbloquear a chave mestre do dispositivo criptografado com LUKS, e esta pode ser mudada. Outros modos de encriptação não suportam mudança na chave depois de definida, devido a eles não utilizarem uma chave mestre na encriptação. Veja <a href="/title/Criptografia_de_dados_em_repouso#Encripta%C3%A7%C3%A3o_de_dispositivo_de_bloco" class="mw-redirect" title="Criptografia de dados em repouso">Criptografia de dados em repouso#Encriptação de dispositivo de bloco</a> para detalhes.
</p>
<h2>
<span id="Op.C3.A7.C3.B5es_de_encripta.C3.A7.C3.A3o_com_dm-crypt"></span><span class="mw-headline" id="Opções_de_encriptação_com_dm-crypt">Opções de encriptação com dm-crypt</span>
</h2>
<p><i>Cryptsetup</i> suporta o uso de diferentes modos de encriptação com <i>dm-crypt</i>: 
</p>
<ul>
<li>
<code>--type luks</code> para usar a versão padrão do LUKS (LUKS1 com <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=cryptsetup">cryptsetup</a></span> &lt; 2.1.0, LUKS2 com <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=cryptsetup">cryptsetup</a></span> ≥ 2.1.0),</li>
<li>
<code>--type luks1</code> para usar LUKS1, a versão mais comum do LUKS,</li>
<li>
<code>--type luks2</code> para usar LUKS2, a última versão do LUKS que permite extensões adicionais,</li>
<li>
<code>--type plain</code> para usar o modo plain do dm-crypt,</li>
<li>
<code>--type loopaes</code> para o modo loopaes legacy,</li>
<li>
<code>--type tcrypt</code> para o modo de compatibilidade com <a href="/title/TrueCrypt" title="TrueCrypt">TrueCrypt</a>.</li>
</ul>
<p>As opções criptográficas básicas para as cifras e hashes disponíveis podem ser usadas para todos os modos e dependem das funcionalidades relacionadas a criptografia presentes no kernel. Todas as que são carregadas e disponíveis para uso como opções podem ser vistas com:
</p>
<pre>$ less /proc/crypto 
</pre>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Dica:</strong> Se a lista é pequena, execute <code>$ cryptsetup benchmark</code> que irá ativar a busca de módulos disponíveis.</div>
<p>As opções de encriptação para os modos <code>luks</code>, <code>luks1</code>, <code>luks2</code> e <code>plain</code> serão introduzidas. Note que a tabela lista opções utilizadas em seus respectivos artigos e não todas as disponíveis. 
</p>
<h3>
<span id="Op.C3.A7.C3.B5es_de_encripta.C3.A7.C3.A3o_para_o_modo_LUKS"></span><span class="mw-headline" id="Opções_de_encriptação_para_o_modo_LUKS">Opções de encriptação para o modo LUKS</span>
</h3>
<p>A ação do <i>cryptsetup</i> para configurar um novo dispositivo do dm-crypt no modo de encriptação LUKS é <i>luksFormat</i>. Diferente do que o nome implica, não formata o dispositivo, mas configura o cabeçalho do dispositivo LUKS e criptografa a chave mestre com as opções criptografadas desejadas. 
</p>
<p>como LUKS é o modo de encriptação padrão, você pode criar um novo dispositivo LUKS com os parâmetros padrão (<code>-v</code> é opcional):
</p>
<pre># cryptsetup -v luksFormat <i>dispositivo</i>
</pre>
<p>Em comparação, você pode querer especificar as opções padrão manualmente também:  
</p>
<pre># cryptsetup -v --type luks --cipher aes-xts-plain64 --key-size 256 --hash sha256 --iter-time 2000 --use-urandom --verify-passphrase luksFormat <i>dispositivo</i>
</pre>
<p>As opções padrão são comparadas com um exemplo de especificação criptograficamente maior na tabela abaixo, com comentários: 
</p>
<table class="wikitable">
<tbody>
<tr>
<th>Opções</th>
<th>Padrão do cryptsetup 2.1.0</th>
<th>Exemplo</th>
<th>Comentários
</th>
</tr>
<tr>
<th style="text-align:right;white-space:nowrap;">--cipher
<p>-c
</p>
</th>
<td>
<code>aes-xts-plain64</code>
</td>
<td>
<code>aes-xts-plain64</code>
</td>
<td>
<a rel="nofollow" class="external text" href="https://www.kernel.org/pub/linux/utils/cryptsetup/v1.6/v1.6.0-ReleaseNotes">A versão 1.6.0</a> mudou o padrão para uma <a href="/title/Criptografia_de_dados_em_repouso#Cifras_e_modos_de_opera%C3%A7%C3%A3o" class="mw-redirect" title="Criptografia de dados em repouso">cifra</a> do AES no modo <a href="https://en.wikipedia.org/wiki/Disk_encryption_theory#XEX-based_tweaked-codebook_mode_with_ciphertext_stealing_.28XTS.29" class="extiw" title="wikipedia:Disk encryption theory">XTS</a> (veja o item 5.16 <a rel="nofollow" class="external text" href="https://gitlab.com/cryptsetup/cryptsetup/wikis/FrequentlyAskedQuestions#5-security-aspects">do FAQ</a>). Não é recomendado o uso da cifra padrão anterior <code>--cipher aes-cbc-essiv</code> devido a seus conhecidos <a href="https://en.wikipedia.org/wiki/Disk_encryption_theory#Cipher-block_chaining_.28CBC.29" class="extiw" title="wikipedia:Disk encryption theory">problemas</a> e <a rel="nofollow" class="external text" href="https://www.jakoblell.com/blog/2013/12/22/practical-malleability-attack-against-cbc-encrypted-luks-partitions/">ataques</a> práticos contra eles.
</td>
</tr>
<tr>
<th style="text-align:right;white-space:nowrap;">--key-size
<p>-s
</p>
</th>
<td>
<code>256</code> (<code>512</code> for XTS)
</td>
<td>
<code>512</code>
</td>
<td>Por padrão uma chave com tamanho de 512 bit é usada para cifras XTS. Note no entanto que <a href="https://en.wikipedia.org/wiki/Disk_encryption_theory#XEX-based_tweaked-codebook_mode_with_ciphertext_stealing_.28XTS.29" class="extiw" title="wikipedia:Disk encryption theory">XTS divide a chave no meio</a>, resultando no uso do AES-256.
</td>
</tr>
<tr>
<th style="text-align:right;white-space:nowrap;">--hash
<p>-h
</p>
</th>
<td>
<code>sha256</code>
</td>
<td>
<code>sha512</code>
</td>
<td>O algoritmo de Hash usado para <a href="/title/Criptografia_de_dados_em_repouso#Metadados_criptogr%C3%A1ficos" class="mw-redirect" title="Criptografia de dados em repouso">derivação de chave</a>. A versão 1.7.0 mudou o padrão de <code>sha1</code> para <code>sha256</code> "<i>não por segurança [mas] principalmente para previnir problemas de compabilidade em sistemas onde SHA1 já estava [em] desuso </i>"<a rel="nofollow" class="external autonumber" href="https://www.kernel.org/pub/linux/utils/cryptsetup/v1.7/v1.7.0-ReleaseNotes">[1]</a>. O antigo padrão do <code>sha1</code> pode ainda ser usado por compatibilidade com versões mais velhas do <i>cryptsetup</i> desde que é <a rel="nofollow" class="external text" href="https://gitlab.com/cryptsetup/cryptsetup/wikis/FrequentlyAskedQuestions#5-security-aspects">considerada segura</a> (veja o item 5.20).
</td>
</tr>
<tr>
<th style="text-align:right;white-space:nowrap;">--iter-time
<p>-i
</p>
</th>
<td>
<code>2000</code>
</td>
<td>
<code>5000</code>
</td>
<td>Número de milisegundos a serem esperados com o processamento da senha PBKDF2. A versão 1.7.0 mudou o padrão de <code>1000</code> para <code>2000</code> com o objetivo de "<i>tentar manter a contagem da interação do PBKDF2 alta o bastante e também ainda aceitável pelos usuários.</i>"<a rel="nofollow" class="external autonumber" href="https://www.kernel.org/pub/linux/utils/cryptsetup/v1.7/v1.7.0-ReleaseNotes">[2]</a>. Esta opção é somente relevante para operações do LUKS que definem ou mudam senhas, tais como <i>luksFormat</i> ou <i>luksAddKey</i>. Especificando 0 como parâmetro seleciona o padrão compilado.
</td>
</tr>
<tr>
<th style="text-align:right;white-space:nowrap;">--use-{u,}random
</th>
<td>
<code>--use-urandom</code>
</td>
<td>
<code>--use-random</code>
</td>
<td>Seleciona que <a href="/title/Random_number_generator" class="mw-redirect" title="Random number generator">gerador de números randômicos</a> vai ser utilizado. Traduzindo a página manual do cryptsetup: "Em situações de baixa entropia (exemplo, em um sistema embarcado), ambas as escolhas são problemáticas. Usar /dev/urandom pode resultar em chaves fracas. Usar /dev/random pode demorar muito tempo, potencialmente para sempre, se a entropia coletada pelo kernel não for o bastante."
</td>
</tr>
<tr>
<th style="text-align:right;white-space:nowrap;">--verify-passphrase
<p>-y
</p>
</th>
<td>Yes
</td>
<td>-
</td>
<td>Padrão somente para luksFormat e luksAddKey. Não é necessário digitar essa opção no momento.
</td>
</tr>
</tbody>
</table>
<p>As propriedades das funcionalidades e opções do LUKS são descritas nas especificações do <a rel="nofollow" class="external text" href="https://gitlab.com/cryptsetup/cryptsetup/wikis/Specification">LUKS1</a> (pdf) e <a rel="nofollow" class="external text" href="https://gitlab.com/cryptsetup/cryptsetup/blob/master/docs/on-disk-format-luks2.pdf">LUKS2</a> (pdf).
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Dica:</strong> A apresentação dos desenvolvedores do projeto <a rel="nofollow" class="external text" href="https://mbroz.fedorapeople.org/talks/DevConf2016/devconf2016-luks2.pdf">devconfcz2016</a> (pdf) sumariza a motivação para as grandes mudanças do LUKS2.</div>
<h3>
<span id="Op.C3.A7.C3.B5es_de_encripta.C3.A7.C3.A3o_para_o_modo_plain"></span><span class="mw-headline" id="Opções_de_encriptação_para_o_modo_plain">Opções de encriptação para o modo plain</span>
</h3>
<p>No modo <i>plain</i> do dm-crypt, não existe chave mestre no dispositivo, consequentemente não é necessário defini-lá. As opções de encriptação são empregadas diretamente para criar a mapeação entre o disco criptografado e um dispositivo nomeado. O mapeamento pode ser criado na partição ou no dispositivo todo. Nesse último caso não é necessário uma tabela de partição.
</p>
<p>O mapeamento do modo <i>plain</i> com os parâmetros padrão do cryptsetup pode ser feito com:
</p>
<pre># cryptsetup &lt;opções&gt; open --type plain &lt;dispositivo&gt; &lt;dmnome&gt;
</pre>
<p>Ao executar o comando, será solicitada a senha, que deve possuir uma entropia muito alta.
Abaixo uma comparação dos parâmetros padrão com o exemplo em <a href="/title/Dm-crypt/Criptografando_todo_um_sistema#dm-crypt_plain" class="mw-redirect" title="Dm-crypt/Criptografando todo um sistema">dm-crypt/Criptografando todo um sistema#dm-crypt plain</a>:
</p>
<table class="wikitable">
<tbody>
<tr>
<th>Opção</th>
<th>Padrão do cryptsetup 2.1.0</th>
<th>Exemplo</th>
<th>Comentários
</th>
</tr>
<tr>
<th style="text-align:right;white-space:nowrap;">--hash
<p>-h
</p>
</th>
<td>
<code>ripemd160</code>
</td>
<td>-
</td>
<td>O hash é usado para criar a chave com a senha; não é usado em uma keyfile.
</td>
</tr>
<tr>
<th style="text-align:right;white-space:nowrap;">--cipher
<p>-c
</p>
</th>
<td>
<code>aes-cbc-essiv:sha256</code>
</td>
<td>
<code>aes-xts-plain64</code>
</td>
<td>As cifras consistem de três pares: geradores cifra-modo_de_opeação-IV. Veja <a href="/title/Criptografia_de_dados_em_repouso#Cifras_e_modos_de_opera%C3%A7%C3%A3o" class="mw-redirect" title="Criptografia de dados em repouso">Criptografia de dados em repouso#Cifras e modos de operação</a> para uma explicação dessas configurações, e a <a rel="nofollow" class="external text" href="https://gitlab.com/cryptsetup/cryptsetup/wikis/DMCrypt">documentação do DMCrypt</a> para os modos disponíveis.
</td>
</tr>
<tr>
<th style="text-align:right;white-space:nowrap;">--key-size
<p>-s
</p>
</th>
<td>
<code>256</code>
</td>
<td>
<code>512</code>
</td>
<td>O tamanho da chave (em bits). O tamanho dependerá da cifra e chainmode utilizado. O modo Xts precisa de duas vezes o tamanho da chave do cbc.
</td>
</tr>
<tr>
<th style="text-align:right;white-space:nowrap;">--size
<p>-b
</p>
</th>
<td>Tamanho real do disco alvo
</td>
<td>
<code>2048</code> (dispositivo mapeado será 512B×2048=1MiB)
</td>
<td>Limite o tamanho máximo do dispositivo (em setores de 512-byte).
</td>
</tr>
<tr>
<th style="text-align:right;white-space:nowrap;">--offset
<p>-o
</p>
</th>
<td>
<code>0</code>
</td>
<td>
<code>0</code>
</td>
<td>O quanto pular do inicio do disco alvo (setores de 512-byte) antes de começar o mapeamento
</td>
</tr>
<tr>
<th style="text-align:right;white-space:nowrap;">--skip
<p>-p
</p>
</th>
<td>
<code>0</code>
</td>
<td>
<code>2048</code> (512B×2048=1MiB serão pulados)
</td>
<td>O número de setores de 512-byte de dados criptografados a pular no começo.
</td>
</tr>
<tr>
<th style="text-align:right;white-space:nowrap;">--key-file
<p>-d
</p>
</th>
<td>A senha será usada por padrão
</td>
<td>
<code>/dev/sd<i>Z</i></code> (ou, por exemplo, <code>/boot/keyfile.enc</code>)
</td>
<td>O dispositivo ou arquivo a ser usado como chave. Veja <a href="#Keyfiles">#Keyfiles</a> para mais detalhes.
</td>
</tr>
<tr>
<th style="text-align:right;white-space:nowrap;">--keyfile-offset
</th>
<td>
<code>0</code>
</td>
<td>
<code>0</code>
</td>
<td>Distância do início do arquivo onde a chave começa (em bytes). Esta opção é suportada a partir da versão 1.6.7 do <i>cryptsetup</i>.
</td>
</tr>
<tr>
<th style="text-align:right;white-space:nowrap;">--keyfile-size
<p>-l
</p>
</th>
<td>
<code>8192kB</code>
</td>
<td>- (será utilizado o padrão)
</td>
<td>Limita os bytes lidos da keyfile. Esta opção é suportada a partir da versão 1.6.7 do <i>cryptsetup</i>.
</td>
</tr>
</tbody>
</table>
<p>Se usar o dispositivo <code>/dev/sd<i>X</i></code>, o exemplo da columa acima da direita resulta em:
</p>
<pre># cryptsetup --cipher=aes-xts-plain64 --offset=0 --key-file=/dev/sd<i>Z</i> --key-size=512 open --type=plain /dev/sdX enc
</pre>
<p>Diferente de criptografar com LUKS, o comando acima deve ser executado <i>totalmente</i>, independente se o mapeamento precisa ser re-estabelecido ou não, é importante lembrar da cifra, hash e keyfile.
Agora podemos checar se o mapeamento foi feito:
</p>
<pre># fdisk -l
</pre>
<p>O dispositivo mapeado deve aparecer como <code>/dev/mapper/enc</code>.
</p>
<h2><span class="mw-headline" id="Criptografando_dispositivos_com_cryptsetup">Criptografando dispositivos com cryptsetup</span></h2>
<p>Esta seção mostra como empregar as opções para criar novos dispositivos de bloco criptografados e acessá-los manualmente.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Atenção:</strong> GRUB não suporta cabeçalhos do LUKS2; veja <a rel="nofollow" class="external text" href="https://savannah.gnu.org/bugs/?55093">GRUB bug #55093</a>. Então, se você planeja <a href="/title/GRUB_(Portugu%C3%AAs)#/boot_criptografado" title="GRUB (Português)">abrir uma partição de boot criptografada com o GRUB</a>, especifique <code>--type luks1</code> nos dispositivos criptografados que o GRUB precisa acessar.</div>
<h3><span class="mw-headline" id="Criptografando_dispositivos_com_o_modo_LUKS">Criptografando dispositivos com o modo LUKS</span></h3>
<h4>
<span id="Formatando_parti.C3.A7.C3.B5es_LUKS"></span><span class="mw-headline" id="Formatando_partições_LUKS">Formatando partições LUKS</span>
</h4>
<p>Para configurar uma partição criptografada LUKS, execute:
</p>
<pre># cryptsetup luksFormat <i>dispositivo</i>
</pre>
<p>Lhe será solicitado uma senha e também a verificação desta.
</p>
<p>Veja <a href="#Op%C3%A7%C3%B5es_de_encripta%C3%A7%C3%A3o_para_o_modo_LUKS">#Opções de encriptação para o modo LUKS</a> para opções da linha de comando.
</p>
<p>Você pode checar os resultados com:
</p>
<pre># cryptsetup luksDump <i>dispositivo</i>
</pre>
<p>Note que a saída vai mostrar a informação do cabeçalho da cifra criptográfica, como também as chaves em uso da partição LUKS. 
</p>
<p>O seguinte exemplo criará uma partição raiz criptografada no <code>/dev/sda1</code> usando a cifra AES padrão no modo XTS com uma efetiva encriptação de 256-bit
</p>
<pre># cryptsetup -s 512 luksFormat /dev/sda1
</pre>
<h5>
<span id="Formatando_uma_parti.C3.A7.C3.A3o_com_LUKS_e_uma_keyfile"></span><span class="mw-headline" id="Formatando_uma_partição_com_LUKS_e_uma_keyfile">Formatando uma partição com LUKS e uma keyfile</span>
</h5>
<p>Na criação de uma partição criptografada LUKS, uma keyfile pode ser associada usando:
</p>
<pre># cryptsetup luksFormat <i>dispositivo</i> <i>/caminho/para/keyfile</i>
</pre>
<p>Veja <a href="#Keyfiles">#Keyfiles</a> para instruções em como gerar e gerenciar keyfiles.
</p>
<h4>
<span id="Abrindo.2FMapeando_containers_LUKS_com_o_mapeador_de_dispositivos"></span><span class="mw-headline" id="Abrindo/Mapeando_containers_LUKS_com_o_mapeador_de_dispositivos">Abrindo/Mapeando containers LUKS com o mapeador de dispositivos</span>
</h4>
<p>Uma vez que os containers LUKS foram criados, eles podem ser abertos.
</p>
<p>Para abrir um container LUKS voce precisa definir o nome do novo dispositivo mapeado. Isto alerta o kernel que <code><i>dispositivo</i></code> está criptografado e deve ser acessado através do LUKS usando o <code>/dev/mapper/<i>dm_nome</i></code> para nao sobrescrever os dados criptografados. Para se proteger deste tipo de acidente, leia sobre como fazer <a href="#Backup_e_restaura%C3%A7%C3%A3o">backup do cabeçalho criptografado</a> depois de terminar a configuração.
</p>
<p>Para abrir um container LUKS criptografado execute:
</p>
<pre># cryptsetup open <i>dispositivo</i> <i>dm_nome</i>
</pre>
<p>Será solicitada a senha para abrir o container. Normalmente o nome do dispositivo mapeado é uma breve descrição da função do container mapeado.
Por exemplo, o comando a seguir abre o container LUKS <code>/dev/sda1</code> e mapeia ele para <code>cryptraiz</code>:
</p>
<pre># cryptsetup open /dev/sda1 cryptraiz
</pre>
<p>Uma vez aberto, o container criptografado deve ser acessado pelo caminho <code>/dev/mapper/cryptraiz</code> ao invés do container diretamente (exemplo <code>/dev/sda1</code>). 
</p>
<p>Para configurar um grupo de volumes do LVM em cima da camada criptografada, o nome do dispositivo mapeado deve ser (nesse caso) algo parecido com <code>/dev/mapper/cryptraiz</code>, e não <code>/dev/sda1</code>. LVM vai dar nomes adicionais para todos os volumes lógicos criados, exemplo, <code>/dev/lvmpool/raiz</code> e <code>/dev/lvmpool/swap</code>.
</p>
<p>Para escrever dados criptografados no container você deve acessá-lo pelo nome do dispositivo mapeado. O primeiro passo tipicamente será  <a href="/title/Sistemas_de_arquivos#Criar_um_sistema_de_arquivos" class="mw-redirect" title="Sistemas de arquivos">colocar um sistema de arquivos </a>. Por exemplo:
</p>
<pre># mkfs -t ext4 /dev/mapper/cryptraiz
</pre>
<p>O dispositivo <code>/dev/mapper/cryptraiz</code> pode ser então <a href="/title/Monta" class="mw-redirect" title="Monta">montado</a> como qualquer partição.
</p>
<p>Para fechar o container LUKS, desmonte a partição e execute:
</p>
<pre># cryptsetup close cryptraiz
</pre>
<h3><span class="mw-headline" id="Criptografando_dispositivos_com_o_modo_plain">Criptografando dispositivos com o modo plain</span></h3>
<p>A criação e acesso subsequente do container no modo plain do <i>dm-crypt</i> precisam somente dos <a href="#Op%C3%A7%C3%B5es_de_encripta%C3%A7%C3%A3o_para_o_modo_plain">parâmetros</a> corretos com a ação <code>open</code>. A seguir é mostrado dois dispositivos não raiz, com o segundo criado em cima do primeiro. Obviamente, empilhar a criptografia dobra uso de recursos. Este exemplo é utilizado para mostrar o uso de cifras criptográficas.
</p>
<p>O primeiro mapeamento é criado com as opções padrão do modo plain do<i>cryptsetup</i>, como descrito em uma das tabelas acima
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup --type plain -v open /dev/sdaX plain1</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Enter passphrase:
Command successful.
</pre>
<p>No segundo dispositivo de bloco, vão ser utilizados parâmetros diferentes e um (opcional) início (offset), colocar um sistema de arquivos e montá-lo.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup --type plain --cipher=serpent-xts-plain64 --hash=sha256 --key-size=256 --offset=10  open /dev/mapper/plain1 plain2</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Enter passphrase:</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># lsblk -p</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;"> NAME
 /dev/sda
 ├─/dev/sdaX
 │ └─/dev/mapper/plain1
 │   └─/dev/mapper/plain2
 ...
</pre>
<pre># mkfs -t ext2 /dev/mapper/plain2
# mount -t ext2 /dev/mapper/plain2 /mnt
# echo "Este é o empilhado. Uma senha por pé para atirar" &gt; /mnt/stacked.txt
</pre>
<p>Feche o dispositivo para checar se o acesso funciona
</p>
<pre># cryptsetup close plain2
# cryptsetup close plain1
</pre>
<p>Primerio, tente abrir o sistema de arquivos diretamente:
</p>
<pre># cryptsetup --type plain --cipher=serpent-xts-plain64 --hash=sha256 --key-size=256 --offset=10 open /dev/sdaX plain2
</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># mount -t ext2 /dev/mapper/plain2 /mnt</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">mount: wrong fs type, bad option, bad superblock on /dev/mapper/plain2,
      missing codepage or helper program, or other error
</pre>
<p>Por que não deu certo? como o "plain2" que começa no bloco (<code>10</code>) está criptografado com a cifra do "plain1". Ele só pode ser acessado através do dispositivo mapeado empilhado. O erro é arbitário, tentar a senha ou opções erradas vai resultar no mesmo. Para o modo plain do <i>dm-crypt</i>, a ação <code>open</code> não apresentará erros.
</p>
<p>Tentando novamente mas agora na ordem correta:
</p>
<pre># cryptsetup close plain2    # dispositivo mapeado disfuncional da tentativa anterior
</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup --type plain open /dev/sdaX plain1</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Enter passphrase:
</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup --type plain --cipher=serpent-xts-plain64 --hash=sha256 --key-size=256 --offset=10 open /dev/mapper/plain1 plain2</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Enter passphrase:</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># mount /dev/mapper/plain2 /mnt &amp;&amp; cat /mnt/stacked.txt</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Este é o empilhado. Uma senha por pé para atirar
</pre>
<p><i>dm-crypt</i> irá cuidar da criptografia empilhada com alguns modos misturados também. Por exemplo o modo LUKS poderia ser empilhado no dispositivo mapeado "plain1". Seu cabeçalho deve estar criptografado dentro do "plain1".
</p>
<p>A opção <code>--shared</code> está somente disponível para o modo plain. Com esta um dispositivo pode ser segmentado em diferentes dispositivos mapeados sem sobreposição. Isto será exemplificado a seguir, usando um modo de cifra compatível com <i>loopaes</i> para o "plain2":
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup --type plain --offset 0 --size 1000 open /dev/sdaX plain1</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Enter passphrase:</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup --type plain --offset 1000 --size 1000 --shared --cipher=aes-cbc-lmk --hash=sha256 open /dev/sdaX plain2</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Enter passphrase:</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># lsblk -p</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">NAME
dev/sdaX
├─/dev/sdaX
│ ├─/dev/mapper/plain1
│ └─/dev/mapper/plain2
...
</pre>
<p>Como a árvore de dispositivos mostra, ambos residem no mesmo nível, elas não estão empilhadas e "plain2" pode ser aberto individualmente.
</p>
<h2>
<span id="A.C3.A7.C3.B5es_espec.C3.ADficas_do_cryptsetup_para_o_LUKS"></span><span class="mw-headline" id="Ações_específicas_do_cryptsetup_para_o_LUKS">Ações específicas do cryptsetup para o LUKS</span>
</h2>
<h3><span class="mw-headline" id="Gerenciamento_de_chaves">Gerenciamento de chaves</span></h3>
<p>É possível definir chaves adicionais para um container LUKS. Permitindo a criação do acesso a chaves para backup de dados seguro: Na prática conhecida como key escrow, uma chave é usada para utilização diária, outra guardada para ganhar acesso ao container caso a senha seja esquecida ou a keyfile foi perdida/danificada. Um diferente espaço de chave também pode ser usado para garantir acesso de um container para um usuário ao adicionar uma segunda chave e mais tarde removê-la.
</p>
<p>Uma vez que o container criptografado foi criado, o espaço de chave (key slot) 0 é criado (se nenhum outro foi definido manualmente). Espaços de chave adicionais são numerados de 1 a 7. Os espaços de chave utilizados podem ser vistos com:
</p>
<pre># cryptsetup luksDump /dev/&lt;dispositivo&gt;
</pre>
<p>Onde &lt;dispositivo&gt; é o volume que contém o cabeçalho do LUKS. Este e todos os seguintes comandos nesta seção funcionam em backups de cabeçalho também. 
</p>
<h4><span class="mw-headline" id="Adicionando_chaves_do_LUKS">Adicionando chaves do LUKS</span></h4>
<p>Para adicionar uma nova chave, use a ação do cryptsetup <code>luksAddKey</code>. Por segurança, sempre será solicitada uma chave existente válida ("any passphrase"), também para dispositivos já abertos, antes que a nova senha seja solicitada:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup luksAddKey /dev/&lt;dispositivo&gt; (/caminho/para/&lt;keyfile_adicional&gt;)</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Enter any passphrase:
Enter new passphrase for key slot:
Verify passphrase: 
</pre>
<p>Se <code>/caminho/para/&lt;keyfile_adicional&gt;</code> for dado, cryptsetup adicionará a &lt;keyfile_adicional&gt;. Se não, uma nova senha será solicitada duas vezes. É possível usar uma existente <i>keyfile</i> para autorizar a ação, use a opção <code>--key-file</code> ou <code>-d</code> seguida pela "antiga" &lt;keyfile&gt;:
</p>
<pre># cryptsetup luksAddKey /dev/&lt;dispositivo&gt; (/caminho/para/&lt;keyfile_adicional&gt;) -d /caminho/para/&lt;keyfile&gt;
</pre>
<p>Se é desejado usar múltiplas chaves e mudar ou remover elas, a opção <code>--key-slot</code> ou <code>-S</code> pode ser usada para especificar o slot: 
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup luksAddKey /dev/&lt;dispositivo&gt; -S 6</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Enter any passphrase: 
Enter new passphrase for key slot: 
Verify passphrase:
</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup luksDump /dev/sda8 | grep 'Slot 6'</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Key Slot 6: ENABLED
</pre>
<p>Para mostrar uma ação associada neste exemplo, foi decidido mudar a chave acima mostrada:  
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup luksChangeKey /dev/&lt;dispositivo&gt; -S 6</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Enter LUKS passphrase to be changed: 
Enter new LUKS passphrase:
</pre>
<p>Antes de removê-la.
</p>
<h4><span class="mw-headline" id="Removendo_chaves_do_LUKS">Removendo chaves do LUKS</span></h4>
<p>Existem três diferentes ações para remover chaves do cabeçalho: 
</p>
<ul>
<li>
<code>luksRemoveKey</code> é usado para remover uma chave por especificar sua senha/kefile.</li>
<li>
<code>luksKillSlot</code> pode ser usado para remover uma chave específica (usando outra chave). Isto é extremamente útil se você esqueceu uma senha, perdeu uma keyfile ou não tem acesso a ela.</li>
<li>
<code>luksErase</code> é usado para rapidamente remover <b>todas</b> as chaves ativas.</li>
</ul>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Atenção:</strong> 
<ul>
<li>Todas as ações acima podem ser usadas apagar a última chave ativa de um dispositivo criptografado!</li>
<li>O comando <code>luksErase</code> foi adicionado na versão 1.6.4 para rapidamente retirar o acesso ao dispositivo. Esta ação <b>não irá</b> solicitar senha! Isto não irá <a href="/title/Dm-crypt/Preparando_a_unidade_de_armazenamento#Apagar_o_cabe%C3%A7alho_do_LUKS" class="mw-redirect" title="Dm-crypt/Preparando a unidade de armazenamento">apagar o cabeçalho do LUKS</a>, mas todos os espaços de chave de uma vez só, então você não ganhará acesso a menos que você tenha um backup válido do cabeçalho do LUKS.</li>
</ul>
</div>
<p>É útil saber se a chave que desejamos <b>manter</b> é válida. Uma forma fácil de checar é abrir o dispositivo com a opção <code>-v</code>, o espaço que ela ocupa será mostrado:  
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup -v open /dev/&lt;dispositivo&gt; testcrypt</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Enter passphrase for /dev/&lt;dispositivo&gt;: 
Key slot 1 unlocked.
Command successful.
</pre>
<p>Agora será removida a chave adicionada na subseção anterior, usando sua senha: 
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup luksRemoveKey /dev/&lt;dispositivo&gt;</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Enter LUKS passphrase to be deleted:
</pre>
<p>Se for usada a mesma senha para dois espaços, a primeira ocorrência de espaço que tiver a senha vai ser apagado. Somente executando novamente a segunda vai ser apagada. 
</p>
<p>Alternativamente, é possível especificar o espaço de chave: 
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup luksKillSlot /dev/&lt;dispositivo&gt; 6</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Enter any remaining LUKS passphrase:
</pre>
<p>Note que em ambos os casos, nenhuma confirmação é necessária.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup luksDump /dev/sda8 | grep 'Slot 6'</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Key Slot 6: DISABLED
</pre>
<p>Reiterando o que foi falado acima: Se a mesma senha foi usada para o espaço 1 e 6, ambos devem ter sidos apagados agora.
</p>
<h3>
<span id="Backup_e_restaura.C3.A7.C3.A3o"></span><span class="mw-headline" id="Backup_e_restauração">Backup e restauração</span>
</h3>
<p>Se o cabeçalho de um container criptografado com LUKS é destruído, você não vai conseguir decriptografar seus dados. Tão problemático quanto esquecer a senha ou modificar/perder a keyfile. Danos podem acontecer por sua própria responsabilidade ao particionar novamente o disco depois ou por programas de terceiros que interpretam errado a tabela de partições. Então, ter um backup do cabeçalho e guardá-lo em outro lugar pode ser uma boa ideia.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Se uma das senhas das partições criptografadas com LUKS for revelada, você deve retirá-la em <i>todas</i> as cópias do cabeçalho, até mesmo estes que você fez o backup. De outro modo, uma cópia do cabeçalho criptografado que a usa pode ser utilizado para determinar a chave mestre que pode ser usada para abrir o container relacionado (até mesmo o seu atual, não somente o do backup). Se a chave mestre for descoberta, você vai ter que re-criptografar todo seu container. Veja o <a rel="nofollow" class="external text" href="https://gitlab.com/cryptsetup/cryptsetup/wikis/FrequentlyAskedQuestions#6-backup-and-data-recovery">PAQ do LUKS</a> para mais detalhes.</div>
<h4><span class="mw-headline" id="Backup_usando_o_cryptsetup">Backup usando o cryptsetup</span></h4>
<p>A ação <code>luksHeaderBackup</code> do cryptsetup faz o backup do cabeçalho LUKS e os espaços de chave:
</p>
<pre># cryptsetup luksHeaderBackup /dev/&lt;dispositivo&gt; --header-backup-file /mnt/&lt;backup&gt;/&lt;arquivo&gt;.img
</pre>
<p>Onde &lt;dispositivo&gt; é a partição que contém o volume LUKS.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Dica:</strong> Você pode também fazer o backup do cabeçalho no ramfs e criptografá-lo com o gpg antes de escrevê-lo em um local persistente ao executar os seguintes comandos.</div>
<pre># mkdir /root/&lt;tmp&gt;/
# mount ramfs /root/&lt;tmp&gt;/ -t ramfs
# cryptsetup luksHeaderBackup /dev/&lt;dispositivo&gt; --header-backup-file /root/&lt;tmp&gt;/&lt;arquivo&gt;.img
# gpg2 --recipient &lt;User ID&gt; --encrypt /root/&lt;tmp&gt;/&lt;arquivo&gt;.img 
# cp /root/&lt;tmp&gt;/&lt;arquivo&gt;.img.gpg /mnt/&lt;backup&gt;/
# umount /root/&lt;tmp&gt;
</pre>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Atenção:</strong> Tmpfs pode trocar para o disco se tem pouca memória disponível, então isto não é recomendado aqui.</div>
<h4>
<span id="Restaura.C3.A7.C3.A3o_usando_o_cryptsetup"></span><span class="mw-headline" id="Restauração_usando_o_cryptsetup">Restauração usando o cryptsetup</span>
</h4>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Atenção:</strong> Restaurar o cabeçalho errado ou restaurar para uma partição não criptografada pode resultar em perda de dados! A ação não pode fazer uma verificação se o cabeçalho é o <i>correto</i> para dado dispositivo.</div> 
<p>Para evitar a restauração de um cabeçalho errado, você pode fazer a verificação ao usá-lo como um cabeçalho remoto com a opção <code>--header</code>: 
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup -v --header /mnt/&lt;backup&gt;/&lt;arquivo&gt;.img open /dev/&lt;dispositivo&gt; test</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Key slot 0 unlocked.
Command successful.
</pre>
<pre># mount /dev/mapper/test /mnt/test &amp;&amp; ls /mnt/test 
# umount /mnt/test 
# cryptsetup close test 
</pre>
<p>Se não ocorreram erros, a restauração pode ser feita: 
</p>
<pre># cryptsetup luksHeaderRestore /dev/&lt;dispositivo&gt; --header-backup-file ./mnt/&lt;backup&gt;/&lt;arquivo&gt;.img
</pre>
<p>Agora todos os espaços de chave foram sobrescrevidos; somente os espaços de chave ativos do backup devem estar disponíveis.
</p>
<h4>
<span id="Backup_e_restaura.C3.A7.C3.A3o_manual"></span><span class="mw-headline" id="Backup_e_restauração_manual">Backup e restauração manual</span>
</h4>
<p>O cabeçalho sempre vai residir no início do dispositivo e um backup pode ser feito sem acesso ao <i>cryptsetup</i> também. Primeiro você têm que descobrir o payload offset da partição criptografada: 
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup luksDump /dev/&lt;dispositivo&gt; | grep "Payload offset"</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Payload offset:	4040
</pre>
<p>Depois, cheque o tamanho dos setores na unidade de armazenamento
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># fdisk -l /dev/&lt;dispositivo&gt; | grep "Sector size"</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Sector size (logical/physical): 512 bytes / 512 bytes
</pre>
<p>Agora que você sabe os valores, você pode fazer o backup do cabeçalho com o <a href="/title/Dd_(Portugu%C3%AAs)" title="Dd (Português)">dd</a>:
</p>
<pre># dd if=/dev/&lt;dispositivo&gt; of=/caminho/para/&lt;arquivo&gt;.img bs=512 count=4040
</pre>
<p>Guarde-o com segurança.
</p>
<p>Uma restauração pode ser feita usando os mesmos valores, com exceção do <code>if</code> e <code>of</code> que serão invertidos:
</p>
<pre># dd if=/caminho/para/&lt;arquivo&gt;.img of=/dev/&lt;dispositivo&gt; bs=512 count=4040
</pre>
<h3><span class="mw-headline" id="Criptografando_dispositivos_novamente">Criptografando dispositivos novamente</span></h3>
<div class="noprint archwiki-template-message">
<p><a href="/title/File:Tango-view-fullscreen.png" class="image"><img alt="Tango-view-fullscreen.png" src="../File:Tango-view-fullscreen.png" decoding="async" width="48" height="48"></a><b>This article or section needs expansion.</b><a href="/title/File:Tango-view-fullscreen.png" class="image"><img alt="Tango-view-fullscreen.png" src="../File:Tango-view-fullscreen.png" decoding="async" width="48" height="48"></a></p>
<div>
<b>Reason:</b> cryptsetup 2.2 usando LUKS2 (com um cabeçalho de 16 MiB) suporta encriptação/decriptação/re-encriptação com o dispositivo em uso.<a rel="nofollow" class="external autonumber" href="https://mirrors.edge.kernel.org/pub/linux/utils/cryptsetup/v2.2/v2.2.0-ReleaseNotes">[3]</a> (Discuss in <a rel="nofollow" class="external text" href="https://wiki.archlinux.org/title/Talk:Dm-crypt/Device_encryption">talk:dm-crypt/Device encryption</a>)</div>
</div>
<p>O pacote <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=cryptsetup">cryptsetup</a></span> possui duas opções para recriptografar o dispositivo:
</p>
<dl>
<dt>cryptsetup reencrypt</dt>
<dd>Argumento do próprio <code>cryptsetup</code>: Metódo recomendado. Atualmente funciona somente com dispositivos LUKS2. Ações podem ser executadas online. Suporta múltiplas tarefas de re-encriptação paralela. Resiliente a falhas do sistema. Veja <span class="plainlinks archwiki-template-man" title="$ man 8 cryptsetup"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/cryptsetup.8">cryptsetup(8)</a></span> para mais informação.</dd>
</dl>
<dl>
<dt>cryptsetup-reencrypt</dt>
<dd>Ferramenta legada, suporta LUKS1 e também LUKS2. Ações podem ser somente executadas em dispositivos desmontados. Somente um processo por vez. Sensível a falhas do sistema. Veja <span class="plainlinks archwiki-template-man" title="$ man 8 cryptsetup-reencrypt"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/cryptsetup-reencrypt.8">cryptsetup-reencrypt(8)</a></span> para mais informações.</dd>
</dl>
<p>Ambos podem ser usados para converter um sistema de arquivos existente para um criptografado com LUKS ou permanentemente remover a criptografia de um dispositivo (usando a opção <code>--decrypt</code>). Como o nome sugere também pode ser usado para criptografar novamente um container LUKS, apesar que isto não é possível com o cabeçalho desanexado ou outros modos de encriptação (exemplo, modo plain). É possível mudar as <a href="#Op%C3%A7%C3%B5es_de_encripta%C3%A7%C3%A3o_para_o_modo_LUKS">#Opções de encriptação para o modo LUKS</a>.
</p>
<p>Criptografar novamente um container pode ser útil para assegurar os dados depois que uma senha ou <a href="#Keyfiles">keyfile</a> foi compromisada <i>e</i> não tem certeza que alguma cópia do cabeçalho foi obtida. Por exemplo, se somente uma senha foi vista mas nenhum acesso físico/lógico ocorreu, deve ser o bastante mudar a respectiva senha/chave (<a href="#Gerenciamento_de_chaves">#Gerenciamento de chaves</a>).
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Atenção:</strong> Sempre tenha um <b>backup confiável</b> disponível e verifique duas vezes as opções especificadas antes de usar a ferramenta!</div>
<p>Exemplo, uma partição é criptografada com LUKS e então criptografada novamente.
</p>
<h4><span class="mw-headline" id="Criptografar_um_sistema_de_arquivos">Criptografar um sistema de arquivos</span></h4>
<p>Um cabeçalho do LUKS sempre é armazenado no início do dispositivo. Já que usualmente um sistema de arquivos existente usa todos os setores da partição, o primeiro passo é diminuir o espaço alocado para o cabeçalho do LUKS.
</p>
<div class="noprint archwiki-template-message">
<p><a href="/title/File:Tango-view-fullscreen.png" class="image"><img alt="Tango-view-fullscreen.png" src="../File:Tango-view-fullscreen.png" decoding="async" width="48" height="48"></a><b>This article or section needs expansion.</b><a href="/title/File:Tango-view-fullscreen.png" class="image"><img alt="Tango-view-fullscreen.png" src="../File:Tango-view-fullscreen.png" decoding="async" width="48" height="48"></a></p>
<div>
<b>Reason:</b> Páginas man do cryptsetup sugerem usar duas vezes o tamanho do cabeçalho do LUKS2. Isto implica em 32MiB e usar <code>--reduce-device-size 32M</code> (Discuss in <a rel="nofollow" class="external text" href="https://wiki.archlinux.org/title/Talk:Dm-crypt/Device_encryption">talk:dm-crypt/Device encryption</a>)</div>
</div>
<p>O cabeçalho <a href="#Op%C3%A7%C3%B5es_de_encripta%C3%A7%C3%A3o_para_o_modo_LUKS">padrão</a> do LUKS2 precisa de 16MiB. Se o sistema de arquivos atual ocupa todo o espaço disponível, diminua ele para ao menos este tamanho.
Para diminuir um sistema de arquivos <code>ext4</code> existente no <code>/dev/sdaX</code> para seu menor espaço possível:
</p>
<pre># umount /mnt
</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># e2fsck -f /dev/sdaX</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">e2fsck 1.43-WIP (18-May-2015)
Pass 1: Checking inodes, blocks, and sizes
...
/dev/sdaX: 12/166320 files (0.0% non-contiguous), 28783/665062 blocks
</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># resize2fs -M /dev/sdaX</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">resize2fs 1.43-WIP (18-May-2015)
Resizing the filesystem on /dev/sdaX to 26347 (4k) blocks.
The filesystem on /dev/sdaX is now 26347 (4k) blocks long.
</pre>
<p>A cifra padrão de encriptação vai ser utilizada, então não há necessidade de especificá-la:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup reencrypt --encrypt --reduce-device-size 16M /dev/sdaX</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">

WARNING!
========
This will overwrite data on LUKS2-temp-12345678-9012-3456-7890-123456789012.new irrevocably.

Are you sure? (Type 'yes' in capital letters): YES
Enter passphrase for LUKS2-temp-12345678-9012-3456-7890-123456789012.new:
Verify passphrase:
</pre>
<p>Depois que acabar, a encriptação vai ter sido feita para toda a partição, não somente o espaço que o sistema de arquivos foi diminuído. Por fim, extenda o sistema de arquivos original <code>ext4</code>  para ocupar o espaço disponível novamente:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup open /dev/sdaX recrypt</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Enter passphrase for /dev/sdaX:
...
</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># resize2fs /dev/mapper/recrypt</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">resize2fs 1.43-WIP (18-May-2015)
Resizing the filesystem on /dev/mapper/recrypt to 664807 (4k) blocks.
The filesystem on /dev/mapper/recrypt is now 664807 (4k) blocks long.
</pre>
<pre># mount /dev/mapper/recrypt /mnt
</pre>
<p>O sistema de arquivos agora está pronto para uso. Você pode querer adicioná-lo no seu <a href="/title/Crypttab_(Portugu%C3%AAs)" class="mw-redirect" title="Crypttab (Português)">crypttab</a>.
</p>
<h4><span class="mw-headline" id="Criptografando_novamente_um_container_LUKS">Criptografando novamente um container LUKS</span></h4>
<p>Neste exemplo um container LUKS é criptografado novamente.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Atenção:</strong> Tenha certeza de especificar as opções de encriptação corretas e <i>nunca</i> faça isso sem um <b>backup confiável</b>!</div>
<p>Para criptografar novamente o dispositivo com suas opções de encriptação atuais, você não precisa especificá-las:
</p>
<pre># cryptsetup reencrypt /dev/sdaX</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Para LUKS1 vai ser necessário usar a ferramenta legada:<pre># cryptsetup-reencrypt /dev/sdaX</pre>
</div>
<p>Chaves existentes serão mantidas quando criptografar novamente um dispositivo com uma cifra e/ou hash diferente. Outro uso é criptografar novamente dispositivos LUKS que não tem opções de encriptação modernas. A habilidade de modificar o cabeçalho pode ser limitada pelo seu tamanho. Exemplo, se um dispositivo inicialmente foi criptografado com a cifra CBC e tamanho de chave de 128 bit, o cabeçalho deste vai ter metade do tamanho mencionado acima (<code>4096</code> setores):
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup luksDump /dev/sdaX |grep -e "mode" -e "Payload" -e "MK bits"</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Cipher mode:   	cbc-essiv:sha256
Payload offset:	<b>2048</b>
MK bits:       	128
</pre>
<p>Apesar de ser possível atualizar a criptografia de tal dispositivo, isto é praticável somente se feito em dois passos. Primeiro, use as mesmas opções de encriptação, mas use a opção <code>--reduce-device-size</code> para disponibilizar espaço para um cabeçalho maior. Segundo, agora utilize as opções de encriptação que desejar. Por esta razão e o fato que um backup deve ser feito, criar um novo dispositivo criptografado para o restaurar é uma opção mais rápida.
</p>
<h2><span class="mw-headline" id="Redimensionando_os_dispositivos_criptografados">Redimensionando os dispositivos criptografados</span></h2>
<div class="noprint archwiki-template-message">
<p><a href="/title/File:Tango-view-fullscreen.png" class="image"><img alt="Tango-view-fullscreen.png" src="../File:Tango-view-fullscreen.png" decoding="async" width="48" height="48"></a><b>This article or section needs expansion.</b><a href="/title/File:Tango-view-fullscreen.png" class="image"><img alt="Tango-view-fullscreen.png" src="../File:Tango-view-fullscreen.png" decoding="async" width="48" height="48"></a></p>
<div>
<b>Reason:</b> Esta seção precisa ser reescrita para introduzir mais genericamente o redimensionamento. Talvez junto com o <a href="/title/Resizing_LVM-on-LUKS" title="Resizing LVM-on-LUKS">Resizing LVM-on-LUKS</a>. (Discuss in <a rel="nofollow" class="external text" href="https://wiki.archlinux.org/title/Talk:Dm-crypt/Device_encryption">talk:dm-crypt/Device encryption</a>)</div>
</div>
<p>Se um dispositivo de armazenamento criptografado com dm-crypt está sendo clonado (com uma ferramenta como o <a href="/title/Dd_(Portugu%C3%AAs)" title="Dd (Português)">dd</a>) para outro dispositivo maior, este último deve ser redimensionado para utilizar todo o seu espaço. 
</p>
<p>Neste exemplo, o dispositivo destino é /dev/sdX2, todo o espaço adicional da partição vai ser utilizado:
</p>
<pre># cryptsetup luksOpen /dev/sdX2 sdX2
# cryptsetup resize sdX2
</pre>
<p>O sistema de arquivos deste deve ser redimensionado também.
</p>
<h3><span class="mw-headline" id="Sistema_de_arquivos_de_loopback">Sistema de arquivos de loopback</span></h3>
<p>Assuma que um sistema de arquivos de loopback criptografado está no arquivo <code>grande_segredo</code>, ligado ao <code>/dev/loop0</code>, mapeado como <code>segredo</code> e montado em <code>/mnt/segredo</code>, como no exemplo presente em <a href="/title/Dm-crypt/Criptografando_um_sistema_de_arquivos_n%C3%A3o_raiz#Dispositivo_de_loop" class="mw-redirect" title="Dm-crypt/Criptografando um sistema de arquivos não raiz">dm-crypt/Criptografando um sistema de arquivos não raiz#Dispositivo de loop</a>.
</p>
<p>Se o container está mapeado e/ou montado, o desmonte e/ou feche:
</p>
<pre># umount /mnt/segredo
# cryptsetup close segredo
# losetup -d /dev/loop0
</pre>
<p>Depois, expanda o container com o tamanho do arquivo que você quer adicionar. Neste exemplo, o arquivo será expandido com 1M * 1024, que é 1G.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Atenção:</strong> Tenha certeza de usar <b>dois</b> <code>&gt;</code>,  ao invês de um, ou você irá sobrescrever o arquivo e não adicionar no final dele. Fazer um backup antes desse passo é fortemente recomendado.</div>
<pre># dd if=/dev/urandom bs=1M count=1024 | cat - &gt;&gt; grande_segredo
</pre>
<p>Agora mapeie o container para o dispositivo de loop:
</p>
<pre># losetup /dev/loop0 grande_segredo
# cryptsetup open /dev/loop0 segredo
</pre>
<p>Depois disso, redimensione a parte criptografada do container para o novo tamanho máximo do arquivo container:
</p>
<pre># cryptsetup resize segredo
</pre>
<p>Finalmente, cheque o sistema de arquivos e, se está ok, o redimensione (exemplo para ext2/3/4):
</p>
<pre># e2fsck -f /dev/mapper/segredo
# resize2fs /dev/mapper/segredo
</pre>
<p>Você pode montar o container novamente:
</p>
<pre># mount /dev/mapper/segredo /mnt/segredo
</pre>
<h2><span class="mw-headline" id="Keyfiles">Keyfiles</span></h2>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Esta seção descreve o uso de keyfile em texto puro. Se desejar criptografar a keyfile para conseguir autentificação de dois fatores veja <a href="/title/Dm-crypt/Especificidades#Usando_keyfiles_criptografadas_com_GPG,_LUKS_ou_OpenSSL" class="mw-redirect" title="Dm-crypt/Especificidades">Usando keyfiles criptografadas com GPG, LUKS ou OpenSSL</a> para detalhes, mas ainda leia esta seção.</div>
<p><b>O que é uma keyfile?</b>
</p>
<p>Também conhecida como arquivo chave ou arquivo-chave, uma keyfile é um arquivo cujo dados são usados como senha para abrir um volume criptografado.
Isto significa que se tal arquivo é perdido ou modificado, abrir o volume pode não ser mais possível.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Dica:</strong> Adicione uma senha além da keyfile para evitar a situação citada acima.</div>
<p><b>Porque usar uma keyfile?</b>
</p>
<p>Existem muitos tipos de keyfiles. Cada tipo possui suas vantagens e desvantagens, resumidos abaixo:
</p>
<h3><span class="mw-headline" id="Tipos_de_keyfiles">Tipos de keyfiles</span></h3>
<h4><span class="mw-headline" id="Senha">Senha</span></h4>
<p>Contém a senha. A vantagem deste tipo é que se o arquivo perde os dados, o proprietário do volume criptografado pode se lembrar do conteudo. No entanto a desvantagem é que isto não trás nenhuma segurança extra comparado com digitar a senha na inicialização.
</p>
<p>Exemplo: <code>1234</code>
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> A keyfile que contém a senha não deve ter quebra de linha (newline) dentro dela. Uma opção é criá-la usando:
<pre># echo -n 'sua_senha' &gt; /caminho/para/&lt;keyfile&gt;
# chown root:root /caminho/para/&lt;keyfile&gt;; chmod 400 /caminho/para/&lt;keyfile&gt;
</pre>
<p>Se o arquivo contém caracteres especiais como barra invertida, é preferível simplesmente editar a keyfile diretamente entrando ou colando a senha e então remover a quebra de linha com um script perl de uma linha: 
</p>
<pre># perl -pi -e 'chomp if eof' /caminho/para/&lt;keyfile&gt;
</pre>
</div>
<h4>
<span id="Texto_rand.C3.B4mico"></span><span class="mw-headline" id="Texto_randômico">Texto randômico</span>
</h4>
<p>Este tipo de keyfile contém um bloco de caracteres randômicos. É muito mais resistente ao ataques de dicionários que uma simples senha. Possui também como vantagem o tamanho dos dados utilizados. Desde que este tipo não é para ser memorizado por uma pessoa, é possível criar um arquivo com milhares de caracteres e colocá-lo como uma chave. A desvantagem é que se o arquivo é perdido ou modificado, não deve ser possível recuperar o acesso ao volume criptografado sem outra chave.
</p>
<p>Exemplo: <code>fjqweifj830149-57 819y4my1-38t1934yt8-91m 34co3;t8y;9p3y-</code>
</p>
<h4>
<span id="Bin.C3.A1rio"></span><span class="mw-headline" id="Binário">Binário</span>
</h4>
<p>É um arquivo binário que foi definido como keyfile. Quando identificar candidatos para uma keyfile, é recomendado que escolha fotos relativamente estáticas como fotos, músicas, vídeos. A vantagem, esses arquivos tem outras funções que dificultam a sua identificação como keyfile. Ao invês de ter um arquivo de texto com uma grande quantidade de texto randômico, a keyfile vai ser considerada como um arquivo de mídia normal. A desvantagem, se o arquivo for perdido ou mudado, provavelmente não será mais possível acessar o volume criptografado sem outra chave. Adicionalmente, existe teoricamente uma perda de aleatoriedade se comparado com um arquivo de texto randômico. Isto é devido ao fato que imagens, vídeos e músicas tem uma relação intríseca entre bits de dados vizinhos que não existe num texto randômico. No entanto isto é controverso e nunca foi publicamente explorado.
</p>
<p>Exemplo: imagens, texto, video ...
</p>
<h3>
<span id="Criando_uma_keyfile_com_caracteres_rand.C3.B4micos"></span><span class="mw-headline" id="Criando_uma_keyfile_com_caracteres_randômicos">Criando uma keyfile com caracteres randômicos</span>
</h3>
<h4><span class="mw-headline" id="Guardando_a_keyfile_em_um_sistema_de_arquivos_filesystem">Guardando a keyfile em um sistema de arquivos filesystem</span></h4>
<p>Uma keyfile pode ser de conteudo e tamanho arbitrários. 
</p>
<p>É utilizado o <code>dd</code> para gerar uma keyfile de 2048 bytes randômicos, os colocando no arquivo <code>/etc/minha_keyfile</code>:
</p>
<pre># dd bs=512 count=4 if=/dev/random of=/etc/minha_keyfile iflag=fullblock
</pre>
<p>Se você planeja guardar a keyile em um dispositivo externo, você pode simplesmente mudar a saída para o diretório correspondente:
</p>
<pre># dd bs=512 count=4 if=/dev/random of=/media/pendrive/minha_keyfile iflag=fullblock
</pre>
<p>Para negar o acesso de qualquer usuário exceto o <code>root</code>:
</p>
<pre># chmod 600 /etc/minha_keyfile
</pre>
<h5>
<span id="Sobrescrevendo_com_seguran.C3.A7a_as_keyfiles_guardadas"></span><span class="mw-headline" id="Sobrescrevendo_com_segurança_as_keyfiles_guardadas">Sobrescrevendo com segurança as keyfiles guardadas</span>
</h5>
<p>Se você guardar sua keyfile temporária em uma unidade de armazenamento, e quer deletá-la, use algo parecido com isso
</p>
<pre># shred --remove --zero minha_keyfile
</pre>
<p>para sobrescrever com segurança. Para sistemas de arquivos antigos como FAT ou ext2 isto deve bastar, enquanto que no caso de sistemas de arquivos com journaling, hardware de memória flash e outros casos é recomendado a <a href="/title/Securely_wipe_disk" title="Securely wipe disk">apagar todo o disco</a>.
</p>
<h4><span class="mw-headline" id="Guardando_a_keyfile_no_ramfs">Guardando a keyfile no ramfs</span></h4>
<p>Alternativamente você pode montar uma ramfs para guardar a keyfile temporariamente:
</p>
<pre># mkdir /root/minha_ramfs
# mount ramfs /root/minha_ramfs/ -t ramfs
# cd /root/minha_ramfs
</pre>
<p>A vantagem é que ela reside na RAM e não em um disco fisíco, então não pode ser recuperada depois de desmontar o ramfs. Depois de copiar a keyfile para outro seguro e persistente sistema de arquivos, desmonte o ramfs com
</p>
<pre># umount /root/minha_ramfs
</pre>
<h3>
<span id="Configurando_o_LUKS_para_utilizar_uma.2Foutra_keyfile"></span><span class="mw-headline" id="Configurando_o_LUKS_para_utilizar_uma/outra_keyfile">Configurando o LUKS para utilizar uma/outra keyfile</span>
</h3>
<p>Adicione um espaço de chave para a keyfile no cabeçalho do LUKS:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup luksAddKey /dev/sda2 /etc/minha_keyfile</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Enter any LUKS passphrase:
key slot 0 unlocked.
Command successful.
</pre>
<h3>
<span id="Manualmente_abrindo_uma_parti.C3.A7.C3.A3o_com_uma_keyfile"></span><span class="mw-headline" id="Manualmente_abrindo_uma_partição_com_uma_keyfile">Manualmente abrindo uma partição com uma keyfile</span>
</h3>
<p>Use a opção <code>--key-file</code> quando for abrir um dispositivo LUKS:
</p>
<pre># cryptsetup open /dev/sda2 <i>dm_nome</i> --key-file /etc/minha_keyfile
</pre>
<h4><span class="mw-headline" id="Com_uma_keyfile_em_um_dispositivo_externo">Com uma keyfile em um dispositivo externo</span></h4>
<h5><span class="mw-headline" id="Configurando_o_mkinitcpio">Configurando o mkinitcpio</span></h5>
<p>Você pode adicionar um módulo em sua <code>/etc/mkinitcpio.conf</code> para o sistema de arquivos da sua unidade de armazenamento, no exemplo abaixo o módulo (<code>vfat</code>):
</p>
<pre>MODULES=(vfat)
</pre>
<p>Neste exemplo é assumido que você vai usar um pendrive formatado em FAT (módulo <code>vfat</code>). Mude este módulo para outro caso for usar outro sistema de arquivos (exemplo, <code>ext2</code>). Se receber uma mensagem reclamando de "bad superblock" e "bad codepage" na inicialização, é necessário carregar uma codepage extra. Você pode precisar do módulo <code>nls_iso8859-1</code> para a codepage <code>iso8859-1</code>.
</p>
<p>Se você usa um teclado não-US, pode ser útil carregá-lo antes que seja solicitada a senha para abrir a partição raiz na inicialização. Para isto, você precisa do hook <code>keyboard</code> antes do <code>encrypt</code>.
</p>
<p><a href="/title/Gere_novamente_o_initramfs" class="mw-redirect" title="Gere novamente o initramfs">Gere novamente o initramfs</a>.
</p>
<h5>
<span id="Configurando_os_par.C3.A2metros_do_kernel"></span><span class="mw-headline" id="Configurando_os_parâmetros_do_kernel">Configurando os parâmetros do kernel</span>
</h5>
<div class="noprint archwiki-template-message">
<p><a href="/title/File:Merge-arrows-2.png" class="image"><img alt="Merge-arrows-2.png" src="../File:Merge-arrows-2.png" decoding="async" width="48" height="48"></a><b>This article or section is a candidate for merging with <a href="/title/Dm-crypt/System_configuration#cryptkey" title="Dm-crypt/System configuration">dm-crypt/System configuration#cryptkey</a>.</b><a href="/title/File:Merge-arrows-2.png" class="image"><img alt="Merge-arrows-2.png" src="../File:Merge-arrows-2.png" decoding="async" width="48" height="48"></a></p>
<div>
<b>Notes:</b> Manter todos os parâmetros do hook <code>encrypt</code> em um lugar. (Discuss in <a rel="nofollow" class="external text" href="https://wiki.archlinux.org/title/Talk:Dm-crypt/Device_encryption">Talk:Dm-crypt/Device encryption</a>)</div>
</div>
<p>Adicione as seguintes opções nos <a href="/title/Par%C3%A2metros_do_kernel" class="mw-redirect" title="Parâmetros do kernel">parâmetros do kernel</a> se está usando o hook <code>encrypt</code>. Se está usando o <code>sd-encrypt</code> veja <a href="/title/Dm-crypt/Configura%C3%A7%C3%A3o_do_sistema#Usando_o_hook_sd-encrypt" class="mw-redirect" title="Dm-crypt/Configuração do sistema">dm-crypt/Configuração do sistema#Usando o hook sd-encrypt</a>.
</p>
<pre>cryptdevice=/dev/<i>&lt;partição1&gt;</i>:raiz cryptkey=/dev/<i>&lt;partição2&gt;</i>:&lt;tipo_do_sistema_de_arquivos&gt;:&lt;caminho&gt;
</pre>
<p>Por exemplo:
</p>
<pre>cryptdevice=/dev/sda3:raiz cryptkey=/dev/sdb1:vfat:/chaves/chavesecreta
</pre>
<p>Escolher um arquivo com nome normal dá um pouco de 'segurança por obscurantismo', mas esteja ciente que a linha de comando do kernel é gravada no log do kernel (<i>dmesg</i>). A keyfile não pode ser um arquivo escondido, isto significa que o nome do arquivo não deve começar com um ponto, ou o hook <code>encrypt</code> não vai conseguir encontrar o arquivo durante o processo de inicialização. Alternativamente, você pode essconder a keyfile entre partições e usar:
</p>
<pre>cryptkey=/dev/sdb1:início:tamanho
</pre>
<p>Como vantagem, é mais difícil acidentalmente deletar a chave.
</p>
<p>Não existe garantia que nomes de dispositivos como <code>/dev/sdb1</code> irão permanecer os mesmos entre inicializações. É mais confiável acessar o dispositivo com a <a href="/title/Nomea%C3%A7%C3%A3o_persistente_de_dispositivo_de_bloco" class="mw-redirect" title="Nomeação persistente de dispositivo de bloco">nomeação persistente de dispositivo de bloco</a> do udev. Use isto para ter certeza que o hook <code>encrypt</code> vai encontrar sua keyfile quando lê-la de um dispositivo externo.
</p>
<h4><span class="mw-headline" id="Com_uma_keyfile_no_initramfs">Com uma keyfile no initramfs</span></h4>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Atenção:</strong> Use uma keyfile dentro do initramfs <b>somente</b> se você proteger a keyfile suficientemente por:
<ul>
<li>Usar alguma forma de autentificação prévia no processo de inicialização. De outro modo, o dispositivo vai ser aberto automaticamente, acabando com a proposta de criptografar o dispositivo de bloco.</li>
<li>
<code>/boot</code> é criptografado. De outro modo, a raiz de outra instalação (incluindo o <a href="/title/Guia_de_instala%C3%A7%C3%A3o#Inicializar_o_ambiente_live" class="mw-redirect" title="Guia de instalação">ambiente live</a>) pode extrair sua chave do initramfs, e decriptografar o dispositivo sem qualquer meio de autentificação.</li>
</ul>
</div>
<p>Este método permite o uso de um nome especial para a keyfile que vai ser colocada no <a href="/title/Initramfs" class="mw-redirect" title="Initramfs">initramfs</a> e lida pelo <a href="/title/Mkinitcpio_(Portugu%C3%AAs)#HOOKS" title="Mkinitcpio (Português)">hook</a> <code>encrypt</code> para abrir o sistema de arquivos raiz (<code>cryptdevice</code>) automaticamente. Pode ser útil quando deseja que o <a href="/title/GRUB_(Portugu%C3%AAs)#/boot_criptografado" title="GRUB (Português)">/boot criptografado</a>, evitando entrar duas senhas durante a inicialização.
</p>
<p>O hook <code>encrypt</code> permite que o usuário especificar uma keyfile com o parâmetro do kernel <code>cryptkey</code>: no caso do initramfs, a sintaxe é <code>rootfs:<i>caminho</i></code>. Veja <a href="/title/Dm-crypt/Configura%C3%A7%C3%A3o_do_sistema#cryptkey" class="mw-redirect" title="Dm-crypt/Configuração do sistema">dm-crypt/Configuração do sistema#cryptkey</a>. Apesar que, este parâmetro do kernel se não definido vai usar por padrão <code>/crypto_keyfile.bin</code>, e se o initramfs contém uma chave válida com este nome, o container será aberto sem a necessidade de definir o parâmetro <code>cryptkey</code>.
</p>
<p>Se está usando o <code>sd-encrypt</code>, especifique a localização da keyfile com o parâmetro do kernel <code>rd.luks.key</code>. Veja <a href="/title/Dm-crypt/Configura%C3%A7%C3%A3o_do_sistema#rd.luks.key" class="mw-redirect" title="Dm-crypt/Configuração do sistema">dm-crypt/Configuração do sistema#rd.luks.key</a>.
</p>
<p><a href="#Criando_uma_keyfile_com_caracteres_rand%C3%B4micos">Gere uma keyfile</a>, defina permissões apropriadas e <a href="#Adicionando_chaves_do_LUKS">a adicione como uma chave do LUKS</a>:
</p>
<pre># dd bs=512 count=4 if=/dev/random of=/crypto_keyfile.bin iflag=fullblock
# chmod 600 /crypto_keyfile.bin
# chmod 600 /boot/initramfs-linux*
# cryptsetup luksAddKey /dev/sdX# /crypto_keyfile.bin
</pre>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Atenção:</strong> Quando as permissões do initramfs estão definidas para 644 (por padrão), então todos os usuários poderão conseguir o conteúdo da keyfile. Tenha certeza de que as permissões ainda são 600 depois de atualizar ou instalar um kernel.</div>
<p>Inclua a chave no <a href="/title/Mkinitcpio_(Portugu%C3%AAs)#BINARIES_e_FILES" title="Mkinitcpio (Português)">arranjo de arquivos do mkinitcpio</a>:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/mkinitcpio.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">FILES=(/crypto_keyfile.bin)</pre>
<p>Finalmente <a href="/title/Gere_novamente_o_initramfs" class="mw-redirect" title="Gere novamente o initramfs">gere novamente o initramfs</a>.
</p>
<p>Na próxima inicialização você deve precisar somente entrar com a senha do container criptografado uma vez.
</p>
<p>(<a rel="nofollow" class="external text" href="https://www.pavelkogan.com/2014/05/23/luks-full-disk-encryption/#bonus-login-once">fonte</a>)
</p>
</div>
</div>
<div id="catlinks" class="catlinks" data-mw="interface">
<div id="mw-normal-catlinks" class="mw-normal-catlinks">
<a href="/title/Special:Categories" title="Special:Categories">Category</a>: <ul><li><a href="/title/Category:Data-at-rest_encryption_(Portugu%C3%AAs)" title="Category:Data-at-rest encryption (Português)">Data-at-rest encryption (Português)</a></li></ul>
</div>
<div id="mw-hidden-catlinks" class="mw-hidden-catlinks mw-hidden-cats-hidden">Hidden categories: <ul>
<li><a href="/title/Category:Pages_or_sections_flagged_with_Template:Expansion" title="Category:Pages or sections flagged with Template:Expansion">Pages or sections flagged with Template:Expansion</a></li>
<li><a href="/title/Category:Pages_or_sections_flagged_with_Template:Merge" title="Category:Pages or sections flagged with Template:Merge">Pages or sections flagged with Template:Merge</a></li>
</ul>
</div>
</div>
	</div>
</div>

<footer id="footer" class="mw-footer" role="contentinfo" style="margin: 0">
	<ul id="footer-info">
		<li>Retrieved from "<a dir="ltr" href="https://wiki.archlinux.org/index.php?title=Dm-crypt_(Portugu%C3%AAs)/Device_encryption_(Portugu%C3%AAs)&amp;oldid=668667">https://wiki.archlinux.org/index.php?title=Dm-crypt_(Português)/Device_encryption_(Português)&amp;oldid=668667</a>"</li>
		<li id="footer-info-lastmod"> This page was last edited on 8 May 2021, at 10:36.</li>
		<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3 or later</a> unless otherwise noted.</li>
	<br>
</ul>
	<ul id="footer-places">
		<li id="footer-places-privacy"><a href="/title/ArchWiki:Privacy_policy" title="ArchWiki:Privacy policy">Privacy policy</a></li>
		<li id="footer-places-about"><a href="/title/ArchWiki:About" title="ArchWiki:About">About ArchWiki</a></li>
		<li id="footer-places-disclaimer"><a href="/title/ArchWiki:General_disclaimer" title="ArchWiki:General disclaimer">Disclaimers</a></li>
	</ul>
	<ul id="footer-icons" class="noprint">
		<li id="footer-copyrightico">
	</ul>
	<div style="clear: both;"></div>
</footer>



</body>
</html>
