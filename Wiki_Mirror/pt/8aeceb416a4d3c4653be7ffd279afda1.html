<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<title>dm-crypt (Português)/Specialties (Português) - ArchWiki</title>
<link rel="stylesheet" href="../ArchWikiOffline.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<meta name="generator" content="MediaWiki 1.35.0">
<meta name="referrer" content="no-referrer-when-downgrade">
<meta name="robots" content="noindex,follow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="/opensearch_desc.php" title="ArchWiki (en)">
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.archlinux.org/api.php?action=rsd">
<link rel="license" href="http://www.gnu.org/copyleft/fdl.html">
<link rel="alternate" type="application/atom+xml" title="ArchWiki Atom feed" href="/index.php?title=Special:RecentChanges&amp;feed=atom">
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Dm-crypt_Português_Specialties_Português rootpage-Dm-crypt_Português skin-vector action-view skin-vector-legacy">
<div id="content" class="mw-body" role="main" style="margin: 0">
	<a id="top"></a>
	<div id="siteNotice" class="mw-body-content"></div>
	<div class="mw-indicators mw-body-content">
	</div>
	<h1 id="firstHeading" class="firstHeading" lang="en">dm-crypt (Português)/Specialties (Português)</h1>
	<div id="bodyContent" class="mw-body-content">
		<div id="siteSub" class="noprint">From ArchWiki</div>
		<div id="contentSub"><span class="subpages">&lt; <a href="../pt/Dm-crypt.html" title="Dm-crypt (Português)">Dm-crypt (Português)</a></span></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="#searchInput">Jump to search</a>
		<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<div class="warningbox">The printable version is no longer supported and may have rendering errors. Please update your browser bookmarks and please use the default browser print function instead.</div>
<div class="mw-parser-output">
<p><span></span>
</p>
<div class="noprint archwiki-template-message">
<p><a href="../File:Tango-preferences-desktop-locale.png" class="image"><img alt="Tango-preferences-desktop-locale.png" src="../File:Tango-preferences-desktop-locale.png" decoding="async" width="48" height="48"></a><b>Este artigo ou esta seção precisa de <a href="../pt/ArchWiki:Contributing.html#Traduzindo" class="mw-redirect" title="ArchWiki:Contribuindo">tradução</a>.</b><a href="../File:Tango-preferences-desktop-locale.png" class="image"><img alt="Tango-preferences-desktop-locale.png" src="../File:Tango-preferences-desktop-locale.png" decoding="async" width="48" height="48"></a></p>
<div>
<b>Notas:</b> Esta página está sendo traduzida. (Discuta em <a rel="nofollow" class="external text" href="https://wiki.archlinux.org/index.php/Talk:Dm-crypt_(Portugu%C3%AAs)/Specialties_(Portugu%C3%AAs)">Talk:Dm-crypt (Português)/Specialties (Português)#</a>)</div>
</div>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading">
<input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none"><div class="toctitle" lang="en" dir="ltr">
<h2 id="mw-toc-heading">Contents</h2>
<span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span>
</div>
<ul>
<li class="toclevel-1 tocsection-1">
<a href="#Protegendo_a_parti%C3%A7%C3%A3o_de_boot_n%C3%A3o_criptografada"><span class="tocnumber">1</span> <span class="toctext">Protegendo a partição de boot não criptografada</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Inicializando_de_um_dispositivo_remov%C3%ADvel"><span class="tocnumber">1.1</span> <span class="toctext">Inicializando de um dispositivo removível</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#chkboot"><span class="tocnumber">1.2</span> <span class="toctext">chkboot</span></a></li>
<li class="toclevel-2 tocsection-4">
<a href="#mkinitcpio-chkcryptoboot"><span class="tocnumber">1.3</span> <span class="toctext">mkinitcpio-chkcryptoboot</span></a>
<ul>
<li class="toclevel-3 tocsection-5"><a href="#Instala%C3%A7%C3%A3o"><span class="tocnumber">1.3.1</span> <span class="toctext">Instalação</span></a></li>
<li class="toclevel-3 tocsection-6"><a href="#Vis%C3%A3o_geral_t%C3%A9cnica"><span class="tocnumber">1.3.2</span> <span class="toctext">Visão geral técnica</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-7"><a href="#AIDE"><span class="tocnumber">1.4</span> <span class="toctext">AIDE</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#STARK"><span class="tocnumber">1.5</span> <span class="toctext">STARK</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-9"><a href="#Usando_keyfiles_criptografadas_com_GPG,_LUKS_ou_OpenSSL"><span class="tocnumber">2</span> <span class="toctext">Usando keyfiles criptografadas com GPG, LUKS ou OpenSSL</span></a></li>
<li class="toclevel-1 tocsection-10">
<a href="#Abrir_remotamente_a_parti%C3%A7%C3%A3o_raiz_(ou_outra)"><span class="tocnumber">3</span> <span class="toctext">Abrir remotamente a partição raiz (ou outra)</span></a>
<ul>
<li class="toclevel-2 tocsection-11"><a href="#Abrir_remotamente_(hooks:_systemd,_systemd-tool)"><span class="tocnumber">3.1</span> <span class="toctext">Abrir remotamente (hooks: systemd, systemd-tool)</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#Abrir_remotamente_(hooks:_netconf,_dropbear,_tinyssh,_ppp)"><span class="tocnumber">3.2</span> <span class="toctext">Abrir remotamente (hooks: netconf, dropbear, tinyssh, ppp)</span></a></li>
<li class="toclevel-2 tocsection-13">
<a href="#Abrir_remotamente_pelo_wifi"><span class="tocnumber">3.3</span> <span class="toctext">Abrir remotamente pelo wifi</span></a>
<ul>
<li class="toclevel-3 tocsection-14"><a href="#Hook_predefinido"><span class="tocnumber">3.3.1</span> <span class="toctext">Hook predefinido</span></a></li>
<li class="toclevel-3 tocsection-15"><a href="#Fa%C3%A7a_o_seu_pr%C3%B3prio"><span class="tocnumber">3.3.2</span> <span class="toctext">Faça o seu próprio</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-16"><a href="#Suporte_a_discard/TRIM_para_unidades_de_estado_s%C3%B3lido_(SSD)"><span class="tocnumber">4</span> <span class="toctext">Suporte a discard/TRIM para unidades de estado sólido (SSD)</span></a></li>
<li class="toclevel-1 tocsection-17">
<a href="#O_hook_encrypt_e_m%C3%BAltiplos_discos"><span class="tocnumber">5</span> <span class="toctext">O hook encrypt e múltiplos discos</span></a>
<ul>
<li class="toclevel-2 tocsection-18">
<a href="#Expandindo_LVM_em_m%C3%BAltiplos_discos"><span class="tocnumber">5.1</span> <span class="toctext">Expandindo LVM em múltiplos discos</span></a>
<ul>
<li class="toclevel-3 tocsection-19"><a href="#Adicionando_uma_nova_unidade_de_armazenamento"><span class="tocnumber">5.1.1</span> <span class="toctext">Adicionando uma nova unidade de armazenamento</span></a></li>
<li class="toclevel-3 tocsection-20"><a href="#Extendendo_o_volume_l%C3%B3gico"><span class="tocnumber">5.1.2</span> <span class="toctext">Extendendo o volume lógico</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-21">
<a href="#Modificando_o_hook_encrypt_para_m%C3%BAltiplas_parti%C3%A7%C3%B5es"><span class="tocnumber">5.2</span> <span class="toctext">Modificando o hook encrypt para múltiplas partições</span></a>
<ul>
<li class="toclevel-3 tocsection-22"><a href="#sistema_de_arquivos_principal_expandido_para_m%C3%BAltiplas_parti%C3%A7%C3%B5es"><span class="tocnumber">5.2.1</span> <span class="toctext">sistema de arquivos principal expandido para múltiplas partições</span></a></li>
<li class="toclevel-3 tocsection-23"><a href="#M%C3%BAltiplas_parti%C3%A7%C3%B5es_n%C3%A3o_raiz"><span class="tocnumber">5.2.2</span> <span class="toctext">Múltiplas partições não raiz</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-24">
<a href="#Sistema_criptografado_usando_um_cabe%C3%A7alho_LUKS_desanexado"><span class="tocnumber">6</span> <span class="toctext">Sistema criptografado usando um cabeçalho LUKS desanexado</span></a>
<ul>
<li class="toclevel-2 tocsection-25"><a href="#Usando_o_hook_do_systemd"><span class="tocnumber">6.1</span> <span class="toctext">Usando o hook do systemd</span></a></li>
<li class="toclevel-2 tocsection-26"><a href="#Modificando_o_hook_encrypt"><span class="tocnumber">6.2</span> <span class="toctext">Modificando o hook encrypt</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-27">
<a href="#Encrypted_/boot_and_a_detached_LUKS_header_on_USB"><span class="tocnumber">7</span> <span class="toctext">Encrypted /boot and a detached LUKS header on USB</span></a>
<ul>
<li class="toclevel-2 tocsection-28">
<a href="#Preparing_the_disk_devices"><span class="tocnumber">7.1</span> <span class="toctext">Preparing the disk devices</span></a>
<ul>
<li class="toclevel-3 tocsection-29"><a href="#Preparing_the_USB_key"><span class="tocnumber">7.1.1</span> <span class="toctext">Preparing the USB key</span></a></li>
<li class="toclevel-3 tocsection-30"><a href="#The_main_drive"><span class="tocnumber">7.1.2</span> <span class="toctext">The main drive</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-31">
<a href="#Installation_procedure_and_custom_encrypt_hook"><span class="tocnumber">7.2</span> <span class="toctext">Installation procedure and custom encrypt hook</span></a>
<ul>
<li class="toclevel-3 tocsection-32"><a href="#Boot_Loader"><span class="tocnumber">7.2.1</span> <span class="toctext">Boot Loader</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-33"><a href="#Changing_the_LUKS_keyfile"><span class="tocnumber">7.3</span> <span class="toctext">Changing the LUKS keyfile</span></a></li>
</ul>
</li>
</ul>
</div>

<h2>
<span id="Protegendo_a_parti.C3.A7.C3.A3o_de_boot_n.C3.A3o_criptografada"></span><span class="mw-headline" id="Protegendo_a_partição_de_boot_não_criptografada">Protegendo a partição de boot não criptografada</span>
</h2>
<p>A partição <code>/boot</code> e o <a href="../pt/Partitioning.html#Master_Boot_Record" class="mw-redirect" title="Particionamento">Master Boot Record</a> são duas áreas do disco que não são criptografadas até mesmo com a <a href="../pt/bd347841f13524ba6da3458e094be74d.html" class="mw-redirect" title="Dm-crypt/Criptografando todo um sistema">raiz criptografada</a>. Estes não podem ser usualmente criptografados porquê o <a href="../pt/Arch_boot_process.html#Gerenciador_de_boot" class="mw-redirect" title="Gerenciador de boot">gerenciador de boot</a> e BIOS (respectivamente) não são capazes de abrir o container do dm-crypt para continuar o processo de inicialização. Uma exceção é o <a href="../pt/GRUB.html" title="GRUB (Português)">GRUB</a>, que tem a funcionalidade de abrir a partição <code>/boot</code> criptografada - veja <a href="../pt/bd347841f13524ba6da3458e094be74d.html#Parti%C3%A7%C3%A3o_de_boot_criptografada_(GRUB)" class="mw-redirect" title="Dm-crypt/Criptografando todo um sistema">dm-crypt/Criptografando todo um sistema#Partição de boot criptografada (GRUB)</a>. 
</p>
<p>Esta seção descreve passos que podem ser feitos para fazer o processo de inicialização mais seguro.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Atenção:</strong> Note que proteger a partição <code>/boot</code> e MBR pode mitigar numerosos ataques que ocorrem no processo de inicialização, mas sistemas configurados desta maneira ainda podem estar vuneráveis a adulteração da BIOS/UEFI/firmware, keyloggers de hardware, ataques cold boot, e outras ameaças que estão fora do escopo deste artigo. Para uma visão geral da confiabilidade do sistema e como estes são relacionados a encriptação total de sistema, veja <a rel="nofollow" class="external autonumber" href="https://www.youtube.com/watch?v=pKeiKYA03eE">[1]</a>.</div>
<h3>
<span id="Inicializando_de_um_dispositivo_remov.C3.ADvel"></span><span class="mw-headline" id="Inicializando_de_um_dispositivo_removível">Inicializando de um dispositivo removível</span>
</h3>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Atenção:</strong> O gerador do systemd versão 230 para o cryptsetup emite <code>RequiresMountsFor</code> para a keyfile. Quando o sistema de arquivos que possui este arquivo é desmontado, o serviço do cryptsetup também para. Este comportamento está correto porquê o sistema de arquivos e a chave criptografada são necessários somente quando o container criptografado é inicialmente aberto. Veja a <a rel="nofollow" class="external text" href="https://github.com/systemd/systemd/issues/3816">systemd issue 3816</a>.</div>
<p>Usar um dispositivo separado para inicializar um sistema é um procedimento bastante simples, e oferece uma significante melhora na segunraça contra alguns tipos de ataques. Duas partes vulneráveis de um sistema com <a href="../pt/bd347841f13524ba6da3458e094be74d.html" class="mw-redirect" title="Dm-crypt/Criptografando todo um sistema">raiz criptografada</a> são:
</p>
<ul>
<li>o <a href="../pt/Partitioning.html#Master_Boot_Record" class="mw-redirect" title="Particionamento">Master Boot Record</a>, e</li>
<li>a partição <code>/boot</code>.</li>
</ul>
<p>Estas devem ser guardadas em forma não criptografada para o sistema inicializar. Para protegê-las de adulteração, é recomendado usar uma unidade de armazenamento removível, como um pendrive, e inicializar por meio desta ao invês do disco interno. Enquanto você cuidar e guardar consigo a unidade de armazenamento removível, vai ter certeza que esta não foi adulterada, fazendo a autentificação muito mais segura quando abrir seu sistema.
</p>
<p>É assumido que você já configurou seu sistema e tem um partição dedicada montada em <code>/boot</code>. Se não, siga os passos em <a href="../pt/5e279fa7d75b32c0232ab38e4294ae71.html#Gerenciador_de_boot" class="mw-redirect" title="Dm-crypt/Configuração do sistema">dm-crypt/Configuração do sistema#Gerenciador de boot</a>, substituindo a sua unidade de armazenamento por uma removível.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Você deve ter certeza que seu sistema suporta a inicialização por uma unidade de armazenamento removível, seja esta um pendrive, HD externo, cartão SD, ou qualquer outra coisa.</div>
<p>Prepare a unidade de armazenamento removível (<code>/dev/sdx</code>).
</p>
<pre># gdisk /dev/sdx # formate se necessário. Pode usar também cgdisk, fdisk, cfdisk, gparted...
# mkfs.ext2 /dev/sdx1
# mount /dev/sdx1 /mnt
</pre>
<p>Copie o que tiver no <code>/boot</code> para o novo.
</p>
<pre># cp -ai /boot/* /mnt/
</pre>
<p>Monte a nova partição. Não se esqueça de atualizar o <a href="../pt/Fstab.html" title="Fstab (Português)">fstab</a> de acordo.
</p>
<pre># umount /boot
# umount /mnt
# mount /dev/sdx1 /boot
# genfstab -p -U / &gt; /etc/fstab
</pre>
<p>Atualize o <a href="../pt/GRUB.html" title="GRUB (Português)">GRUB</a>. <code>grub-mkconfig</code> deve detectar o novo UUID da partição automaticamente, mas entradas do menu customizadas precisam ser atualizadas manualmente.
</p>
<pre># grub-mkconfig -o /boot/grub/grub.cfg
# grub-install /dev/sdx # instale para a unidade de armazenamento removível, não a unidade de armazenamento interna.
</pre>
<p>Reinicie e teste a nova configuração. Se lembre de definir a entrada do dispositivo de boot de acordo com sua BIOS ou <a href="../en/Unified_Extensible_Firmware_Interface.html" class="mw-redirect" title="UEFI">UEFI</a>. Se o sistema falhar na inicialização, você deve ainda conseguir inicializar pelo disco rígido e então corrigir o problema.
</p>
<h3><span class="mw-headline" id="chkboot">chkboot</span></h3>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Atenção:</strong> chkboot faz a partição <code>/boot</code> <b>tamper-evident</b> (adulterações evidentes), não <b>tamper-proof</b> (a prova de adulteração). Quando o script chkboot é executado, você já digitou a sua senha em um potencialmente compromissado gerenciador de boot, kernel ou initrd. Se seu sistema falhar o teste de integridade chkboot, nenhuma assunção pode ser feita sobre a segurança dos seus dados.</div>
<p>Fazendo referência ao artigo (em inglês) da ct-magazine (em inglês, issue 3/12, página 146, 01.16.2012, <a rel="nofollow" class="external autonumber" href="https://www.heise.de/ct/inhalt/2012/03/6/">[2]</a>) o seguinte script checa por mudanças do SHA-1 hash, inode, e blocos ocupados no disco dos arquivos no <code>/boot</code>. Também checa o <a href="../pt/Partitioning.html#Master_Boot_Record" class="mw-redirect" title="Particionamento">Master Boot Record</a>. O script não pode prevenir certos tipos de ataques, mas o fazem mais difíceis. Nenhuma configuração do script é guardada no <code>/boot</code> não criptografado. Com o sistema criptografado fechado/desligado, não é aparente que uma comparação automática da soma de verificação da partição é feita na inicialização, dificultando para os atacantes. No entanto, um atacante que antecipar estas precauções pode manipular o firmware para rodar seu próprio código em cima do kernel e interceptar acessos ao sistema de arquivos, exemplo para <code>/boot</code>, e apresentar os arquivos intocados. Geralmente, nenhuma medida de segurança abaixo do nível do firmware pode garantir confiança e evidência de adulteração.
</p>
<p>O script com instruções de instalação está disponível <a rel="nofollow" class="external text" href="ftp://ftp.heise.de/pub/ct/listings/1203-146.zip">aqui</a> (Autor: Juergen Schmidt, ju na heisec.de; Licença: GPLv2). Existe também o pacote <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/chkboot/">chkboot</a></span><sup><small>AUR</small></sup> para <a href="../pt/Help:Reading.html#Instala%C3%A7%C3%A3o_de_pacotes" class="mw-redirect" title="Instala">instalar</a>.
</p>
<p>Depois da instalação, adicione um arquivo de serviço (o pacote inclui um baseado no seguinte) e <a href="../pt/Systemd.html#Usando_units" class="mw-redirect" title="Habilite">habilite</a>-o:
</p>
<pre>[Unit]
Description=Check that boot is what we want
Requires=basic.target
After=basic.target

[Service]
Type=oneshot
ExecStart=/usr/local/bin/chkboot.sh

[Install]
WantedBy=multi-user.target
</pre>
<p>Existe uma pequena ressalva para o systemd. No tempo de escrita, o script original provido, <code>chkboot.sh</code>, contém um espaço em branco no começo do <code><u> </u>#!/bin/bash</code> que deve ser removido para o serviço começar com sucesso.
</p>
<p><code>/usr/local/bin/chkboot_user.sh</code> precisa ser executado depois do login, adicione-o para a <a href="../pt/Autostarting.html" class="mw-redirect" title="Inicialização automática">inicialização automática</a> (exemplo, em inglês, no KDE -&gt; <i>System Settings -&gt; Startup and Shutdown -&gt; Autostart</i>; GNOME 3: <i>gnome-session-properties</i>). 
</p>
<p>Com o Arch Linux, mudanças no <code>/boot</code> são frequentes, por exemplo atualizações do kernel. Assim, pode ser útil usar scripts com cada atualização total do sistema. Uma forma de fazer isso é:
</p>
<pre>#!/bin/bash
#
# Nota: Insira seu &lt;usuário&gt; e execute isto com sudo para pacman e chkboot para funcionar automagicamente
#
echo "Atualização [1] Checagem rápida antes dela" &amp; 
sudo -u &lt;usuário&gt; /usr/local/bin/chkboot_user.sh		# insira seu &lt;usuário&gt; logado
/usr/local/bin/chkboot.sh
sudo -u &lt;usuário&gt; /usr/local/bin/chkboot_user.sh		# insira seu &lt;usuário&gt; logado
echo "Atualização [2] Sincronizando repositórios com o pacman" 
pacman -Syu
/usr/local/bin/chkboot.sh
sudo -u &lt;usuário&gt; /usr/local/bin/chkboot_user.sh		# insira seu &lt;usuário&gt; logado
echo "Atualização [3] Tudo feito, vamos continuar..."
</pre>
<h3><span class="mw-headline" id="mkinitcpio-chkcryptoboot">mkinitcpio-chkcryptoboot</span></h3>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Atenção:</strong> Este hook <b>não</b> criptografa o código núcleo do <a href="../pt/GRUB.html" title="GRUB (Português)">GRUB</a> ou EFI stub, nem protege contra situações onde um atacante pode modificar o comportamento do gerenciador de boot para comprometer o kernel e/ou initramfs durante a execução.</div>
<p><span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/mkinitcpio-chkcryptoboot/">mkinitcpio-chkcryptoboot</a></span><sup><small>AUR</small></sup> é um hook do <a href="../pt/Mkinitcpio.html" title="Mkinitcpio (Português)">mkinitcpio</a> que verifica a integridade durante o *** performs integrity checks during early-userspace e recomenda ao usuário não entrar com a senha da partição raiz criptografada se o sistema ter sido aparentemente comprometido. Segurança é conquistada atravês de uma <a href="../pt/bd347841f13524ba6da3458e094be74d.html#Parti%C3%A7%C3%A3o_de_boot_criptografada_(GRUB)" class="mw-redirect" title="Dm-crypt/Criptografando todo um sistema">partição de boot criptografada</a>, que é aberta usando o módulo <code>cryptodisk.mod</code> do <a href="../pt/GRUB.html#/boot_criptografado" title="GRUB (Português)">GRUB</a>, e a partição raiz criptografada tem uma senha diferente da anterior. Desta maneira, o <a href="../en/Arch_boot_process.html#initramfs" class="mw-redirect" title="Initramfs">initramfs</a> e o <a href="../pt/Kernel.html" title="Kernel (Português)">kernel</a> são protegidos contra adulterações offline, e a partição raiz pode permanecer segura até mesmo se a senha da partição <code>/boot</code> seja entrada em uma máquina comprometida (desde que o hook chkcryptoboot detecte modificações, e não seja comprometido durante a execução). 
</p>
<p>Este hook precisa do <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=grub">grub</a></span> versão &gt;= 2.00 para funcionar, e uma partição <code>/boot</code> criptografada com LUKS, com sua própria senha para ser segura.
</p>
<h4>
<span id="Instala.C3.A7.C3.A3o"></span><span class="mw-headline" id="Instalação">Instalação</span>
</h4>
<p><a href="../pt/Help:Reading.html#Instala%C3%A7%C3%A3o_de_pacotes" class="mw-redirect" title="Instale">Instale</a> o <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/mkinitcpio-chkcryptoboot/">mkinitcpio-chkcryptoboot</a></span><sup><small>AUR</small></sup> e edite <code>/etc/default/chkcryptoboot.conf</code>. Se você quer detectar se sua partição de boot foi modificada, edite as variáveis <code>CMDLINE_NAME</code> e <code>CMDLINE_VALUE</code>, com valores conhecidos somente por você. Você pode seguir o conselho de usar duas hash como é sugerido depois da instalação. Também, faça as mudanças apropriadas aos <a href="../pt/Kernel_parameters.html" class="mw-redirect" title="Parâmetros do kernel">parâmetros do kernel</a> em <code>/etc/default/grub</code>. Edite a linha <code>HOOKS=</code> em <code>/etc/mkinitcpio.conf</code>, e insira o hook <code>chkcryptoboot</code> <b>antes do</b> hook <code>encrypt</code>. Quando acabar, <a href="../pt/Mkinitcpio.html#Cria%C3%A7%C3%A3o_e_ativa%C3%A7%C3%A3o_de_imagem" class="mw-redirect" title="Gere novamente o initramfs">gere novamente o initramfs</a>.
</p>
<h4>
<span id="Vis.C3.A3o_geral_t.C3.A9cnica"></span><span class="mw-headline" id="Visão_geral_técnica">Visão geral técnica</span>
</h4>
<p><span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/mkinitcpio-chkcryptoboot/">mkinitcpio-chkcryptoboot</a></span><sup><small>AUR</small></sup> consiste de um install e run-time hook para o mkinitcpio. O install hook é executado toda vez que o initramfs é gerado, e faz hash do <a href="../en/Unified_Extensible_Firmware_Interface.html" class="mw-redirect" title="EFI">EFI</a> stub do GRUB (<code>$esp/EFI/grub_uefi/grubx64.efi</code>) (para sistemas <a href="../en/Unified_Extensible_Firmware_Interface.html" class="mw-redirect" title="UEFI">UEFI</a>) ou os primeiros 446 bytes do disco que o grub está instalado (para sistemas BIOS), e guarda esta hash dentro do initramfs localizado na partição <code>/boot</code> criptografada. Quando o sistema é inicializado, GRUB pede a senha para a partição <code>/boot</code>, e então o run-time hook executa a mesma operação de hash e compara o hash resultante antes de solicitar a senha para a partição raiz. Se eles não forem iguais, vai ser mostrado um erro como esse:
</p>
<pre>CHKCRYPTOBOOT ALERT!
CHANGES HAVE BEEN DETECTED IN YOUR BOOT LOADER EFISTUB!
YOU ARE STRONGLY ADVISED NOT TO ENTER YOUR ROOT CONTAINER PASSWORD!
Please type uppercase yes to continue:
</pre>
<p>Em adição a fazer hash do gerenciador de boot, o hook também verifica os parâmetros do kernel em execução com os configurados em <code>/etc/default/chkcryptoboot.conf</code>. Esta verificação é feita durante e depois do processo de inicialização. Isto permite detectar se a configuração do GRUB foi adulterada durante a execução e depois para verificar se toda a partição <code>/boot</code> foi modificada.
</p>
<p>Para sistemas BIOS, o hook cria um hash do primeiro estágio do gerenciador de boot GRUB (instalado nos primeiros 446 bytes do dispositivo de inicialização) para comparar depois no processo de inicialização. O principal segundo estágio <code>core.img</code> não é verificado.
</p>
<h3><span class="mw-headline" id="AIDE">AIDE</span></h3>
<p>Uma alternativa aos scripts acima, é a checagem de hash feita com <a href="../en/AIDE.html" title="AIDE">AIDE</a> que tem um arquivo de configuração muito flexível.
</p>
<h3><span class="mw-headline" id="STARK">STARK</span></h3>
<p>Enquanto um destes métodos devem servir para a maioria do usuários, eles não resolvem todos os problemas de segurança associados com o <code>/boot</code> não criptografado. Uma abordagem que se esforça para prover uma cadeia de inicialização totalmente autentificada foi publicada como POTTS, uma tese acadêmica de implementação do framework de autentificação <a rel="nofollow" class="external text" href="https://www1.informatik.uni-erlangen.de/stark">STARK</a>.
</p>
<p>O proof-of-concept (prova de conceito) POTTS usa Arch Linux como distribuição base e implementa um sistema de inicialização em cadeia com:
</p>
<ul>
<li>POTTS - um menu de inicialização com caixa de diálogo para autentificação única por meio de mensagem.</li>
<li>TrustedGrub - uma implementação do <a href="../en/GRUB_Legacy.html" title="GRUB Legacy">GRUB Legacy</a> que verifica o kernel e initramfs por meio de registradores PCR do <a href="../en/Trusted_Platform_Module.html" title="Trusted Platform Module">chip TPM</a>.</li>
<li>TRESOR - um patch do kernel que implementa AES, mas mantém a chave mestre nos registradores da CPU ao invês da RAM enquanto está em execução.</li>
</ul>
<p>Como parte da tese, as instruções de <a rel="nofollow" class="external text" href="https://13.tc/p/potts/manual.html">instalação</a> baseadas no Arch Linux (ISO de 2013-01) foi publicada. Se você quiser tentar, tenha em mente que estas ferramentas não estão nos repositórios padrão e a solução vai consumir tempo para manter.
</p>
<h2>
<span id="Usando_keyfiles_criptografadas_com_GPG.2C_LUKS_ou_OpenSSL"></span><span class="mw-headline" id="Usando_keyfiles_criptografadas_com_GPG,_LUKS_ou_OpenSSL">Usando keyfiles criptografadas com GPG, LUKS ou OpenSSL</span>
</h2>
<p>Os seguintes posts (em inglês) do fórum dão instruções para usar autentificação de dois fatores, keyfiles criptografadas com gpg ou openssl, ao invês de uma keyfile de texto puro descrita antes em <a rel="nofollow" class="external text" href="https://bbs.archlinux.org/viewtopic.php?id=120243">Criptografia de sistema usando LUKS com chaves criptografadas com GPG</a>:
</p>
<ul>
<li>GnuPG: <a rel="nofollow" class="external text" href="https://bbs.archlinux.org/viewtopic.php?pid=943338#p943338">Post sobre chaves criptografadas com GPG</a>. Possui instruções genéricas.</li>
<li>OpenSSL: <a rel="nofollow" class="external text" href="https://bbs.archlinux.org/viewtopic.php?pid=947805#p947805">Post sobre chaves criptografadas com OpenSSL</a>. Tem somente os hooks <code>ssldec</code>.</li>
<li>OpenSSL: <a rel="nofollow" class="external text" href="https://bbs.archlinux.org/viewtopic.php?id=155393">Post sobre chaves criptografadas com OpenSSL (embaralhadas com bf-cbc)</a>. Este post tem o hooks do initcpio install, <code>bfkf</code>, e script gerador de keyfile criptografada.</li>
<li>LUKS: <a rel="nofollow" class="external text" href="https://bbs.archlinux.org/viewtopic.php?pid=1502651#p1502651">Post sobre chaves criptografadas com LUKS</a> com um hook do initcpio <code>lukskey</code>. Ou <a href="#Encrypted_/boot_and_a_detached_LUKS_header_on_USB">#/boot criptografado e um cabeçalho LUKS desanexado em um pendrive</a> abaixo com um hook encrypt customizado para o  initcpio.</li>
</ul>
<p>Note que:
</p>
<ul>
<li>Você pode seguir as instruções acima com somente duas partições, uma de boot (necessário devido a criptografia) e uma LVM. Dentro da partição com LVM, você pode ter quantos volumes lógicos quiser/precisar, exemplo, volumes lógicos para a raiz, swap e home. Com isto basta ter somente uma keyfile para abrir os volumes lógicos da LVM criptografada. Se você decidir fazer isso, dentre os hooks presentes no <code>/etc/mkinitcpio.conf</code> deve ter:<pre>HOOKS=( ... usb usbinput (etwo ou ssldec) encrypt (se está usando openssl) lvm2 resume ... )</pre> e você deve adicionar <pre>resume=/dev/&lt;GrupoDeVolumes&gt;/&lt;VolumeLogicoDaSwap&gt;</pre> para os do <a href="../pt/Kernel_parameters.html" class="mw-redirect" title="Parâmetros do kernel">parâmetros do kernel</a>.</li>
<li>Se você precisa temporariamente guardar a keyfile não criptografada em algum lugar, não a guarde em um disco não criptografado. É mais recomendado guardá-la na RAM, em <code>/dev/shm</code>.</li>
<li>Se você quer usar uma keyfile criptografada com GPG, vai precisar usar uma versão 1.4 do GnuPG compilada estaticamente ou editar os hooks e usar este pacote do AUR <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/gnupg1/">gnupg1</a></span><sup><small>AUR</small></sup>
</li>
<li>É possível que uma atualização do OpenSSL quebre o <code>ssldec</code> customizado mencionado no segundo post do forum.</li>
</ul>
<h2>
<span id="Abrir_remotamente_a_parti.C3.A7.C3.A3o_raiz_.28ou_outra.29"></span><span class="mw-headline" id="Abrir_remotamente_a_partição_raiz_(ou_outra)">Abrir remotamente a partição raiz (ou outra)</span>
</h2>
<p>Se você deseja ser capaz de reiniciar um sistema criptografado com LUKS remotamente, ou iniciá-lo com um serviço <a href="../en/Wake-on-LAN.html" title="Wake-on-LAN">Wake-on-LAN</a>, você vai precisar de uma maneira de entrar a senha para a partição/container raiz na inicialização. Isto é alcançavél ao executar um hook do <a href="../pt/Mkinitcpio.html" title="Mkinitcpio (Português)">mkinitcpio</a> que configura uma interface de rede. Alguns pacotes listados abaixo contribuem com vários <a href="../pt/Mkinitcpio.html#Hooks_de_compila%C3%A7%C3%A3o" title="Mkinitcpio (Português)">hooks de compilação do mkinitcpio</a> para facilitar a configuração.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> 
<ul>
<li>Usar nomes de dispositivos do kernel para interface de rede (exemplo, <code>eth0</code>) ao invês dos do <a href="../en/Udev.html" title="Udev">udev</a> (exemplo, <code>enp1s0</code>), não vai funcionar.</li>
<li>Por padrão, nomes de interfaces de rede previsíveis são ativados e <i>mudam</i> nomes de dispositivos do kernel mais tarde durante a inicialização. Use dmesg e olhe o que seu módulo de rede do kernel faz para achar o nome original (exemplo, <code>eth0</code>)</li>
<li>Pode ser necessário adicionar o módulo para sua placa de rede <a href="../pt/2a2d9da11b1ecc48a6c73ac3dfbbd32f.html#Driver_de_dispositivo" title="Network configuration (Português)/Ethernet (Português)">a cabo</a> ou <a href="../pt/b9b884f10bec6b20a2e6f1b1fe79d6b3.html#Driver_de_dispositivo" title="Network configuration (Português)/Wireless (Português)">sem fio</a> para o vetor <a href="../pt/Mkinitcpio.html#MODULES" title="Mkinitcpio (Português)">MODULES</a>.</li>
</ul>
</div>
<h3>
<span id="Abrir_remotamente_.28hooks:_systemd.2C_systemd-tool.29"></span><span class="mw-headline" id="Abrir_remotamente_(hooks:_systemd,_systemd-tool)">Abrir remotamente (hooks: systemd, systemd-tool)</span>
</h3>
<p>O pacote do AUR <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=mkinitcpio-systemd-tool">mkinitcpio-systemd-tool</a></span> oferece um hook do mkinitcpio voltado no <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=systemd">systemd</a></span> com o nome de <i>systemd-tool</i> que possui as seguintes funcionalidades para o initramfs do systemd:
</p>
<table class="wikitable">

<tbody><tr style="vertical-align:top;">
<td width="50%" style="padding:10px;">
<p>Funcionalidades principais incluídas no hook:
</p>
<ul>
<li>configuração unificada do systemd + mkinitcpio</li>
<li>automática provisão de binário e recursos de configuração</li>
<li>invocação em demanda de scripts e funções do mkinitcpio</li>
</ul>
</td>
<td width="50%" style="padding:10px;">
<p>Funcionalidades oferecidas pela unidades de serviço incluídas:
</p>
<ul>
<li>debug do initrd</li>
<li>configuração inicial de rede antecipada</li>
<li>shell interativo</li>
<li>acesso remoto ssh no initrd</li>
<li>cryptsetup + agente de senha personalizado</li>
</ul>
</td>
</tr></tbody>
</table>
<p>O pacote <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=mkinitcpio-systemd-tool">mkinitcpio-systemd-tool</a></span> precisa do <a href="../pt/Mkinitcpio.html#Hooks_comuns" title="Mkinitcpio (Português)">hook do systemd</a>. Para mais informações leia o <a rel="nofollow" class="external text" href="https://github.com/random-archer/mkinitcpio-systemd-tool/blob/master/README.md">README</a> do projeto e também <a rel="nofollow" class="external text" href="https://github.com/random-archer/mkinitcpio-systemd-tool">arquivos unit de serviços do systemd</a> como uma introdução.
</p>
<p>Os hooks recomendados são: <code>base autodetect modconf block filesystems keyboard fsck systemd systemd-tool</code>.
</p>
<h3>
<span id="Abrir_remotamente_.28hooks:_netconf.2C_dropbear.2C_tinyssh.2C_ppp.29"></span><span class="mw-headline" id="Abrir_remotamente_(hooks:_netconf,_dropbear,_tinyssh,_ppp)">Abrir remotamente (hooks: netconf, dropbear, tinyssh, ppp)</span>
</h3>
<p>Outra combinação de pacotes que oferece login remoto para o initcpio é <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=mkinitcpio-netconf">mkinitcpio-netconf</a></span> e/ou <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/mkinitcpio-ppp/">mkinitcpio-ppp</a></span><sup><small>AUR</small></sup> (para abrir remotamente usando uma coneção <a href="https://en.wikipedia.org/wiki/Point-to-Point_Protocol" class="extiw" title="wikipedia:Point-to-Point Protocol">PPP</a>) junto com um servidor <a href="../pt/Secure_Shell.html" title="Secure Shell (Português)">SSH</a>. Você tem a opção de usar o <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=mkinitcpio-dropbear">mkinitcpio-dropbear</a></span> ou <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=mkinitcpio-tinyssh">mkinitcpio-tinyssh</a></span>. Estes hooks não instalam qualquer shell, então você pode precisar <a href="../pt/Help:Reading.html#Instala%C3%A7%C3%A3o_de_pacotes" class="mw-redirect" title="Instala">instalar</a> o pacote <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=mkinitcpio-utils">mkinitcpio-utils</a></span>. As instruções abaixo podem ser usadas em qualquer combinação dos pacotes acima. Será perceptível quando ações forem específicas para dada combinação de pacotes.
</p>
<ol>
<li>Se você não tem um par de chaves do SSH ainda, <a href="../en/SSH_keys.html#Generating_an_SSH_key_pair" title="SSH keys">o gere</a> no sistema cliente (o que vai ser usado para abrir remotamente a máquina). <div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> <code>tinyssh</code> somente suporta <a href="../en/SSH_keys.html#Ed25519" title="SSH keys">Ed25519</a> e tipos de chave <a href="../en/SSH_keys.html#ECDSA" title="SSH keys">ECDSA</a>. Se você prefere usar <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=mkinitcpio-tinyssh">mkinitcpio-tinyssh</a></span>, você precisa criar/usar um destes.</div> <div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> <code>mkinitcpio-dropbear</code> na versão 0.0.3-5 não é compativel com a atual implementação do dropbear que removeu dss. Veja a <a rel="nofollow" class="external text" href="https://github.com/grazzolini/mkinitcpio-dropbear/issues/8">issue 8</a> para detalhes e como corrigir.</div>
</li>
<li>Insira sua chave pública do SSH (exemplo, a que você normalmente coloca nas máquinas acessadas sem uma senha, ou a que você criou e termina com <i>.pub</i>) no <code>/etc/dropbear/root_key</code> ou <code>/etc/tinyssh/root_key</code> da máquina remota. <div class="archwiki-template-box archwiki-template-box-tip">
<strong>Dica:</strong> Este método pode ser usado mais tarde para adicionar outras chaves públicas se necessário; Caso copie o conteúdo do arquivo <code>~/.ssh/authorized_keys</code> da máquina remota, verifique se somente tem chaves que você planeja usar para abrir a máquina remotamente. Quando adicionar chaves, gere seu initrd também usando o <code>mkinitcpio</code>. Veja também <a href="../en/OpenSSH.html#Protection" title="OpenSSH">OpenSSH#Protection</a>.</div>
</li>
<li>Adicione todos os três <a href="../pt/Mkinitcpio.html#HOOKS" title="Mkinitcpio (Português)">hooks</a> <code>&lt;netconf e/ou ppp&gt; &lt;dropbear ou tinyssh&gt; encryptssh</code> antes de <code>filesystems</code> dentro do vetor "HOOKS" no <code>/etc/mkinitcpio.conf</code> (o hook <code>encryptssh</code> substitue <code>encrypt</code>). Então <a href="../pt/Mkinitcpio.html#Cria%C3%A7%C3%A3o_e_ativa%C3%A7%C3%A3o_de_imagem" class="mw-redirect" title="Gere novamente o initramfs">gere novamente o initramfs</a>. <div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> O hook <code>net</code> provido pelo <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=mkinitcpio-nfs-utils">mkinitcpio-nfs-utils</a></span> <b>não</b> é necessário.</div>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Se você receber o erro <code>libgcc_s.so.1 must be installed for pthread_cancel to work</code> quando tentar descriptografar, você precisa adicionar <code>/usr/lib/libgcc_s.so.1</code> para o vetor "<a href="../pt/Mkinitcpio.html#BINARIES_e_FILES" title="Mkinitcpio (Português)">BINARIES</a>".</div>
</li>
<li>Configure o <a href="../pt/5e279fa7d75b32c0232ab38e4294ae71.html#Gerenciador_de_boot" class="mw-redirect" title="Dm-crypt/Configuração do sistema">parâmetro</a> <code>cryptdevice=</code> e adicione o <a href="../en/Kernel_parameters.html" title="Kernel parameters">o parâmetro do kernel</a> <code>ip=</code> para a configuração do seu gerenciador de boot com os argumentos apropriados. Por exemplo, se o servidor DHCP não atribuir um IP estático para seu sistema remoto, dificultando o acesso com SSH entre inicializações, você pode explicitamente declarar o endereço IP que você quer, usando: <pre>ip=192.168.1.1:::::eth0:none</pre> Alternativamente, você pode especificar também a máscara de subrede e gateway necessário para a rede: <pre>ip=192.168.1.1::192.168.1.254:255.255.255.0::eth0:none</pre> <div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Na versão 0.0.4 do <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=mkinitcpio-netconf">mkinitcpio-netconf</a></span>, você pode usar múltiplos <code>ip=</code> para configurar várias interfaces. você não pode misturar isto com <code>ip=dhcp</code> (<code>ip=:::::eth0:dhcp</code>) sozinho. Uma interface precisa ser especificada.</div> <pre>ip=ip=192.168.1.1:::::eth0:none:ip=172.16.1.1:::::eth1:none</pre> Para uma descrição detalhada veja <a href="../pt/Mkinitcpio.html#Usando_net" title="Mkinitcpio (Português)">essa seção do mkinitcpio</a>. Quando terminar, atualize a configuração do seu <a href="../pt/Arch_boot_process.html#Gerenciador_de_boot" class="mw-redirect" title="Gerenciador de boot">gerenciador de boot</a>.</li>
<li>Finalmente, reinicie o sistema remoto e tente <a href="../en/OpenSSH.html#Client_usage" title="OpenSSH">usar o ssh</a>, <b>explicitamente usando o nome de usuário "root"</b> (até mesmo se o superusuário root está desabilitado na máquina, este usuário root é usado somente no initrd para abrir o sistema remotamente). Se você está usando o pacote <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=mkinitcpio-dropbear">mkinitcpio-dropbear</a></span> e também tem o pacote <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=openssh">openssh</a></span> instalado, então provavelmente não vai receber nenhum aviso antes de logar, porquê o anterior converte e usa as mesmas chaves do ssh (exceto chaves Ed25519, já que o dropbear não suporta elas). Caso você está usando <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=mkinitcpio-tinyssh">mkinitcpio-tinyssh</a></span>, existe a opção de instalar <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=tinyssh-convert">tinyssh-convert</a></span> ou <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/tinyssh-convert-git/">tinyssh-convert-git</a></span><sup><small>AUR</small></sup> para que você possa usar as mesmas chaves da sua instalação do <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=openssh">openssh</a></span> (atualmente, somente chaves Ed25519). De qualquer forma, você precisa rodar o <a href="../en/OpenSSH.html#Daemon_management" title="OpenSSH">daemon do ssh</a> ao menos uma vez, usando as units providas do systemd, então as chaves podem ser geradas primeiro. Depois de reiniciar a máquina, deve ser solicitado a senha para abrir o dispositivo raiz. O sistema vai completar o processo de inicialização e você pode executar o ssh <a href="../en/OpenSSH.html#Client_usage" title="OpenSSH">normalmente</a> (com o usuário remoto de sua escolha).</li>
</ol>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Dica:</strong> Se você deseja uma boa solução para montar outras partições criptografadas (tais como <code>/home</code>) remotamente, você pode quer ler <a rel="nofollow" class="external text" href="https://bbs.archlinux.org/viewtopic.php?pid=880484">esta thread do forum</a>.</div>
<h3><span class="mw-headline" id="Abrir_remotamente_pelo_wifi">Abrir remotamente pelo wifi</span></h3>
<p>O hook net é normalmente usado com uma conexão com fio. Caso você queira configurar um computador sem fio, e abrí-lo por wifi, você pode usar um hook predefinido ou criar um hook customizado para se conectar a rede wifi antes que o hook net seja executado.
</p>
<h4><span class="mw-headline" id="Hook_predefinido">Hook predefinido</span></h4>
<p>Você pode instalar um hook predefinido baseado no presente nesta wiki:
</p>
<ol>
<li>Instale <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/mkinitcpio-wifi/">mkinitcpio-wifi</a></span><sup><small>AUR</small></sup>.</li>
<li>Configure sua coneção wifi ao criar uma configuração do wpa_supplicant com as propriedades da sua rede: <pre>wpa_passphrase "ESSID" "senha" &gt; /etc/wpa_supplicant/initcpio.conf</pre>
</li>
<li>Adicione o hook <code>wifi</code> antes de <code>netconf</code> no seu <code>/etc/mkinitcpio.conf</code>. Seus módulos relacionados com wifi devem ser detectados automaticamente, se não: adicione eles em <code>MODULES</code>.</li>
<li>Adicione <code>ip=:::::wlan0:dhcp</code> nos <a href="../pt/Kernel_parameters.html" class="mw-redirect" title="Parâmetros do kernel">parâmetros do kernel</a>.</li>
<li>
<a href="../pt/Mkinitcpio.html#Cria%C3%A7%C3%A3o_e_ativa%C3%A7%C3%A3o_de_imagem" class="mw-redirect" title="Gere novamente o initramfs">Gere novamente o initramfs</a>.</li>
<li>Atualize a configuração do seu <a href="../pt/Arch_boot_process.html#Gerenciador_de_boot" class="mw-redirect" title="Gerenciador de boot">gerenciador de boot</a>.</li>
</ol>
<h4>
<span id="Fa.C3.A7a_o_seu_pr.C3.B3prio"></span><span class="mw-headline" id="Faça_o_seu_próprio">Faça o seu próprio</span>
</h4>
<p>Abaixo um exemplo mostrando uma configuração usando um adaptador usb, se conectando a uma rede wifi com WPA2-PSK. Caso você use, por exemplo, WEP ou outro gerenciador de boot, você pode precisar mudar algumas coisas.
</p>
<ol>
<li>Modifique o <code>/etc/mkinitcpio.conf</code>:
<ul>
<li>Adicione os módulos do kernel necessários para seu adaptador wifi.</li>
<li>Inclua os binários do <code>wpa_passphrase</code> e <code>wpa_supplicant</code>.</li>
<li>Adicione o hook <code>wifi</code> (ou um nome de sua escolha, este será o hook customizado que será criado) antes do hook <code>net</code>. <pre>MODULES=(<i>module</i>)<br>BINARIES=(wpa_passphrase wpa_supplicant)<br>HOOKS=(base udev autodetect ... <b>wifi</b> net ... dropbear encryptssh ...)</pre>
</li>
</ul>
</li>
<li>Crie o hook <code>wifi</code> no <code>/etc/initcpio/hooks/wifi</code>:<pre>run_hook ()<br>{<br>	# espere alguns segundos para que wlan0 seja configurada pelo kernel<br>	sleep 5<br><br>	# set wlan0 to up<br>	ip link set wlan0 up<br><br>	# associe com a rede wifi<br>	# 1. salve o arquivo de configuração temporário<br>	wpa_passphrase "<i>ESSID da rede</i>" "<i>senha</i>" &gt; /tmp/wifi<br><br>	# 2. associe<br>	wpa_supplicant -B -D nl80211,wext -i wlan0 -c /tmp/wifi<br><br>	# espere alguns segundos para que wpa_supplicant termine de se conectar<br>	sleep 5<br><br>	# wlan0 deve agora estar conectada e pronta para receber um ip pelo hook net<br>}<br><br>run_cleanuphook ()<br>{<br>	# mate wpa_supplicant rodando em segundo plano<br>	killall wpa_supplicant<br><br>	# coloque a interface wlan0 como down<br>	ip link set wlan0 down<br><br>	# wlan0 deve agora esta totalmente desconectada da rede wifi<br>}</pre>
</li>
<li>Crie o arquivo do hook de instalação no <code>/etc/initcpio/install/wifi</code>:<pre>build ()<br>{<br>	add_runscript<br>}<br>help ()<br>{<br>cat&lt;&lt;HELPEOF<br>	Habilita o wifi na inicialização, para abrir o disco com dropbear (ssh).<br>HELPEOF<br>}</pre>
</li>
<li>Adicione <code>ip=:::::wlan0:dhcp</code> para os <a href="../pt/Kernel_parameters.html" class="mw-redirect" title="Parâmetros do kernel">parâmetros do kernel</a>. Remova <code>ip=:::::eth0:dhcp</code> para evitar conflitos.</li>
<li>Opcionalmente crie uma entrada de boot adicional com o parâmetro do kernel <code>ip=:::::eth0:dhcp</code>.</li>
<li>
<a href="../pt/Mkinitcpio.html#Cria%C3%A7%C3%A3o_e_ativa%C3%A7%C3%A3o_de_imagem" class="mw-redirect" title="Gere novamente o initramfs">Gere novamente o initramfs</a>.</li>
<li>Atualize a configuração do seu <a href="../pt/Arch_boot_process.html#Gerenciador_de_boot" class="mw-redirect" title="Gerenciador de boot">gerenciador de boot</a>.</li>
</ol>
<p>Uma vez que o sistema estiver totalmente inicializado, se lembre de configurar o <a href="../pt/b9b884f10bec6b20a2e6f1b1fe79d6b3.html" title="Network configuration (Português)/Wireless (Português)">wifi</a>, para então você fazer login. Caso você não consiga se conectar a rede wifi, tente aumentar um pouco o tempo de espera.
</p>
<h2>
<span id="Suporte_a_discard.2FTRIM_para_unidades_de_estado_s.C3.B3lido_.28SSD.29"></span><span class="mw-headline" id="Suporte_a_discard/TRIM_para_unidades_de_estado_sólido_(SSD)">Suporte a discard/TRIM para unidades de estado sólido (SSD)</span>
</h2>
<p>Usuários de <a href="../en/Solid_state_drive.html" title="Solid state drive">SSDs</a> devem saber que, por padrão, comandos de TRIM não são habilitados pelo mapeador de dispositivos, dispositivos de bloco são montados sem a opção <code>discard</code> a menos que você sobrescreva o padrão. 
</p>
<p>Os mantenedores do mapeador de dispositivos deixaram claro que suporte a TRIM nunca será habilitado por padrão em dispositivos do dm-crypt devido a potenciais implicações de segurança.<a rel="nofollow" class="external autonumber" href="http://www.saout.de/pipermail/dm-crypt/2011-September/002019.html">[3]</a><a rel="nofollow" class="external autonumber" href="http://www.saout.de/pipermail/dm-crypt/2012-April/002420.html">[4]</a> Um vazamento mínimo de dados em forma de informações de blocos liberadas, talvez o suficiente para determinar o sistema de arquivos em uso, pode ocorrer se o suporte a TRIM estiver habilitado. Ilustrações e discursão dos problemas resultantes estão disponíveis no <a rel="nofollow" class="external text" href="https://asalor.blogspot.de/2011/08/trim-dm-crypt-problems.html">blog</a> de um dos desenvolvedores do <i>cryptsetup</i>. Se você está preocupado com isso, tenha em mente que as ameaças podem crescer: por exemplo, se o dispositivo está ainda criptografado com a antiga cifra padrão (cryptsetup &lt;=1.6.0) <code>--cipher aes-cbc-essiv</code>, mais informação pode ser vazada do setor que sofreu TRIM do que com o <a href="../pt/32a9ef2a5038cdf95d792b1a87067cba.html#Op%C3%A7%C3%B5es_de_encripta%C3%A7%C3%A3o_para_o_modo_LUKS" class="mw-redirect" title="Dm-crypt/Encriptação de dispositivo">padrão</a> atual.
</p>
<p>Os seguintes casos podem ser distinguidos:
</p>
<ul><li>O dispositivo é criptografado com as opções padrão do modo LUKS do dm-crypt:
<ul>
<li>Por padrão o cabeçalho do LUKS é guardado no início do dispositivo e usar TRIM é útil para proteger as modificações do cabeçalho. Se por exemplo uma senha comprometida do LUKS é revocada, sem TRIM o velho cabeçalho vai, geralmente, ainda estar disponível para leitura até que seja sobrescrevida por outra operação; se a unidade de armazenamento é roubada nesse periodo, os atacantes podem em teoria achar uma maneira de localizar o velho cabeçalho e usá-lo para descriptografar o dispositivo com a senha compromissada. Veja <a rel="nofollow" class="external text" href="https://gitlab.com/cryptsetup/cryptsetup/wikis/FrequentlyAskedQuestions#5-security-aspects">FAQ do cryptsetup, seção 5.19 "What about SSDs, Flash and Hybrid Drives?"</a> e <a rel="nofollow" class="external text" href="https://www.reddit.com/r/archlinux/comments/2f370s/full_disk_encryption_on_an_ssd/ck5p5c5">Encriptação total de disco em um ssd</a>.</li>
<li>TRIM pode continuar desabilitado se as preocupações de segurança mostradas no começo desta seção são consideradas uma ameaça pior que a acima.</li>
</ul>
</li></ul>
<dl><dd>Veja também <a href="../en/Securely_wipe_disk.html#Flash_memory" title="Securely wipe disk">Securely wipe disk#Flash memory</a>.</dd></dl>
<ul><li>O dispositivo é criptografado com o modo plain do dm-crypt, ou o cabeçalho do LUKS é guardado <a href="#Sistema_criptografado_usando_um_cabe%C3%A7alho_LUKS_desanexado">separadamente</a>:
<ul>
<li>Se negação plausível é desejada, TRIM <b>nunca</b> deve ser usado devido a considerações no começo dessa seção, ou o uso de encriptação vai ser revelado.</li>
<li>Se negação plausível não é desejada, TRIM pode ser usado para ganhos de perfomance, já que problemas de segurança descritos no começo dessa seção não são uma preocupação.</li>
</ul>
</li></ul>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Atenção:</strong> Antes de habilitar o TRIM na unidade de armazenamento, tenha certeza de que o dispositivo suporta totalmente comandos de TRIM, ou perda de dados podem ocorrer. Veja <a href="../en/Solid_state_drive.html#TRIM" class="mw-redirect" title="Solid State Drives">Solid State Drives#TRIM</a>.</div>
<p>No <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=linux">linux</a></span> 3.1 e superior, habilitar o TRIM no dm-crypt pode ser alcançado na montagem com <code>dmsetup</code> ou na criação do dispositivo. Suporte para esta opção também existe no <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=cryptsetup">cryptsetup</a></span> versão &gt;= 1.4.0. Para adicionar suporte durante a inicialização, você precisa adicionar <code>:allow-discards</code> para a opção <code>cryptdevice</code>. A opção de TRIM pode parecer assim:
</p>
<pre>cryptdevice=/dev/sdaX:raiz:allow-discards
</pre>
<p>Para as configurações principais do <code>cryptdevice</code> antes de <code>allow-discards</code> veja <a href="../pt/5e279fa7d75b32c0232ab38e4294ae71.html" class="mw-redirect" title="Dm-crypt/Configuração do sistema">Dm-crypt/Configuração do sistema</a>.
</p>
<p>Se você usa um initrd baseado no systemd, você deve colocar:
</p>
<pre>rd.luks.options=discard
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> <code>rd.luks.options=discard</code> não tem efeito nos dispositivos incluidos no arquivo <code>/etc/crypttab</code> da imagem do initramfs (<code>/etc/crypttab.initramfs</code> na raiz do sistema). Você deve especificar a opção <code>discard</code> no <code>/etc/crypttab.initramfs</code>.</div>
<p>Além disso, também é necessário periodicamente rodar <code>fstrim</code> ou montar o sistema de arquivos (exemplo, <code>/dev/mapper/raiz</code> neste exemplo) com a opção <code>discard</code> no <code>/etc/fstab</code>. Para detalhes, veja a página do <a href="../en/Solid_state_drive.html#TRIM" class="mw-redirect" title="TRIM">TRIM</a>.
</p>
<p>Para dispositivos LUKS abertos com <code>/etc/crypttab</code>, use a opção <code>discard</code>, exemplo:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/crypttab</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">luks-123abcdef-etc UUID=123abcdef-etc none discard</pre>
<p>Quando abrir manualmente os dispositivos no terminal use <code>--allow-discards</code>.
</p>
<p>Com LUKS2 você pode definir <code>allow-discards</code> como uma flag padrão para um dispositivo ao abrí-lo uma vez com a opção <code>--persistent</code>:
</p>
<pre># cryptsetup --allow-discards --persistent open /dev/sdaX root
</pre>
<p>Quando o dispositivo já estiver aberto, a ação <code>open</code> vai dar erro. Nestes casos você pode usar a opção <code>refresh</code>, exemplo:
</p>
<pre># cryptsetup --allow-discards --persistent refresh /dev/sdaX
</pre>
<p>Você pode ter certeza que a flag está definida como persistente no cabeçalho do LUKS2 ao olhar a saída do <code>cryptsetup luksDump</code>:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup luksDump /dev/sdaX | grep Flags</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Flags:          allow-discards
</pre>
<p>Em qualquer caso você pode ver se o dispositivo foi aberto com a flag ao inspecionar a saída do <code>dmsetup table</code>:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># dmsetup table</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">luks-123abcdef-etc: 0 1234567 crypt aes-xts-plain64 000etc000 0 8:2 4096 1 allow_discards
</pre>
<h2>
<span id="O_hook_encrypt_e_m.C3.BAltiplos_discos"></span><span class="mw-headline" id="O_hook_encrypt_e_múltiplos_discos">O hook encrypt e múltiplos discos</span>
</h2>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Dica:</strong> o hook <code>sd-encrypt</code> suporta abrir múltiplos dispositivos. Eles podem ser especificados nos parâmetros do kernel ou no <code>/etc/crypttab.initramfs</code>. Veja <a href="../pt/5e279fa7d75b32c0232ab38e4294ae71.html#Usando_o_hook_sd-encrypt" class="mw-redirect" title="Dm-crypt/Configuração do sistema">dm-crypt/Configuração do sistema#Usando o hook sd-encrypt</a>.</div>
<p>O hook <code>encrypt</code> somente permite uma <b>única</b> entrada <code>cryptdevice=</code> (<a rel="nofollow" class="external text" href="https://bugs.archlinux.org/task/23182">FS#23182</a>). Em um sistema com múltiplas unidades de armazenamentos isto pode ser limitante, devido ao <i>dm-crypt</i> não ter funcionalidade para usar algo além de dispositivos físicos. Por exemplo, use "LVM dentro do LUKS":  Toda a LVM existe dentro de um dispositivo LUKS. Não há problema para sistema com uma unidade de armazenamento, desde que tem somente uma para criptografar. Mas o que acontece se você quer aumentar o tamanho da LVM? Você não pode, não sem modificar o hook <code>encrypt</code>.
</p>
<p>As seções seguintes brevemente mostram alternativas para superar esta limitação. A primeira, demostra como expandir uma configuração <a href="../pt/bd347841f13524ba6da3458e094be74d.html#LUKS_dentro_do_LVM" class="mw-redirect" title="Dm-crypt/Criptografando todo um sistema">LUKS dentro do LVM</a> para um novo disco. A segunda, em como modificar o hook <code>encrypt</code> para abrir múltiplos disco criptografados com LUKS sem LVM.
</p>
<h3>
<span id="Expandindo_LVM_em_m.C3.BAltiplos_discos"></span><span class="mw-headline" id="Expandindo_LVM_em_múltiplos_discos">Expandindo LVM em múltiplos discos</span>
</h3>
<p>O gerenciamento de múltiplos discos é uma funcionalidade básica do <a href="../pt/LVM.html" title="LVM (Português)">LVM</a> e uma da razões por seu particionamento flexível. Pode ser usado com <i>dm-crypt</i>, mas somente se LVM é empregado como primeiro mapeador. Em uma configuração <a href="../pt/bd347841f13524ba6da3458e094be74d.html#LUKS_dentro_do_LVM" class="mw-redirect" title="Dm-crypt/Criptografando todo um sistema">LUKS dentro do LVM</a>, os dispositivos criptografados são criados dentro de volumes lógicos (com uma senha/chave separada por volume). A seguir é mostrado como expandir para outro disco.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Atenção:</strong> Faça backup! Enquanto redimensionar sistema de arquivos pode ser o padrão, tenha em mente que operções <b>podem</b> dar errado e não serem aplicáveis para uma configuração específica. Geralmente, extender um sistema de arquivos para usar o espaço livre é menos problemático que reduzí-lo. Isto é particularmente verdade quando mapeadores são empilhados, o caso do seguinte exemplo.</div>
<h4><span class="mw-headline" id="Adicionando_uma_nova_unidade_de_armazenamento">Adicionando uma nova unidade de armazenamento</span></h4>
<p>Primeiro, pode ser desejado preparar um novo disco de acordo com <a href="../pt/ad45d25565fc10042af3fc980f15016f.html" class="mw-redirect" title="Dm-crypt/Preparando a unidade de armazenamento">dm-crypt/Preparando a unidade de armazenamento</a>.
Segundo, é particionado como um LVM, exemplo, todo o espaço é alocado para <code>/dev/sdY1</code> com o tipo de partição <code>8E00</code> (Linux LVM).
Terceiro, o novo disco/partição é ligado a um grupo de volumes do LVM existente, exemplo:
</p>
<pre># pvcreate /dev/sdY1
# vgextend MeuArmazenamento /dev/sdY1
</pre>
<h4>
<span id="Extendendo_o_volume_l.C3.B3gico"></span><span class="mw-headline" id="Extendendo_o_volume_lógico">Extendendo o volume lógico</span>
</h4>
<p>Para o próximo passo, a alocação final do novo espaço do disco, o volume lógico que será extendido tem que estar desmontado. Isto pode ser feito pela partição raiz do <code>cryptdevice</code>, mas neste caso o procedimento vai ser feito com a ISO de instalação do Arch.
</p>
<p>Neste exemplo, é assumido que o volume lógico para <code>/home</code> (<code>homevol</code> é nome do volume lógico) vai ser expandido para o novo espaço em disco: 
</p>
<pre># umount /home
# fsck /dev/mapper/home
# cryptsetup luksClose /dev/mapper/home
# lvextend -l +100%FREE MeuArmazenamento/homevol
</pre>
<p>Agora o volume lógico é extendido e o container LUKS vem depois: 
</p>
<pre># cryptsetup open /dev/MeuArmazenamento/homevol home
# umount /home      # como uma garantia, caso foi automaticamente montado
# cryptsetup --verbose resize home
</pre>
<p>Finalmente, o sistema de arquivos vai ser redimensionado: 
</p>
<pre># e2fsck -f /dev/mapper/home
# resize2fs /dev/mapper/home
</pre>
<p>Pronto! Se foi de acordo com o plano, <code>/home</code> pode ser remontado e agora inclui a extensão para o novo disco:
</p>
<pre># mount /dev/mapper/home /home
</pre>
<p>Note que a ação <code>cryptsetup resize</code> não afeta as chaves de encriptação, e estas não mudaram.
</p>
<h3>
<span id="Modificando_o_hook_encrypt_para_m.C3.BAltiplas_parti.C3.A7.C3.B5es"></span><span class="mw-headline" id="Modificando_o_hook_encrypt_para_múltiplas_partições">Modificando o hook encrypt para múltiplas partições</span>
</h3>
<h4>
<span id="sistema_de_arquivos_principal_expandido_para_m.C3.BAltiplas_parti.C3.A7.C3.B5es"></span><span class="mw-headline" id="sistema_de_arquivos_principal_expandido_para_múltiplas_partições">sistema de arquivos principal expandido para múltiplas partições</span>
</h4>
<p>É possível modificar o hook encrypt para permitir que múltiplas unidades de armazenamento abram a raiz <code>/</code> na inicialização. Uma maneira é:
</p>
<pre># cp /usr/lib/initcpio/install/encrypt /etc/initcpio/install/encrypt2
# cp /usr/lib/initcpio/hooks/encrypt  /etc/initcpio/hooks/encrypt2
# sed -i "s/cryptdevice/cryptdevice2/" /etc/initcpio/hooks/encrypt2
# sed -i "s/cryptkey/cryptkey2/" /etc/initcpio/hooks/encrypt2
</pre>
<p>Adicione <code>cryptdevice2=</code> para suas opções de boot (e <code>cryptkey2=</code> se necessário), e adicione o hook <code>encrypt2</code> para seu <a href="../pt/Mkinitcpio.html" title="Mkinitcpio (Português)">mkinitcpio.conf</a> antes de gerar o initramfs. Veja <a href="../pt/5e279fa7d75b32c0232ab38e4294ae71.html" class="mw-redirect" title="Dm-crypt/Configuração do sistema">dm-crypt/Configuração do sistema</a>.
</p>
<h4>
<span id="M.C3.BAltiplas_parti.C3.A7.C3.B5es_n.C3.A3o_raiz"></span><span class="mw-headline" id="Múltiplas_partições_não_raiz">Múltiplas partições não raiz</span>
</h4>
<p>Talvez você precisa usar o hook <code>encrypt</code> em uma partição não raiz. Arch não suporta isto nativamente, no entanto, você pode facilmente mudar os valores cryptdev e cryptname em <code>/lib/initcpio/hooks/encrypt</code> (o primeiro para sua partição <code>/dev/sd*</code>, a segunda para o nome que você quer o atribuir). Isto deve bastar.
</p>
<p>A grande vantagem é que você pode ter tudo automatizado, configurar o <code>/etc/crypttab</code> com uma keyfile externa (a keyfile não está numa partição do disco rígido interno) pode ser chato - você precisa ter certeza que o dispositivo USB/FireWire/... é montado antes da partição criptografada, isto significa que você tem de mudar a ordem do <code>/etc/fstab</code> (ao menos).
</p>
<p>Se o pacote <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=cryptsetup">cryptsetup</a></span> for atualizado, você terá que mudar este script denovo. Diferente do <code>/etc/crypttab</code>, somente uma partição é suportada, mas com alguns hacks é possível abrir múltiplas partições.
</p>
<div class="noprint archwiki-template-message">
<p><a href="../File:Tango-inaccurate.png" class="image"><img alt="Tango-inaccurate.png" src="../File:Tango-inaccurate.png" decoding="async" width="48" height="48"></a><b>The factual accuracy of this article or section is disputed.</b><a href="../File:Tango-inaccurate.png" class="image"><img alt="Tango-inaccurate.png" src="../File:Tango-inaccurate.png" decoding="async" width="48" height="48"></a></p>
<div>
<b>Reason:</b> Porque não usar o suporte do GRUB2 imediatamente? Veja também <a href="../pt/Mkinitcpio.html#Usando_RAID" title="Mkinitcpio (Português)">mkinitcpio#Usando RAID</a> (Discuss in <a rel="nofollow" class="external text" href="https://wiki.archlinux.org/index.php/Talk:Dm-crypt/Specialties">talk:dm-crypt/Specialties</a>)</div>
</div> 
<p>Se você quer fazer isto em uma partição RAID de software, existe mais uma coisa que você precisa fazer. Somente definir o dispositivo <code>/dev/mdX</code> em <code>/lib/initcpio/hooks/encrypt</code> não é o bastante; o hook <code>encrypt</code> não vai encontrar a chave por algum motivo, e a senha não vai ser solicitada. Aparentemente, dispositivos RAID não são descobertos antes do hook <code>encrypt</code> rodar. Você pode resolver isto ao botar o arranjo RAID em <code>/boot/grub/menu.lst</code>, como:
</p>
<pre>kernel /boot/vmlinuz-linux md=1,/dev/hda5,/dev/hdb5
</pre>
<p>Se você usar sua partição raiz como RAID, você vai notar similaridades com esta configuração. <a href="../pt/GRUB.html" title="GRUB (Português)">GRUB</a> pode de forma simples manusear definições de múltiplos arranjos:
</p>
<pre>kernel /boot/vmlinuz-linux root=/dev/md0 ro md=0,/dev/sda1,/dev/sdb1 md=1,/dev/sda5,/dev/sdb5,/dev/sdc5
</pre>
<h2>
<span id="Sistema_criptografado_usando_um_cabe.C3.A7alho_LUKS_desanexado"></span><span class="mw-headline" id="Sistema_criptografado_usando_um_cabeçalho_LUKS_desanexado">Sistema criptografado usando um cabeçalho LUKS desanexado</span>
</h2>
<p>Este exemplo segue a mesma configuração do <a href="../pt/bd347841f13524ba6da3458e094be74d.html#dm-crypt_plain" class="mw-redirect" title="Dm-crypt/Criptografando todo um sistema">dm-crypt/Criptografando todo um sistema#dm-crypt plain</a>, que deve ser lida antes de seguir este guia.
</p>
<p>Ao usar um cabeçalho desanezado, o dispositivo de bloco criptografado somente possui os dados criptografados, o que leva à <a href="https://en.wikipedia.org/wiki/Deniable_encryption" class="extiw" title="wikipedia:Deniable encryption">criptografia negável</a> enquanto a existência do cabeçalho é desconhecida pelos atacantes. É similar ao <a href="../pt/bd347841f13524ba6da3458e094be74d.html#dm-crypt_plain" class="mw-redirect" title="Dm-crypt/Criptografando todo um sistema">dm-crypt plain</a>, mas com as vantagens do LUKS como múltiplas senhas para a chave mestre e derivação de chave. Além de oferecer uma forma de autentificação de dois fatores com uma configuração mais simples que <a href="#Using_GPG,_LUKS,_or_OpenSSL_Encrypted_Keyfiles">#Using GPG, LUKS, or OpenSSL Encrypted Keyfiles</a><sup>[<a href="../pt/Help:Procedures.html#Corrigir_links_quebrados_de_se%C3%A7%C3%B5es" class="mw-redirect" title="Help:Procedimentos">link quebrado</a>: seção inválida]</sup>, enquanto nativamente tem solicitação de senha para múltiplas tentativas. Veja <a href="../pt/Data-at-rest_encryption.html#Metadados_criptogr%C3%A1ficos" class="mw-redirect" title="Criptografia de disco">Criptografia de disco#Metadados criptográficos</a> para mais informações.
</p>
<p>Veja <a href="../pt/32a9ef2a5038cdf95d792b1a87067cba.html#Op%C3%A7%C3%B5es_de_encripta%C3%A7%C3%A3o_para_o_modo_LUKS" class="mw-redirect" title="Dm-crypt/Encriptação de dispositivo">dm-crypt/Encriptação de dispositivo#Opções de encriptação para o modo LUKS</a> para opções de encriptação antes de executar o primeiro passo e criar o arquivo de cabeçalho para usar com <code>cryptsetup</code>:
</p>
<pre># dd if=/dev/zero of=cabecalho.img bs=16M count=1
# cryptsetup luksFormat /dev/sdX --offset 32768 --header cabecalho.img
</pre>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Dica:</strong> A opção <code>--offset</code> permite especificar o início dos dados criptografados no dispositivo. Ao reservar um espaço no começo do dispositivo você pode <a href="../pt/32a9ef2a5038cdf95d792b1a87067cba.html#Restaura%C3%A7%C3%A3o_usando_o_cryptsetup" class="mw-redirect" title="Dm-crypt/Encriptação de dispositivo">recolocar o cabeçalho do LUKS</a>. O valor é especificado em setores de 512-bytes, veja <span class="plainlinks archwiki-template-man" title="$ man 8 cryptsetup"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/cryptsetup.8">cryptsetup(8)</a></span> para mais detalhes.</div>
<p>Abra o container:
</p>
<pre># cryptsetup open --header cabecalho.img /dev/sdX enc
</pre>
<p>Agora siga a <a href="../pt/bd347841f13524ba6da3458e094be74d.html#Preparando_parti%C3%A7%C3%B5es_que_n%C3%A3o_s%C3%A3o_de_boot" class="mw-redirect" title="Dm-crypt/Criptografando todo um sistema">configuração LVM dentro do LUKS</a> para suas necessidades. O mesmo se aplica para <a href="../pt/bd347841f13524ba6da3458e094be74d.html#Preparando_a_parti%C3%A7%C3%A3o_de_boot_4" class="mw-redirect" title="Dm-crypt/Criptografando todo um sistema">preparando a partição de boot</a><sup>[<a href="../pt/Help:Procedures.html#Corrigir_links_quebrados_de_se%C3%A7%C3%B5es" class="mw-redirect" title="Help:Procedimentos">link quebrado</a>: seção inválida]</sup> no dispositivo removível (se não, não há lógica em ter um cabeçalho separado para abrir o disco criptografado).
Mova o <code>cabecalho.img</code> para ele:
</p>
<pre># mv cabecalho.img /mnt/boot
</pre>
<p>Siga o procedimento de instalação até o passo do mkinitcpio (você deve ter executado <code>arch-chroot</code> no sistema criptografado). 
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Dica:</strong> Você vai notar que a partição do sistema tem somente dados "randômicos", não tem tabela de partição e também não tem  um <code>UUID</code> ou <code>LABEL</code>. Mas você pode ainda ter um mapeamento persistente usando o <a href="../pt/Persistent_block_device_naming.html#by-id_e_by-path" class="mw-redirect" title="Nomeação persistente de dispositivo de bloco">Nomeação persistente de dispositivo de bloco#by-id e by-path</a>. Exemplo, usando o id do disco pelo <code>/dev/disk/by-id/</code>.</div>
<p>No initramfs, existem duas opções que suportam o cabeçalho do LUKS desanexado.
</p>
<h3><span class="mw-headline" id="Usando_o_hook_do_systemd">Usando o hook do systemd</span></h3>
<p>Primeiro crie <code>/etc/crypttab.initramfs</code> e adicione o dipositivo cripotgrafado nele. A sintaxe está definida em <span class="plainlinks archwiki-template-man" title="$ man 5 crypttab"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/crypttab.5">crypttab(5)</a></span>
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/crypttab.initramfs</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">enc	/dev/disk/by-id/<i>id_do_seu_disco</i>	none	header=/boot/cabecalho.img</pre>
<p>Modifique <code>/etc/mkinitcpio.conf</code> <a href="../pt/Mkinitcpio.html#Hooks_comuns" title="Mkinitcpio (Português)">para usar o systemd</a> e adicione o cabeçalho em <code>FILES</code>.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/mkinitcpio.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">...
FILES=(<b>/boot/cabecalho.img</b>)
...
HOOKS=(base <b>systemd</b> autodetect <b>keyboard</b> <b>sd-vconsole</b> modconf block <b>sd-encrypt</b> <b>sd-lvm2</b> filesystems fsck)
...</pre>
<p><a href="../pt/Mkinitcpio.html#Cria%C3%A7%C3%A3o_e_ativa%C3%A7%C3%A3o_de_imagem" class="mw-redirect" title="Gere novamente o initramfs">Gere novamente o initramfs</a> e pronto.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Nenhum parâmetro do cryptsetup precisa ser passado para a linha de comando do kernel, desde que <code>/etc/crypttab.initramfs</code> será adicionado como <code>/etc/crypttab</code> no initramfs. Se você deseja especificá-los na linha de comando do kernel veja <a href="../pt/5e279fa7d75b32c0232ab38e4294ae71.html#Usando_o_hook_sd-encrypt" class="mw-redirect" title="Dm-crypt/Configuração do sistema">dm-crypt/Configuração do sistema#Usando o hook sd-encrypt</a> para opções suportadas.</div>
<h3><span class="mw-headline" id="Modificando_o_hook_encrypt">Modificando o hook encrypt</span></h3>
<p>Este método mostra como modificar o hook <code>encrypt</code> para usá-lo com um cabeçalho do LUKS desanexado.
Agora o hook <code>encrypt</code> precisa ser modificado para deixar o <code>cryptsetup</code> usar o cabeçalho separado (<a rel="nofollow" class="external text" href="https://bugs.archlinux.org/task/42851">FS#42851</a>); A fonte base e ideia para estas mudanças foi <a rel="nofollow" class="external text" href="https://bbs.archlinux.org/viewtopic.php?pid=1076346#p1076346">publicada no BBS</a>). Faça uma cópia para que esta configuração não seja sobrescrevida em uma atualização do <a href="../pt/Mkinitcpio.html" title="Mkinitcpio (Português)">mkinitcpio</a>:
</p>
<pre># cp /usr/lib/initcpio/hooks/encrypt /etc/initcpio/hooks/encrypt2
# cp /usr/lib/initcpio/install/encrypt /etc/initcpio/install/encrypt2
</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/initcpio/hooks/encrypt2 (around line 52)</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">warn_deprecated() {
    echo "The syntax 'root=${root}' where '${root}' is an encrypted volume is deprecated"
    echo "Use 'cryptdevice=${root}:root root=/dev/mapper/root' instead."
}

<b>local headerFlag=false</b>
for cryptopt in ${cryptoptions//,/ }; do
    case ${cryptopt} in
        allow-discards)
            cryptargs="${cryptargs} --allow-discards"
            ;;  
        <b>header)
            cryptargs="${cryptargs} --header /boot/cabecalho.img"
            headerFlag=true
            ;;</b>
        *)  
            echo "Encryption option '${cryptopt}' not known, ignoring." &gt;&amp;2 
            ;;  
    esac
done

if resolved=$(resolve_device "${cryptdev}" ${rootdelay}); then
    if <b>$headerFlag || </b>cryptsetup isLuks ${resolved} &gt;/dev/null 2&gt;&amp;1; then
        [ ${DEPRECATED_CRYPT} -eq 1 ] &amp;&amp; warn_deprecated
        dopassphrase=1</pre>
<p>Agora edite o <a href="../pt/Mkinitcpio.html" title="Mkinitcpio (Português)">mkinitcpio.conf</a> para adicionar os hooks <code>encrypt2</code> e <code>lvm2</code>, o <code>cabecalho.img</code> para <code>FILES</code> e o <code>loop</code> para <code>MODULES</code>, fora outras configurações que o sistema precisa:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/mkinitcpio.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">...
MODULES=(<b>loop</b>)
...
FILES=(<b>/boot/cabecalho.img</b>)
...
HOOKS=(base udev autodetect <b>keyboard</b> <b>keymap</b> consolefont modconf block <b>encrypt2</b> <b>lvm2</b> filesystems fsck)
...</pre>
<p>Isto é necessário para que o cabeçalho do LUKS esteja disponível na inicialização, nos excluindo uma configuração mais complicada para montar um pendrive separado para acessar o cabeçalho. Depois disso, <a href="../pt/Mkinitcpio.html#Cria%C3%A7%C3%A3o_e_ativa%C3%A7%C3%A3o_de_imagem" class="mw-redirect" title="Gere novamente o initramfs">gere novamente o initramfs</a>.
</p>
<p>Depois, configure o <a href="../pt/bd347841f13524ba6da3458e094be74d.html#Configurando_o_gerenciador_de_boot_4" class="mw-redirect" title="Dm-crypt/Criptografando todo um sistema">gerenciador de boot</a> para especificar o <code>cryptdevice=</code> também passando a nova opção <code>header</code> para esta configuração: 
</p>
<pre>cryptdevice=/dev/disk/by-id/<i>id_do_seu_disco</i>:enc:header
</pre>
<p>Para finalizar, é útil seguir <a href="../pt/bd347841f13524ba6da3458e094be74d.html#P%C3%B3s-instala%C3%A7%C3%A3o" class="mw-redirect" title="Dm-crypt/Criptografando todo um sistema">dm-crypt/Criptografando todo um sistema#Pós-instalação</a> com uma partição <code>/boot</code> no dispositivo USB.
</p>
<h2>
<span id="Encrypted_.2Fboot_and_a_detached_LUKS_header_on_USB"></span><span class="mw-headline" id="Encrypted_/boot_and_a_detached_LUKS_header_on_USB">Encrypted /boot and a detached LUKS header on USB</span>
</h2>
<div class="noprint archwiki-template-message">
<p><a href="../File:Tango-view-refresh-red.png" class="image"><img alt="Tango-view-refresh-red.png" src="../File:Tango-view-refresh-red.png" decoding="async" width="48" height="48"></a><b>This article or section is out of date.</b><a href="../File:Tango-view-refresh-red.png" class="image"><img alt="Tango-view-refresh-red.png" src="../File:Tango-view-refresh-red.png" decoding="async" width="48" height="48"></a></p>
<div>
<b>Reason:</b> This scenario was based on <a rel="nofollow" class="external autonumber" href="https://wiki.archlinux.org/index.php?title=Dm-crypt/Encrypting_an_entire_system&amp;oldid=562642#Encrypted_boot_partition_(GRUB)">[5]</a>, whose structure was then changed with <a rel="nofollow" class="external autonumber" href="https://wiki.archlinux.org/index.php?title=Dm-crypt/Encrypting_an_entire_system&amp;diff=next&amp;oldid=562642">[6]</a>. (Discuss in <a rel="nofollow" class="external text" href="https://wiki.archlinux.org/index.php/Talk:Dm-crypt_(Portugu%C3%AAs)/Specialties_(Portugu%C3%AAs)#Encrypted_/boot_and_a_detached_LUKS_header_on_USB">Talk:Dm-crypt (Português)/Specialties (Português)#Encrypted /boot and a detached LUKS header on USB</a>)</div>
</div>
<p>Rather than embedding the <code>header.img</code> and keyfile into the <a href="../en/Arch_boot_process.html#initramfs" class="mw-redirect" title="Initramfs">initramfs</a> image, this setup will make your system depend entirely on the usb key rather than just the image to boot, and on the encrypted keyfile inside of the encrypted boot partition. Since the header and keyfile are not included in the <a href="../en/Arch_boot_process.html#initramfs" class="mw-redirect" title="Initramfs">initramfs</a> image and the custom encrypt hook is specifically for the usb's <a href="../en/Persistent_block_device_naming.html#by-id_and_by-path" title="Persistent block device naming">by-id</a>, you will literally need the usb key to boot.
</p>
<p>For the usb drive, since you are encrypting the drive and the keyfile inside, it is preferred to cascade the ciphers as to not use the same one twice. Whether a <a href="https://en.wikipedia.org/wiki/Meet-in-the-middle_attack" class="extiw" title="wikipedia:Meet-in-the-middle attack">meet-in-the-middle</a> attack would actually be feasible is debatable. You can do twofish-serpent or serpent-twofish.
</p>
<h3><span class="mw-headline" id="Preparing_the_disk_devices">Preparing the disk devices</span></h3>
<p><code>sdb</code> will be assumed to be the USB drive, <code>sda</code> will be assumed to be the main hard drive.
</p>
<p>Prepare the devices according to <a href="../en/Dm-crypt/Drive_preparation.html" title="Dm-crypt/Drive preparation">dm-crypt/Drive preparation</a>.
</p>
<h4><span class="mw-headline" id="Preparing_the_USB_key">Preparing the USB key</span></h4>
<p>Use <a href="../en/GPT_fdisk.html" class="mw-redirect" title="Gdisk">gdisk</a> to partition the disk according to the layout <a href="../en/Dm-crypt/Encrypting_an_entire_system.html#Preparing_the_disk_5" title="Dm-crypt/Encrypting an entire system">shown here</a>, with the exception that it should only include the first two partitions. So as follows:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># gdisk /dev/sdb</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Number  Start (sector)    End (sector)  Size       Code  Name
   1            2048         1050623   512.0 MiB   EF00  EFI System
   2         1050624         1460223   200.0 MiB   8300  Linux filesystem
</pre>
<p>Before running <code>cryptsetup</code>, look at the <a href="../en/Dm-crypt/Device_encryption.html#Encryption_options_for_LUKS_mode" title="Dm-crypt/Device encryption">Encryption options for LUKS mode</a> and <a href="../en/Data-at-rest_encryption.html#Ciphers_and_modes_of_operation" class="mw-redirect" title="Disk encryption">Ciphers and modes of operation</a> first to select your desired settings.
</p>
<p><a href="../en/Dm-crypt/Encrypting_an_entire_system.html#Preparing_the_boot_partition_5" title="Dm-crypt/Encrypting an entire system">Prepare the boot partition</a><sup>[<a href="../pt/Help:Procedures.html#Corrigir_links_quebrados_de_se%C3%A7%C3%B5es" class="mw-redirect" title="Help:Procedimentos">link quebrado</a>: seção inválida]</sup> but do not <code>mount</code> any partition yet and <a href="../en/EFI_system_partition.html#Format_the_partition" title="EFI system partition">Format the EFI system partition</a>.
</p>
<pre># mount /dev/mapper/cryptboot /mnt
# dd if=/dev/urandom of=/mnt/key.img bs=<i>filesize</i> count=1
# cryptsetup luksFormat /mnt/key.img
# cryptsetup open /mnt/key.img lukskey
</pre>
<p><i>filesize</i> is in bytes but can be followed by a suffix such as <code>M</code>. Having too small of a file will get you a nasty <code>Requested offset is beyond real size of device /dev/loop0</code> error. As a rough reference, creating a 4M file will encrypt it successfully. You should make the file larger than the space needed since the encrypted loop device will be a little smaller than the file's size.
</p>
<p>With a big file, you can use <code>--keyfile-offset=<i>offset</i></code> and <code>--keyfile-size=<i>size</i></code> to navigate to the correct position. <a rel="nofollow" class="external autonumber" href="https://wiki.gentoo.org/wiki/Custom_Initramfs#Encrypted_keyfile">[7]</a>
</p>
<p>Now you should have <code>lukskey</code> opened in a loop device (underneath <code>/dev/loop1</code>), mapped as <code>/dev/mapper/lukskey</code>.
</p>
<h4><span class="mw-headline" id="The_main_drive">The main drive</span></h4>
<pre># truncate -s 16M /mnt/header.img
# cryptsetup --key-file=/dev/mapper/lukskey --keyfile-offset=<i>offset</i> --keyfile-size=<i>size</i> luksFormat /dev/sda --offset 32768 --header /mnt/header.img
</pre>
<p>Pick an <i>offset</i> and <i>size</i> in bytes (8192 bytes is the maximum keyfile size for <code>cryptsetup</code>).
</p>
<pre># cryptsetup open --header /mnt/header.img --key-file=/dev/mapper/lukskey --keyfile-offset=<i>offset</i> --keyfile-size=<i>size</i> /dev/sda enc 
# cryptsetup close lukskey
# umount /mnt
</pre>
<p>Follow <a href="../en/Dm-crypt/Encrypting_an_entire_system.html#Preparing_the_logical_volumes" title="Dm-crypt/Encrypting an entire system">Preparing the logical volumes</a> to set up LVM on LUKS.
</p>
<p>See <a href="../pt/Partitioning.html#Parti%C3%A7%C3%B5es_discretas" class="mw-redirect" title="Particionamento">Particionamento#Partições discretas</a> for recommendations on the size of your partitions.
</p>
<p>Once your root partition is mounted, <code>mount</code> your encrypted boot partition as <code>/mnt/boot</code> and your EFI system partition as <code>/mnt/efi</code>.
</p>
<h3><span class="mw-headline" id="Installation_procedure_and_custom_encrypt_hook">Installation procedure and custom encrypt hook</span></h3>
<p>Follow the <a href="../en/Installation_guide.html" title="Installation guide">installation guide</a> up to the <code>mkinitcpio</code> step but do not do it yet, and skip the partitioning, formatting, and mounting steps as they have already been done.
</p>
<p>In order to get the encrypted setup to work, you need to build your own hook, which is thankfully easy to do and here is the code you need. You will have to follow <a href="../en/Persistent_block_device_naming.html#by-id_and_by-path" title="Persistent block device naming">Persistent block device naming#by-id and by-path</a> to figure out your own <code>by-id</code> values for the usb and main hard drive (they are linked -&gt; to <code>sda</code> or <code>sdb</code>).
</p>
<p>You should be using the <code>by-id</code> instead of just <code>sda</code> or <code>sdb</code> because <code>sdX</code> can change and this ensures it is the correct device.
</p>
<p>You can name <code>customencrypthook</code> anything you want, and custom build hooks can be placed in the <code>hooks</code> and <code>install</code> folders of <code>/etc/initcpio</code>. Keep a backup of both files (<code>cp</code> them over to the <code>/home</code> partition or your user's <code>/home</code> directory after you make one). <code>/usr/bin/ash</code> is not a typo.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/initcpio/hooks/customencrypthook</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">#!/usr/bin/ash

run_hook() {
    modprobe -a -q dm-crypt &gt;/dev/null 2&gt;&amp;1
    modprobe loop
    [ "${quiet}" = "y" ] &amp;&amp; CSQUIET="&gt;/dev/null"

    while [ ! -L '/dev/disk/by-id/<i>usbdrive</i>-part2' ]; do
     echo 'Waiting for USB'
     sleep 1
    done

    cryptsetup open /dev/disk/by-id/<i>usbdrive</i>-part2 cryptboot
    mkdir -p /mnt
    mount /dev/mapper/cryptboot /mnt
    cryptsetup open /mnt/key.img lukskey
    cryptsetup --header /mnt/header.img --key-file=/dev/mapper/lukskey --keyfile-offset=''offset'' --keyfile-size=''size'' open /dev/disk/by-id/<i>harddrive</i> enc
    cryptsetup close lukskey
    umount /mnt
}
</pre>
<p><code><i>usbdrive</i></code> is your USB drive <code>by-id</code>, and <code><i>harddrive</i></code> is your main hard drive <code>by-id</code>.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Tip:</strong> You could also close <code>cryptboot</code> using <code>cryptsetup close</code>, but having it open makes it easier to mount for system updates using <a href="../en/Pacman.html" title="Pacman">Pacman</a> and regenerating the initramfs with <a href="../pt/Mkinitcpio.html" title="Mkinitcpio (Português)">mkinitcpio</a>. The <code>/boot</code> partition must be mounted for updates that affect the <a href="../en/Kernel.html" title="Kernel">kernel</a> or <a href="../en/Arch_boot_process.html#initramfs" class="mw-redirect" title="Initramfs">Initramfs</a>, and the initramfs will be automatically regenerated after these updates.</div>
<pre># cp /usr/lib/initcpio/install/encrypt /etc/initcpio/install/customencrypthook
</pre>
<p>Now edit the copied file and remove the <code>help()</code> section as it is not necessary.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/mkinitcpio.conf (edit this only do not replace it, these are just excerpts of the necessary parts)</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">MODULES=(loop)
...
HOOKS=(base udev autodetect modconf block customencrypthook lvm2 filesystems keyboard fsck)</pre>
<p>The <code>files=()</code> and <code>binaries=()</code> arrays are empty, and you should not have to replace <code>HOOKS=(...)</code> array entirely just edit in <code>customencrypthook lvm2</code> after <code>block</code> and before <code>filesystems</code>, and make sure <code>systemd</code>, <code>sd-lvm2</code>, and <code>encrypt</code> are removed.
</p>
<h4><span class="mw-headline" id="Boot_Loader">Boot Loader</span></h4>
<p>Finish the <a href="../en/Installation_guide.html#Initramfs" title="Installation guide">Installation Guide</a> from the <code>mkinitcpio</code> step. To boot you would need either <a href="../pt/GRUB.html" title="GRUB (Português)">GRUB</a> or <a href="../en/Unified_Extensible_Firmware_Interface.html#efibootmgr" class="mw-redirect" title="Efibootmgr">efibootmgr</a>. Note you can use <a href="../pt/GRUB.html" title="GRUB (Português)">GRUB</a> to support the encrypted disks by <a href="../en/Dm-crypt/Encrypting_an_entire_system.html#Configuring_the_boot_loader_6" title="Dm-crypt/Encrypting an entire system">Configuring the boot loader</a><sup>[<a href="../pt/Help:Procedures.html#Corrigir_links_quebrados_de_se%C3%A7%C3%B5es" class="mw-redirect" title="Help:Procedimentos">link quebrado</a>: seção inválida]</sup> but editing the <code>GRUB_CMDLINE_LINUX</code> is not necessary for this set up.
</p>
<p>Or use Direct UEFI Secure boot by generating keys with <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/cryptboot/">cryptboot</a></span><sup><small>AUR</small></sup> then signing the initramfs and kernel and creating a bootable <i>.efi</i> file for your EFI system partition with <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/sbupdate-git/">sbupdate-git</a></span><sup><small>AUR</small></sup>. Before using cryptboot or sbupdate note this excerpt from <a href="../en/Unified_Extensible_Firmware_Interface/Secure_Boot.html#Using_your_own_keys" class="mw-redirect" title="Secure Boot">Secure Boot#Using your own keys</a>:
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Tip:</strong> Note that <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/cryptboot/">cryptboot</a></span><sup><small>AUR</small></sup> requires the encrypted boot partition to be specified in <code>/etc/crypttab</code> before it runs, and if you are using it in combination with <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/sbupdate-git/">sbupdate-git</a></span><sup><small>AUR</small></sup>, sbupdate expects the <code>/boot/efikeys/db.*</code> files created by cryptboot to be capitalized like <code>DB.*</code> unless otherwise configured in <code>/etc/default/sbupdate</code>. Users who do not use systemd to handle encryption may not have anything in their <code>/etc/crypttab</code> file and would need to create an entry.
</div>
<pre># efibootmgr -c -d /dev/<i>device</i> -p <i>partition_number</i> -L "Arch Linux Signed" -l "EFI\Arch\linux-signed.efi"
</pre>
<p>See <span class="plainlinks archwiki-template-man" title="$ man 8 efibootmgr"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/efibootmgr.8">efibootmgr(8)</a></span> for an explanation of the options.
</p>
<p>Make sure the boot order puts <code>Arch Linux Signed</code> first. If not change it with <code>efibootmgr -o XXXX,YYYY,ZZZZ</code>.
</p>
<h3><span class="mw-headline" id="Changing_the_LUKS_keyfile">Changing the LUKS keyfile</span></h3>
<div class="noprint archwiki-template-message">
<p><a href="../File:Merge-arrows-2.png" class="image"><img alt="Merge-arrows-2.png" src="../File:Merge-arrows-2.png" decoding="async" width="48" height="48"></a><b>This article or section is a candidate for merging with <a href="../en/Dm-crypt/Device_encryption.html#Keyfiles" title="Dm-crypt/Device encryption">dm-crypt/Device encryption#Keyfiles</a>.</b><a href="../File:Merge-arrows-2.png" class="image"><img alt="Merge-arrows-2.png" src="../File:Merge-arrows-2.png" decoding="async" width="48" height="48"></a></p>
<div>
<b>Notes:</b> Changing the keyfile is not a required action in this setup. (Discuss in <a rel="nofollow" class="external text" href="https://wiki.archlinux.org/index.php/Talk:Dm-crypt_(Portugu%C3%AAs)/Specialties_(Portugu%C3%AAs)">Talk:Dm-crypt (Português)/Specialties (Português)#</a>)</div>
</div>
<pre># cryptsetup --header /boot/header.img --key-file=/dev/mapper/lukskey --keyfile-offset=<i>offset</i> --keyfile-size=<i>size</i> luksChangeKey /dev/mapper/enc /dev/mapper/lukskey2 --new-keyfile-size=<i>newsize</i> --new-keyfile-offset=<i>newoffset</i>
</pre>
<p>Afterwards, <code>cryptsetup close lukskey</code> and <a href="../en/Securely_wipe_disk.html#shred" class="mw-redirect" title="Shred">shred</a> or <a href="../en/Securely_wipe_disk.html#dd" title="Securely wipe disk">dd</a> the old keyfile with random data before deleting it, then make sure that the new keyfile is renamed to the same name of the old one: <code>key.img</code> or other name.
</p>
</div>
</div>
<div id="catlinks" class="catlinks" data-mw="interface">
<div id="mw-normal-catlinks" class="mw-normal-catlinks">
<a href="../Special:Categories.html" title="Special:Categories">Category</a>: <ul><li><a href="../pt/Category:Data-at-rest_encryption.html" title="Category:Data-at-rest encryption (Português)">Data-at-rest encryption (Português)</a></li></ul>
</div>
<div id="mw-hidden-catlinks" class="mw-hidden-catlinks mw-hidden-cats-hidden">Hidden categories: <ul>
<li><a href="../pt/Category:Pages_or_sections_flagged_with_Template:Translateme.html" title="Category:Pages or sections flagged with Template:Translateme (Português)">Pages or sections flagged with Template:Translateme (Português)</a></li>
<li><a href="../en/Category:Pages_or_sections_flagged_with_Template:Accuracy.html" title="Category:Pages or sections flagged with Template:Accuracy">Pages or sections flagged with Template:Accuracy</a></li>
<li><a href="../en/Category:Pages_with_broken_section_links.html" title="Category:Pages with broken section links">Pages with broken section links</a></li>
<li><a href="../en/Category:Pages_or_sections_flagged_with_Template:Out_of_date.html" title="Category:Pages or sections flagged with Template:Out of date">Pages or sections flagged with Template:Out of date</a></li>
<li><a href="../en/Category:Pages_or_sections_flagged_with_Template:Merge.html" title="Category:Pages or sections flagged with Template:Merge">Pages or sections flagged with Template:Merge</a></li>
</ul>
</div>
</div>
	</div>
</div>

<footer id="footer" class="mw-footer" role="contentinfo" style="margin: 0">
	<ul id="footer-info">
		<li>Retrieved from "<a dir="ltr" href="https://wiki.archlinux.org/index.php?title=Dm-crypt_(Portugu%C3%AAs)/Specialties_(Portugu%C3%AAs)&amp;oldid=661509">https://wiki.archlinux.org/index.php?title=Dm-crypt_(Português)/Specialties_(Português)&amp;oldid=661509</a>"</li>
		<li id="footer-info-lastmod"> This page was last edited on 18 April 2021, at 09:42.</li>
		<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3 or later</a> unless otherwise noted.</li>
	<br>
</ul>
	<ul id="footer-places">
		<li id="footer-places-privacy"><a href="../en/ArchWiki:Privacy_policy.html" title="ArchWiki:Privacy policy">Privacy policy</a></li>
		<li id="footer-places-about"><a href="../en/ArchWiki:About.html" title="ArchWiki:About">About ArchWiki</a></li>
		<li id="footer-places-disclaimer"><a href="../en/ArchWiki:General_disclaimer.html" title="ArchWiki:General disclaimer">Disclaimers</a></li>
	</ul>
	<ul id="footer-icons" class="noprint">
		<li id="footer-copyrightico">
	</ul>
	<div style="clear: both;"></div>
</footer>



</body>
</html>
