<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<title>GRUB (Italiano) - ArchWiki</title>
<link rel="stylesheet" href="../ArchWikiOffline.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<meta name="generator" content="MediaWiki 1.35.0">
<meta name="referrer" content="no-referrer-when-downgrade">
<meta name="robots" content="noindex,follow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="/opensearch_desc.php" title="ArchWiki (en)">
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.archlinux.org/api.php?action=rsd">
<link rel="license" href="http://www.gnu.org/copyleft/fdl.html">
<link rel="alternate" type="application/atom+xml" title="ArchWiki Atom feed" href="/index.php?title=Special:RecentChanges&amp;feed=atom">
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-GRUB_Italiano rootpage-GRUB_Italiano skin-vector action-view skin-vector-legacy">
<div id="content" class="mw-body" role="main" style="margin: 0">
	<a id="top"></a>
	<div id="siteNotice" class="mw-body-content"></div>
	<div class="mw-indicators mw-body-content">
	</div>
	<h1 id="firstHeading" class="firstHeading" lang="en">GRUB (Italiano)</h1>
	<div id="bodyContent" class="mw-body-content">
		<div id="siteSub" class="noprint">From ArchWiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="#searchInput">Jump to search</a>
		<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<div class="warningbox">The printable version is no longer supported and may have rendering errors. Please update your browser bookmarks and please use the default browser print function instead.</div>
<div class="mw-parser-output">
<div class="archwiki-template-meta-related-articles-start">
<p>Articoli correlati</p>
<ul>
<li><a href="../it/GRUB_Legacy.html" title="GRUB Legacy (Italiano)">GRUB Legacy (Italiano)</a></li>
<li><a href="../en/Arch_boot_process.html" title="Arch boot process">Arch boot process</a></li>
<li><a href="../it/Partitioning.html#Master_Boot_Record" class="mw-redirect" title="Master Boot Record (Italiano)">Master Boot Record (Italiano)</a></li>
<li><a href="../en/Partitioning.html#GUID_Partition_Table" class="mw-redirect" title="GUID Partition Table">GUID Partition Table</a></li>
<li><a href="../it/Unified_Extensible_Firmware_Interface.html" title="Unified Extensible Firmware Interface (Italiano)">Unified Extensible Firmware Interface (Italiano)</a></li>
<li><a href="../en/GRUB/EFI_examples.html" class="mw-redirect" title="GRUB EFI Examples">GRUB EFI Examples</a></li>
</ul>
</div>
<div class="noprint archwiki-template-message">
<p><a href="../File:Tango-preferences-desktop-locale.png" class="image"><img alt="Tango-preferences-desktop-locale.png" src="../File:Tango-preferences-desktop-locale.png" decoding="async" width="48" height="48"></a><b>This article or section needs to be <a href="../en/ArchWiki:Contributing.html#Translating" title="ArchWiki:Contributing">translated</a>.</b><a href="../File:Tango-preferences-desktop-locale.png" class="image"><img alt="Tango-preferences-desktop-locale.png" src="../File:Tango-preferences-desktop-locale.png" decoding="async" width="48" height="48"></a></p>
<div>
<b>Notes:</b> L'articolo in lingua inglese è in fase di revisione: la versione italiana verrà aggiornata non appena tale revisione sarà terminata. (Discuss in <a rel="nofollow" class="external text" href="https://wiki.archlinux.org/index.php/Talk:GRUB_(Italiano)">Talk:GRUB (Italiano)#</a>)</div>
</div>
<p><a rel="nofollow" class="external text" href="https://www.gnu.org/software/grub/">GRUB</a>  - da non confondere con <a href="../it/GRUB_Legacy.html" title="GRUB Legacy (Italiano)">GRUB Legacy</a> - è la nuova versione del GRand Unified Bootloader. GRUB deriva da <a rel="nofollow" class="external text" href="https://www.nongnu.org/pupa/">PUPA</a>, un progetto di ricerca mirato al miglioramento di  GRUB Legacy: esso è stato infatti totalmente riscritto, ripulendo il codice assicurando al tempo stesso una maggior modularità e portabilità. <a rel="nofollow" class="external autonumber" href="https://www.gnu.org/software/grub/grub-faq.html#q1">[1]</a>
</p>
<p>In sintesi, il <i>bootloader</i> è il primo programma ad essere eseguito quando il computer si avvia. Ha il compito di caricare e trasferire il controllo al Kernel Linux, il quale, di contro, inizializza il resto del sistema operativo.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading">
<input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none"><div class="toctitle" lang="en" dir="ltr">
<h2 id="mw-toc-heading">Contents</h2>
<span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span>
</div>
<ul>
<li class="toclevel-1 tocsection-1">
<a href="#Prefazione"><span class="tocnumber">1</span> <span class="toctext">Prefazione</span></a>
<ul>
<li class="toclevel-2 tocsection-2">
<a href="#Note_per_gli_utenti_di_GRUB_Legacy"><span class="tocnumber">1.1</span> <span class="toctext">Note per gli utenti di GRUB Legacy</span></a>
<ul>
<li class="toclevel-3 tocsection-3"><a href="#Effetuare_un_backup_dei_dati_importanti"><span class="tocnumber">1.1.1</span> <span class="toctext">Effetuare un backup dei dati importanti</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-4">
<a href="#Prerequisiti_per_GRUB2"><span class="tocnumber">1.2</span> <span class="toctext">Prerequisiti per GRUB2</span></a>
<ul>
<li class="toclevel-3 tocsection-5">
<a href="#Sistemi_BIOS"><span class="tocnumber">1.2.1</span> <span class="toctext">Sistemi BIOS</span></a>
<ul>
<li class="toclevel-4 tocsection-6"><a href="#Istruzioni_specifiche_per_GUID_Partition_Table_(GPT)"><span class="tocnumber">1.2.1.1</span> <span class="toctext">Istruzioni specifiche per GUID Partition Table (GPT)</span></a></li>
<li class="toclevel-4 tocsection-7"><a href="#Istruzioni_specifiche_per_Master_Boot_Record_(MBR)"><span class="tocnumber">1.2.1.2</span> <span class="toctext">Istruzioni specifiche per Master Boot Record (MBR)</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-8">
<a href="#Sistemi_UEFI"><span class="tocnumber">1.2.2</span> <span class="toctext">Sistemi UEFI</span></a>
<ul>
<li class="toclevel-4 tocsection-9"><a href="#Controllare_se_si_sta_utilizzando_GPT_ed_una_partizione_EFI_di_sistema"><span class="tocnumber">1.2.2.1</span> <span class="toctext">Controllare se si sta utilizzando GPT ed una partizione EFI di sistema</span></a></li>
<li class="toclevel-4 tocsection-10"><a href="#Creazione_di_una_partizione_EFI_di_sistema"><span class="tocnumber">1.2.2.2</span> <span class="toctext">Creazione di una partizione EFI di sistema</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-11">
<a href="#Installazione"><span class="tocnumber">2</span> <span class="toctext">Installazione</span></a>
<ul>
<li class="toclevel-2 tocsection-12">
<a href="#Sistemi_BIOS_2"><span class="tocnumber">2.1</span> <span class="toctext">Sistemi BIOS</span></a>
<ul>
<li class="toclevel-3 tocsection-13">
<a href="#Installare_i_file_di_boot"><span class="tocnumber">2.1.1</span> <span class="toctext">Installare i file di boot</span></a>
<ul>
<li class="toclevel-4 tocsection-14"><a href="#Installazione_su_disco"><span class="tocnumber">2.1.1.1</span> <span class="toctext">Installazione su disco</span></a></li>
<li class="toclevel-4 tocsection-15"><a href="#Installazione_su_chiavetta_USB"><span class="tocnumber">2.1.1.2</span> <span class="toctext">Installazione su chiavetta USB</span></a></li>
<li class="toclevel-4 tocsection-16"><a href="#Installazione_su_una_partizione_o_su_un_disco_partitionless"><span class="tocnumber">2.1.1.3</span> <span class="toctext">Installazione su una partizione o su un disco partitionless</span></a></li>
<li class="toclevel-4 tocsection-17"><a href="#Generazione_del_solo_core.img"><span class="tocnumber">2.1.1.4</span> <span class="toctext">Generazione del solo core.img</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-2 tocsection-18">
<a href="#Sistemi_UEFI_2"><span class="tocnumber">2.2</span> <span class="toctext">Sistemi UEFI</span></a>
<ul>
<li class="toclevel-3 tocsection-19">
<a href="#Metodo_di_installazione_consigliato"><span class="tocnumber">2.2.1</span> <span class="toctext">Metodo di installazione consigliato</span></a>
<ul>
<li class="toclevel-4 tocsection-20"><a href="#Workaround_per_alcuni_firmware_UEFI"><span class="tocnumber">2.2.1.1</span> <span class="toctext">Workaround per alcuni firmware UEFI</span></a></li>
<li class="toclevel-4 tocsection-21"><a href="#Metodo_alternativo"><span class="tocnumber">2.2.1.2</span> <span class="toctext">Metodo alternativo</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-22"><a href="#Creare_una_voce_per_GRUB_nel_Firmware_Boot_Manager"><span class="tocnumber">2.2.2</span> <span class="toctext">Creare una voce per GRUB nel Firmware Boot Manager</span></a></li>
<li class="toclevel-3 tocsection-23">
<a href="#GRUB_Standalone"><span class="tocnumber">2.2.3</span> <span class="toctext">GRUB Standalone</span></a>
<ul>
<li class="toclevel-4 tocsection-24"><a href="#GRUB_Standalone_-_Informazioni_tecniche"><span class="tocnumber">2.2.3.1</span> <span class="toctext">GRUB Standalone - Informazioni tecniche</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-25">
<a href="#Generazione_del_file_di_configurazione_principale"><span class="tocnumber">3</span> <span class="toctext">Generazione del file di configurazione principale</span></a>
<ul>
<li class="toclevel-2 tocsection-26"><a href="#Conversione_del_file_di_configurazione_di_GRUB_Legacy_al_nuovo_formato"><span class="tocnumber">3.1</span> <span class="toctext">Conversione del file di configurazione di GRUB Legacy al nuovo formato</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-27">
<a href="#Configurazione_di_base"><span class="tocnumber">4</span> <span class="toctext">Configurazione di base</span></a>
<ul>
<li class="toclevel-2 tocsection-28"><a href="#Argomenti_aggiuntivi"><span class="tocnumber">4.1</span> <span class="toctext">Argomenti aggiuntivi</span></a></li>
<li class="toclevel-2 tocsection-29">
<a href="#Configurazione_dell'aspetto"><span class="tocnumber">4.2</span> <span class="toctext">Configurazione dell'aspetto</span></a>
<ul>
<li class="toclevel-3 tocsection-30"><a href="#Impostare_la_risoluzione_del_framebuffer"><span class="tocnumber">4.2.1</span> <span class="toctext">Impostare la risoluzione del framebuffer</span></a></li>
<li class="toclevel-3 tocsection-31"><a href="#Hack_915resolution"><span class="tocnumber">4.2.2</span> <span class="toctext">Hack 915resolution</span></a></li>
<li class="toclevel-3 tocsection-32"><a href="#Immagine_di_sfondo_e_caratteri_bitmap"><span class="tocnumber">4.2.3</span> <span class="toctext">Immagine di sfondo e caratteri bitmap</span></a></li>
<li class="toclevel-3 tocsection-33"><a href="#Temi"><span class="tocnumber">4.2.4</span> <span class="toctext">Temi</span></a></li>
<li class="toclevel-3 tocsection-34"><a href="#Colori_del_Men%C3%B9"><span class="tocnumber">4.2.5</span> <span class="toctext">Colori del Menù</span></a></li>
<li class="toclevel-3 tocsection-35"><a href="#Men%C3%B9_nascosto"><span class="tocnumber">4.2.6</span> <span class="toctext">Menù nascosto</span></a></li>
<li class="toclevel-3 tocsection-36"><a href="#Disabilitare_il_framebuffer"><span class="tocnumber">4.2.7</span> <span class="toctext">Disabilitare il framebuffer</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-37"><a href="#Nomenclatura_permanente_dei_dispositivi_a_blocchi"><span class="tocnumber">4.3</span> <span class="toctext">Nomenclatura permanente dei dispositivi a blocchi</span></a></li>
<li class="toclevel-2 tocsection-38"><a href="#Richiamare_l'ultimo_sistema_avviato"><span class="tocnumber">4.4</span> <span class="toctext">Richiamare l'ultimo sistema avviato</span></a></li>
<li class="toclevel-2 tocsection-39"><a href="#Cambiare_la_voce_di_menu_predefinita"><span class="tocnumber">4.5</span> <span class="toctext">Cambiare la voce di menu predefinita</span></a></li>
<li class="toclevel-2 tocsection-40"><a href="#Disabilitare_il_sottomenu"><span class="tocnumber">4.6</span> <span class="toctext">Disabilitare il sottomenu</span></a></li>
<li class="toclevel-2 tocsection-41"><a href="#Cifratura_della_partizione_root"><span class="tocnumber">4.7</span> <span class="toctext">Cifratura della partizione root</span></a></li>
<li class="toclevel-2 tocsection-42"><a href="#Effettuare_il_boot_di_una_voce_non_default_per_una_sola_volta"><span class="tocnumber">4.8</span> <span class="toctext">Effettuare il boot di una voce non default per una sola volta</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-43">
<a href="#Configurazione_avanzata"><span class="tocnumber">5</span> <span class="toctext">Configurazione avanzata</span></a>
<ul>
<li class="toclevel-2 tocsection-44"><a href="#Creazione_manuale_del_grub.cfg"><span class="tocnumber">5.1</span> <span class="toctext">Creazione manuale del grub.cfg</span></a></li>
<li class="toclevel-2 tocsection-45">
<a href="#Dual-booting"><span class="tocnumber">5.2</span> <span class="toctext">Dual-booting</span></a>
<ul>
<li class="toclevel-3 tocsection-46">
<a href="#Generazione_automatica_utilizzando_il_file_/etc/grub.d/40_custom_e_grub-mkconfig"><span class="tocnumber">5.2.1</span> <span class="toctext">Generazione automatica utilizzando il file /etc/grub.d/40_custom e grub-mkconfig</span></a>
<ul>
<li class="toclevel-4 tocsection-47"><a href="#Voce_di_men%C3%B9_per_GNU/Linux"><span class="tocnumber">5.2.1.1</span> <span class="toctext">Voce di menù per GNU/Linux</span></a></li>
<li class="toclevel-4 tocsection-48"><a href="#Voce_di_men%C3%B9_per_FreeBSD"><span class="tocnumber">5.2.1.2</span> <span class="toctext">Voce di menù per FreeBSD</span></a></li>
<li class="toclevel-4 tocsection-49"><a href="#Voce_di_men%C3%B9_per_Windows_XP"><span class="tocnumber">5.2.1.3</span> <span class="toctext">Voce di menù per Windows XP</span></a></li>
<li class="toclevel-4 tocsection-50"><a href="#Voce_di_men%C3%B9_per_Windows_installato_in_modalit%C3%A0_UEFI-GPT"><span class="tocnumber">5.2.1.4</span> <span class="toctext">Voce di menù per Windows installato in modalità UEFI-GPT</span></a></li>
<li class="toclevel-4 tocsection-51"><a href="#Voce_di_men%C3%B9_per_lo_spegnimento_del_sistema"><span class="tocnumber">5.2.1.5</span> <span class="toctext">Voce di menù per lo spegnimento del sistema</span></a></li>
<li class="toclevel-4 tocsection-52"><a href="#Voce_di_men%C3%B9_per_il_riavvio_del_sistema"><span class="tocnumber">5.2.1.6</span> <span class="toctext">Voce di menù per il riavvio del sistema</span></a></li>
<li class="toclevel-4 tocsection-53"><a href="#Windows_installato_in_modalit%C3%A0_BIOS-MBR"><span class="tocnumber">5.2.1.7</span> <span class="toctext">Windows installato in modalità BIOS-MBR</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-54"><a href="#Con_Windows_usando_EasyBCD_e_NeoGRUB"><span class="tocnumber">5.2.2</span> <span class="toctext">Con Windows usando EasyBCD e NeoGRUB</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-55"><a href="#Avviare_un'immagine_ISO9660_direttamente_da_GRUB"><span class="tocnumber">5.3</span> <span class="toctext">Avviare un'immagine ISO9660 direttamente da GRUB</span></a></li>
<li class="toclevel-2 tocsection-56"><a href="#LVM"><span class="tocnumber">5.4</span> <span class="toctext">LVM</span></a></li>
<li class="toclevel-2 tocsection-57"><a href="#RAID"><span class="tocnumber">5.5</span> <span class="toctext">RAID</span></a></li>
<li class="toclevel-2 tocsection-58"><a href="#Usare_le_etichette"><span class="tocnumber">5.6</span> <span class="toctext">Usare le etichette</span></a></li>
<li class="toclevel-2 tocsection-59"><a href="#Proteggere_con_una_password_il_menu_di_GRUB"><span class="tocnumber">5.7</span> <span class="toctext">Proteggere con una password il menu di GRUB</span></a></li>
<li class="toclevel-2 tocsection-60"><a href="#Nascondere_il_menu_di_GRUB_e_farlo_apparire_alla_pressione_del_tasto_Shift"><span class="tocnumber">5.8</span> <span class="toctext">Nascondere il menu di GRUB e farlo apparire alla pressione del tasto Shift</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-61"><a href="#Combinare_UUID_e_scripting"><span class="tocnumber">6</span> <span class="toctext">Combinare UUID e scripting</span></a></li>
<li class="toclevel-1 tocsection-62">
<a href="#Usare_la_shell"><span class="tocnumber">7</span> <span class="toctext">Usare la shell</span></a>
<ul>
<li class="toclevel-2 tocsection-63"><a href="#Supporto_al_Pager"><span class="tocnumber">7.1</span> <span class="toctext">Supporto al Pager</span></a></li>
<li class="toclevel-2 tocsection-64">
<a href="#Utilizzare_la_shell_dei_comanti_per_avviare_altri_sistemi_operativi"><span class="tocnumber">7.2</span> <span class="toctext">Utilizzare la shell dei comanti per avviare altri sistemi operativi</span></a>
<ul>
<li class="toclevel-3 tocsection-65"><a href="#Effettuare_il_chainloading_di_una_partizione"><span class="tocnumber">7.2.1</span> <span class="toctext">Effettuare il chainloading di una partizione</span></a></li>
<li class="toclevel-3 tocsection-66"><a href="#Effettuare_il_chainloading_di_un_disco/drive"><span class="tocnumber">7.2.2</span> <span class="toctext">Effettuare il chainloading di un disco/drive</span></a></li>
<li class="toclevel-3 tocsection-67"><a href="#Effettuare_il_chainloading_di_sistemi_Windows/Linux_installati_in_modalit%C3%A0_UEFI"><span class="tocnumber">7.2.3</span> <span class="toctext">Effettuare il chainloading di sistemi Windows/Linux installati in modalità UEFI</span></a></li>
<li class="toclevel-3 tocsection-68"><a href="#Avvio_normale"><span class="tocnumber">7.2.4</span> <span class="toctext">Avvio normale</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-69"><a href="#Tools_grafici_per_la_configurazione"><span class="tocnumber">8</span> <span class="toctext">Tools grafici per la configurazione</span></a></li>
<li class="toclevel-1 tocsection-70"><a href="#parttool_per_hide/unhide"><span class="tocnumber">9</span> <span class="toctext">parttool per hide/unhide</span></a></li>
<li class="toclevel-1 tocsection-71"><a href="#Usare_la_console_di_emergenza"><span class="tocnumber">10</span> <span class="toctext">Usare la console di emergenza</span></a></li>
<li class="toclevel-1 tocsection-72">
<a href="#Risoluzione_dei_problemi"><span class="tocnumber">11</span> <span class="toctext">Risoluzione dei problemi</span></a>
<ul>
<li class="toclevel-2 tocsection-73">
<a href="#Sistemi_con_BIOS_Intel_non_effettuano_il_boot_da_partizioni_GPT"><span class="tocnumber">11.1</span> <span class="toctext">Sistemi con BIOS Intel non effettuano il boot da partizioni GPT</span></a>
<ul>
<li class="toclevel-3 tocsection-74"><a href="#MBR"><span class="tocnumber">11.1.1</span> <span class="toctext">MBR</span></a></li>
<li class="toclevel-3 tocsection-75"><a href="#EFI"><span class="tocnumber">11.1.2</span> <span class="toctext">EFI</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-76"><a href="#Abilitare_i_messaggi_di_debug_in_GRUB"><span class="tocnumber">11.2</span> <span class="toctext">Abilitare i messaggi di debug in GRUB</span></a></li>
<li class="toclevel-2 tocsection-77"><a href="#Correggere_l'errore_di_GRUB_%22no_suitable_mode_found%22"><span class="tocnumber">11.3</span> <span class="toctext">Correggere l'errore di GRUB "no suitable mode found"</span></a></li>
<li class="toclevel-2 tocsection-78"><a href="#messaggio_d'errore_msdos-style"><span class="tocnumber">11.4</span> <span class="toctext">messaggio d'errore msdos-style</span></a></li>
<li class="toclevel-2 tocsection-79"><a href="#GRUB_UEFI_torna_alla_shell"><span class="tocnumber">11.5</span> <span class="toctext">GRUB UEFI torna alla shell</span></a></li>
<li class="toclevel-2 tocsection-80"><a href="#GRUB_UEFI_non_viene_caricato"><span class="tocnumber">11.6</span> <span class="toctext">GRUB UEFI non viene caricato</span></a></li>
<li class="toclevel-2 tocsection-81"><a href="#Invalid_signature"><span class="tocnumber">11.7</span> <span class="toctext">Invalid signature</span></a></li>
<li class="toclevel-2 tocsection-82"><a href="#Freeze_al_boot"><span class="tocnumber">11.8</span> <span class="toctext">Freeze al boot</span></a></li>
<li class="toclevel-2 tocsection-83"><a href="#Ripristinare_GRUB_Legacy"><span class="tocnumber">11.9</span> <span class="toctext">Ripristinare GRUB Legacy</span></a></li>
<li class="toclevel-2 tocsection-84"><a href="#Arch_non_rilevata_da_altre_distribuzioni"><span class="tocnumber">11.10</span> <span class="toctext">Arch non rilevata da altre distribuzioni</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-85"><a href="#Riferimenti"><span class="tocnumber">12</span> <span class="toctext">Riferimenti</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="Prefazione">Prefazione</span></h2>
<ul><li>Il nome <i>GRUB</i> si riferisce ufficialmente alla versione 2 del software (si veda <a rel="nofollow" class="external autonumber" href="https://www.gnu.org/software/grub/">[2]</a>). Se si sta cercando l'articolo relativo alla versione Legacy, si veda <a href="../it/GRUB_Legacy.html" title="GRUB Legacy (Italiano)">GRUB Legacy</a>.</li></ul>
<ul><li>E' supportato l'uso del filesystem <a href="../en/Btrfs.html" title="Btrfs">Btrfs</a> per la root (eliminando quindi la necessità di una partizione /boot separata con un filesystem diverso). Sono inoltre supportati gli algoritmi di compressione zlib o LZO.</li></ul>
<ul><li>GRUB non supporta partizioni root formattate in <a href="../en/F2FS.html" title="F2FS">F2FS</a>, perciò sarà necessario creare una partizione <code>/boot</code> separata usando un filesystem supportato.</li></ul>
<h3><span class="mw-headline" id="Note_per_gli_utenti_di_GRUB_Legacy">Note per gli utenti di GRUB Legacy</span></h3>
<ul><li>Aggiornare <a href="../it/GRUB_Legacy.html" title="GRUB Legacy (Italiano)">GRUB Legacy</a> a <a href="../it/GRUB.html" class="mw-redirect" title="GRUB2 (Italiano)">GRUB</a>(2) è un procedimento molto simile ad un installazione ex-novo di GRUB2, argomento trattato <a href="#Installazione">qui</a>.</li></ul>
<ul>
<li>Vi sono differenze nei comandi di GRUB e GRUB2. Si consiglia di familiarizzare con i <a rel="nofollow" class="external text" href="https://www.gnu.org/software/grub/manual/grub.html#Commands">comandi di GRUB2</a> prima di procedere. (ad esempio, "find" è stato rimpiazzato da "search").</li>
<li>GRUB2 è ora <i>modulare</i> e non richiede più lo "stage 1.5". Di conseguenza, il bootloader dispone di capacità limitate e i moduli sono caricati dal disco rigido in caso di necessità (ad esempio, se si necessita del supporto <a href="../it/LVM.html" title="LVM (Italiano)">LVM</a> o RAID).</li>
<li>La modalità di nomenclatura dei dispositivi è cambiata da GRUB a GRUB2: gli hard disk sono ancora numerati a partire da 0, mentre le partizioni partono da 1 e sono seguite dal nome del sistema di partizionamento usato. Ad esempio, a <code>/dev/sda1</code> corrisponde <code>(hd0,msdos1)</code> (per sistemi che usano MBR) o <code>(hd0,gpt1)</code> (per sistemi GPT).</li>
<li>GRUB occupa molto più spazio rispetto a GRUB Legacy (circa 13Mb di spazio occupato in <code>/boot</code>). Se si effettua il boot da una partizione <code>/boot</code> separata con una dimensione inferiore ai 32 Mb si avranno problemi di spazio e pacman si rifiuterà di installare eventuali nuovi kernel, ad esempio.</li>
</ul>
<h4><span class="mw-headline" id="Effetuare_un_backup_dei_dati_importanti">Effetuare un backup dei dati importanti</span></h4>
<p>In genere, l'installazione di grub dovrebbe andare a buon fine, ma è consigliabile conservare i files di GRUB-legacy prima di installare <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=grub">grub</a></span>.
</p>
<pre>mv /boot/grub /boot/grub-legay
</pre>
<p>Effettuare il backup del MBR che contiene il boot code e la tabella partizioni (Si sostituisca <code>/dev/sdX</code> con l'identificativo del proprio disco):
</p>
<pre># dd if=/dev/sdX of=/path/to/backup/mbr_backup bs=512 count=1
</pre>
<p>Solamente i primi 446 bytes del MBR contengono il boot code, mentre i restanti 64 sono dedicati alla tabella delle partizioni. Se non si desidera sovrascriverla durante un eventuale ripristino, è fortemente consigliato effettuare il backup del solo boot code:
</p>
<pre># dd if=/dev/sdX of=/path/to/backup/bootcode_backup bs=446 count=1
</pre>
<p>Se non si è stati in grado di installare GRUB2 correttamente, si veda <a href="#Ripristinare_GRUB_Legacy">#Ripristinare GRUB Legacy</a>
</p>
<h3><span class="mw-headline" id="Prerequisiti_per_GRUB2">Prerequisiti per GRUB2</span></h3>
<h4><span class="mw-headline" id="Sistemi_BIOS">Sistemi BIOS</span></h4>
<h5>
<span id="Istruzioni_specifiche_per_GUID_Partition_Table_.28GPT.29"></span><span class="mw-headline" id="Istruzioni_specifiche_per_GUID_Partition_Table_(GPT)">Istruzioni specifiche per GUID Partition Table (GPT)</span>
</h5>
<p>Su sistemi <a href="../en/Partitioning.html#GUID_Partition_Table" class="mw-redirect" title="GPT">GPT</a> è necessario creare una <a rel="nofollow" class="external text" href="https://www.gnu.org/software/grub/manual/html_node/BIOS-installation.html">partizione di boot BIOS</a> dove GRUB possa inserire il proprio <code>core.img</code>
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> 
<ul>
<li>Prima di provare questo metodo si tenga presente che non tutti i sistemi supportano questa configurazione. Ulteriori informazioni sulle <a href="../en/Partitioning.html#BIOS_systems" class="mw-redirect" title="GUID Partition Table">tabelle partizioni GUID</a><sup>[<a href="../en/Help:Procedures.html#Fix_broken_section_links" title="Help:Procedures">broken link</a>: invalid section]</sup>.</li>
<li>La partizione in questione è necessaria solo per le combinazioni BIOS/GPT. In precedenza, su schemi di partizionamento BIOS/MBR, GRUB utilizzava il <i>post-MBR gap</i> per inserire il proprio <code>core.img</code>. GRUB per GPT non utilizza tale spazio per rispettare le specifiche GPT sull'allineamento tra le partizioni (1 Mebibyte/2048 settori).</li>
<li>Su sistemi <a href="../it/Unified_Extensible_Firmware_Interface.html" title="Unified Extensible Firmware Interface (Italiano)">UEFI</a> tale partizione non è richiesta in quanto in questo caso non si verifica l'<i>embedding</i> dei settori di boot.</li>
</ul>
</div>
<p>Si crei una partizione da un mebibyte (<code>+1MiB</code> con <code>gdisk</code>) su un disco senza filesystem e le si assegni il tipo <code>ef02</code> (oppure <code>bios_grub</code> se si utilizza <code>parted</code>). Si noti che la partizione può trovare in qualsiasi posizione entro i primi 2 TiB del disco e deve essere creata prima dell'installazione.
Una volta creata la aprtizione, si installi il bootloader seguendo le istruzioni sotto e assicurarsi di specificare l'opzione <code>--target=i386-pc</code> (altrimentri GRUB potrebbe pensare di trovarsi su un sistema EFI-GPT).
</p>
<p>È possibile utilizzare il <i>post-MBR gap</i> come partizione di boot BIOS, anche se tale operazione non rispetta le specifiche GPT sull'allineamento delle partizioni. Dal momento che il contenuto di tale partizione non verrà letto spesso è possibile ignorare l'impatto sulle prestazioni, anche se alcune utility per il partizionamento visualizzeranno un messaggio d'avvertimento. In <code>gdisk</code> si crei una <b>n</b>uova partizione che inizia al settore 34 e arriva al 2047, e le si assegni il tipo. Per fare in modo che le partizioni visibili partano dall'inizio, si crei questa partizione per ultima.
</p>
<h5>
<span id="Istruzioni_specifiche_per_Master_Boot_Record_.28MBR.29"></span><span class="mw-headline" id="Istruzioni_specifiche_per_Master_Boot_Record_(MBR)">Istruzioni specifiche per Master Boot Record (MBR)</span>
</h5>
<p>Solitamente, il gap dopo il <a href="../it/Partitioning.html#Master_Boot_Record" class="mw-redirect" title="Master Boot Record (Italiano)">MBR</a> (dopo i 512 byte ad esso dedicati, e prima dell'inizio della prima partizione), è di  31 KiB, quando eventuali problemi di allineamento dei cilindri sono risolti nella tabella partizioni. Tuttavia, è consigliato mantenere un gap di circa 1 MiB per fornire sufficiente spazio al <code>core.img</code> di GRUB. (<a rel="nofollow" class="external text" href="https://bugs.archlinux.org/task/24103">FS#24103</a>). È consigliabile usare un tool di partizionamento che supporti l'allineamento partizioni di 1 MiB dopo l'MBR per ottenere lo spazio necessario, e risolvere di conseguenza altri problemi, comunque non relativi all'embedding di <code>core.img</code>.
</p>
<h4><span class="mw-headline" id="Sistemi_UEFI">Sistemi UEFI</span></h4>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Per ulteriori informazioni su GRUB2 UEFI, è consigliabile leggere le pagine <a href="../it/Unified_Extensible_Firmware_Interface.html" title="Unified Extensible Firmware Interface (Italiano)">UEFI</a>, <a href="../en/Partitioning.html#GUID_Partition_Table" class="mw-redirect" title="GPT">GPT</a> e <a href="../en/Arch_boot_process.html#Boot_loader" class="mw-redirect" title="Boot loader">Boot loader</a> prima di proseguire con questo articolo.</div>
<h5><span class="mw-headline" id="Controllare_se_si_sta_utilizzando_GPT_ed_una_partizione_EFI_di_sistema">Controllare se si sta utilizzando GPT ed una partizione EFI di sistema</span></h5>
<p>È necessaria una partizione EFI di sistema (<i>ESP</i>) in ogni disco fisso dal quale si desideri effettuare il boot in modalità EFI. GPT non è strettamente necessario, ma ne è raccomandato l'utilizzo, in quanto è l'unico metodo supportato da questo articolo.
</p>
<p>Se si sta installando Arch Linux su un PC con supporto EFI dove sia già stato installato un altro sistema operativo, è probabile che si disponga già di una ESP. Si controlli utilizzando <code>parted</code> per stampare la tabella partizioni del disco dal quale si effettua il boot (nell'esempio si utilizzerà <code>/dev/sda</code>):
</p>
<pre># parted /dev/sda print
</pre>
<p>Se si utilizza GPT, il comando dovrebbe riportare <code>Partition Table: GPT</code>. Per EFI, invece, individuare una piccola partizione (512 MiB o meno) con filesystem <code>vfat</code> e il flag <code>boot</code> attivo contenente una cartella chiamata <i>EFI</i>. In caso i criteri di cui sopra vengano soddisfatti, ricordarsi del numero assegnato alla partizione, in quanto sarà necessario per identificare la stessa quando dovrà essere montata per l'installazione di GRUB.
</p>
<h5><span class="mw-headline" id="Creazione_di_una_partizione_EFI_di_sistema">Creazione di una partizione EFI di sistema</span></h5>
<p>Se non si dispone di una ESP, sarà necesario crearla. Si veda <a href="../en/Unified_Extensible_Firmware_Interface.html#EFI_System_Partition" title="Unified Extensible Firmware Interface">Unified Extensible Firmware Interface#EFI System Partition</a><sup>[<a href="../en/Help:Procedures.html#Fix_broken_section_links" title="Help:Procedures">broken link</a>: invalid section]</sup> per le istruzioni su come procedere.
</p>
<h2><span class="mw-headline" id="Installazione">Installazione</span></h2>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Se si sta <a href="../it/Installation_guide.html" title="Installation guide (Italiano)">installando</a> Arch Linux da LiveCD assicurarsi di aver effettuato il chroot nel sistema appena installato prima di installare GRUB: se si utilizzano gli script di installazione contenuti nel LiveCD potrebbe venir generato un <code>grub.cfg</code> errato o potrebbero verificarsi altri problemi che non consentirebbero al sistema di avviarsi.</div>
<h3><span class="mw-headline" id="Sistemi_BIOS_2">Sistemi BIOS</span></h3>
<p>E' possibile <a href="../it/Pacman.html" title="Pacman (Italiano)">installare</a> GRUB attraverso il pacchetto <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=grub">grub</a></span>, il quale sostituirà <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/grub-legacy/">grub-legacy</a></span><sup><small>AUR</small></sup>, se installato.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> La sola installazione del pacchetto non aggiornerà il file <code>/boot/grub/i386-pc/core.img</code> o i moduli di GRUB2 in <code>/boot/grub</code>. È necessario aggiornare il <code>core.img</code> e i moduli manualmente usando <code>grub-install</code>, come spiegato sotto.</div>
<h4><span class="mw-headline" id="Installare_i_file_di_boot">Installare i file di boot</span></h4>
<p>Ci sono quattro modi per installare i files di boot di GRUB su sistemi BIOS
</p>
<ul>
<li>
<a href="#Installazione_su_disco">Installazione su disco</a> (consigliata)</li>
<li>
<a href="#Installazione_su_chiavetta_USB">Installazione su chiavetta USB</a> (per ripristino)</li>
<li>
<a href="#Installazione_su_una_partizione_o_su_un_disco_partitionless">Installazione su una partizione o su un disco partitionless</a> (sconsigliata)</li>
<li>
<a href="#Generazione_del_solo_core.img">Generazione del solo core.img</a> (metodo più sicuro, ma richiede un altro bootloader come <a href="../it/GRUB_Legacy.html" title="GRUB Legacy (Italiano)">GRUB Legacy</a> o <a href="../en/Syslinux.html" title="Syslinux">Syslinux</a>, che effettui il chainload di <code>/boot/grub/i386-pc/core.img</code>).</li>
</ul>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Si consulti <a rel="nofollow" class="external free" href="https://www.gnu.org/software/grub/manual/html_node/BIOS-installation.html">https://www.gnu.org/software/grub/manual/html_node/BIOS-installation.html</a> per ulteriori informazioni.</div>
<h5><span class="mw-headline" id="Installazione_su_disco">Installazione su disco</span></h5>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Questo metodo tratta l'installazione di GRUB in un disco già partizionato (con MBR o GPT), GRUB installato in <code>/boot/grub</code> e il relativo codice installato nella regione di 440 byte del MBR (non è da confondere con la tabella partizioni MBR). Per l'installazione su dischi partitionless (super-floppy), si faccia riferimento a <a href="#Installazione_su_una_partizione_o_su_un_disco_partitionless">#Installazione su una partizione o su un disco partitionless</a>.</div>
<p>Per installare <code>grub</code> nella regione di 440 byte relativa al boot code, chiamata anche Master Boot Record, popolare la directory <code>/boot/grub</code>, generare il <code>/boot/grub/i386-pc/core.img</code> e inserirlo nel gap di 31KiB (la dimensione varia a seconda dell'allineamento delle partizioni) post-MBR (o nella partizione di boot del BIOS nel caso di sistemi partizionati con GPT, identificata tramite il flag <code>grub_bios</code> in parted e con il codice <code>EF02</code> in gdisk) si esegua:
</p>
<pre># grub-install --target=i386-pc --recheck --debug /dev/sd<i>x</i>
# grub-mkconfig -o /boot/grub/grub.cfg
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> L'opzione <code>--target=i386-pc</code> indica a <code>grub-install</code> di effettuare un'installazione per sistemi BIOS, ed è consigliato specificarla sempre per evitare ambiguità durante l'installazione.</div>
<p>Se si utilizza <a href="../it/LVM.html" title="LVM (Italiano)">LVM</a> per la propria partizione di <code>/boot</code>, è possibile installare GRUB su più dischi fissi.
</p>
<h5><span class="mw-headline" id="Installazione_su_chiavetta_USB">Installazione su chiavetta USB</span></h5>
<p>Si assuma che la prima partizione della propria chiavetta USB sia formattata in FAT32 e che tale partizione sia <code>/dev/sdy1</code>:
</p>
<pre>#  mkdir -p /mnt/usb ; mount /dev/sdy1 /mnt/usb 
# grub-install --target=i386-pc --recheck --debug --boot-directory=/mnt/usb/boot /dev/sdy
# grub-mkconfig -o /mnt/usb/boot/grub/grub.cfg
</pre>
<pre># opzionale, backup dei file di configurazione per grub.cfg
# mkdir -p /mnt/usb/etc/default
# cp /etc/default/grub /mnt/usb/etc/default
# cp -a /etc/grub.d /mnt/usb/etc
</pre>
<pre>#  sync ; umount /mnt/usb
</pre>
<h5><span class="mw-headline" id="Installazione_su_una_partizione_o_su_un_disco_partitionless">Installazione su una partizione o su un disco partitionless</span></h5>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> GRUB non incoraggia gli utenti ad effettuare l'installazione nel boot sector di una partizione o su un disco partitionless, al contrario di quanto fanno GRUB Legacy o syslinux. Questa opzione non è consigliata nemmeno dagli sviluppatori di Arch Linux.</div>
<p>Per installare GRUB nel boot sector di una partizione o su un disco senza partizioni (es. superfloppy), si esegua (si assume che il dispositivo sia <code>/dev/sdaX</code> e che corrisponda alla partizione di <code>/boot</code>):
</p>
<pre># chattr -i /boot/grub/i386-pc/core.img
# grub-install --target=i386-pc --recheck --debug --force /dev/sdaX
# chattr +i /boot/grub/i386-pc/core.img</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> 
<ul>
<li>
<code>/dev/sda</code> viene usato a titolo di esempio: sostituirlo con il valore corretto in caso fosse diverso.</li>
<li>L'opzione <code>--target=i386-pc</code> indica a <code>grub-install</code> di effettuare un'installazione per sistemi BIOS, ed è consigliato specificarla sempre per evitare ambiguità durante l'installazione.</li>
</ul>
</div>
<p>Sarà necessaria l'opzione <code>--force</code> per consentire l'uso delle blocklists, mentre non si dovrà usare <code>--grub-setup=/bin/true</code>, che equivale a generare il solo <code>core.img</code>.
</p>
<p>Si riceveranno dei messaggi d'avvertimento che servono a spiegare i rischi di questo approccio:
</p>
<pre>/sbin/grub-setup: warn: Attempting to install GRUB to a partitionless disk or to a partition.  This is a BAD idea.
/sbin/grub-setup: warn: Embedding is not possible.  GRUB can only be installed in this setup by using blocklists. 
However, blocklists are UNRELIABLE and their use is discouraged.
</pre>
<p>Senza l'opzione <code>--force</code>, si riceverà il esguente errore e <code>grub-setup</code> non installerà il proprio codice nel MBR.
</p>
<pre>/sbin/grub-setup: error: will not proceed with blocklists
</pre>
<p>Specificando <code>--force</code>, invece, si dovrebbe ottenere:
</p>
<pre>Installation finished. No error reported.
</pre>
<p><code>grub-setup</code> non effettua automaticamente questa operazione in caso di installazione del boot loader su una partizione, oppure su un disco partitionless, poichè lo stesso fa affidamento sulle embedded blocklists nel settore di boot della partizione per individuare il <code>/boot/grub/i386-pc/core.img</code> e il percorso della directory <code>/boot/grub</code>. I settori contenenti i files sopra menzionati potrebbero cambiare in caso di alterazione della partizione (in caso di copia o eliminazione di files, eccetera). Per ulteriori informazioni si veda <a rel="nofollow" class="external free" href="https://bugzilla.redhat.com/show_bug.cgi?id=728742">https://bugzilla.redhat.com/show_bug.cgi?id=728742</a>.
</p>
<p>La soluzione proposta è quella di impostare il flag immutable al <code>/boot/grub/i386-pc/core.img</code>, in modo che la posizione del <code>core.img</code> sul disco non venga alterata. Tale flag deve essere impostata solo se <code>grub</code> viene installato su una partizione o su un disco partitionless, e NON in caso di semplice installazione nel MBR o di generazione del <code>core.img</code>.
</p>
<p>Sfortunatamente il <code>grub.cfg</code> generato non contiene gli UUID corretti, anche se non viene visualizzato nessun messaggio di errore (si veda <a rel="nofollow" class="external free" href="https://bbs.archlinux.org/viewtopic.php?pid=1294604#p1294604">https://bbs.archlinux.org/viewtopic.php?pid=1294604#p1294604</a>)
</p>
<p>Per risolvere il problema si esegua:
</p>
<pre># mount /dev/sdxY /mnt        # Partizione root
# mount /dev/sdxZ /mnt/boot  # Partizione /boot (se in uso)
# arch-chroot /mnt
# pacman -S linux
# grub-mkconfig -o /boot/grub/grub.cfg
</pre>
<h5><span class="mw-headline" id="Generazione_del_solo_core.img">Generazione del solo core.img</span></h5>
<p>Per popolare la directory <code>/boot/grub</code> e generare un <code>/boot/grub/i386-pc/core.img</code> SENZA installare GRUB nel MBR, si aggiunga <code>--grub-setup=/bin/true</code> a <code>grub-install</code>:
</p>
<pre># modprobe dm-mod
# grub-install --target=i386-pc --grub-setup=/bin/true --recheck --debug /dev/sda
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> 
<ul>
<li>
<code>/dev/sda</code> viene usato a titolo di esempio: sostituirlo con il valore corretto in caso fosse diverso.</li>
<li>L'opzione <code>--target=i386-pc</code> indica a <code>grub-install</code> di effettuare un'installazione per sistemi BIOS, ed è consigliato specificarla sempre per evitare ambiguità durante l'installazione.</li>
</ul>
</div>
<p>Sarà quindi possibile effettuare il chainload del <code>core.img</code> di GRUB da GRUB Legacy o da syslinux come fosse un kernel Linux o un kernel multiboot.
</p>
<h3><span class="mw-headline" id="Sistemi_UEFI_2">Sistemi UEFI</span></h3>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> I firmware UEFI non sono implementati in modo consistente tra i vari produttori di hardware. Gli esempi proposti di seguito sono pensati per funzionare con il maggior numero possibile di sistemi UEFI. Se si dovessero riscontrare problemi nonostante si siano seguiti i passaggi è consigliabile raccogliere informazioni dettagliate sulla propria configurazione hardware, specialmente quando si riesce a risolvere il problema. A questo scopo, è stata creata una pagina con <a href="../en/GRUB/EFI_examples.html" class="mw-redirect" title="GRUB EFI Examples">esempi per GRUB EFI</a>.</div>
<p>Si installino i pacchetti <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=grub">grub</a></span>, <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=dosfstools">dosfstools</a></span> (per la manipolazione di partizioni UEFI dopo l'installazione) ed <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=efibootmgr">efibootmgr</a></span> (per la creazione di file <code>.efi</code> avviabili, utilizzati dallo script di installazione di GRUB).
</p>
<p>La semplice installazione del pacchetto non aggiornerà il file <code>core.efi</code> e il moduli di GRUB nella partizione UEFI. Sarà necessario aggiornarli manualmente usando lo script di installazione di GRUB, come spiegato sotto.
</p>
<h4><span class="mw-headline" id="Metodo_di_installazione_consigliato">Metodo di installazione consigliato</span></h4>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> I comandi seguenti assumono che si stia installando GRUB su sistemi a 64 bit. (<code>x86_64-efi</code>) Per sistemi i686 si sostituisca ogni occorrenza di <code>x86_64-efi</code> con <code>i386-efi</code>. Sarà inoltre necessario assicurarsi che il supporto di installazione sia stato avviato in modalità UEFI e non Legacy, altrimente l'installazione potrebbe non andare a buon fine.</div>
<p>Assicurarsi che la partizione UEFI sia stata montata (ad esempio creata come <code>/boot</code> o <code>/boot/efi</code>). GRUB non pone limitazioni sul punto di mount della partizione, perciò si è liberi di scegliere quello che si preferisce. Una volta montata la partizione, si esegua il comando di cui sotto per installare l'applicazione UEFI di GRUB in <code>$esp/EFI/grub</code>, installarne i moduli in <code>/boot/grub/x86_64-efi</code> e copiare l'immagine avviabile <code>grubx64.efi</code> in <code>$esp/EFI/arch_grub</code>:
</p>
<pre># grub-install --target=x86_64-efi --efi-directory=$esp --bootloader-id=arch_grub --recheck --debug
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> 
<ul>
<li>Se si riscontrano problemi nell'utilizzo di <code>grub-install</code> e lo script ci consiglia di caricare il modulo efivars, si provi con <a href="../en/Unified_Extensible_Firmware_Interface.html#Switch_to_efivarfs" title="Unified Extensible Firmware Interface">Unified Extensible Firmware Interface#Switch_to_efivarfs</a><sup>[<a href="../en/Help:Procedures.html#Fix_broken_section_links" title="Help:Procedures">broken link</a>: invalid section]</sup>
</li>
<li>Se si sta installando GRUB in un ambiente chroot su un sistema che utilizza LVM è possibile che vengano visualizzati messaggi simili a questo: <code>/run/lvm/lvmetad.socket: connect failed: No such file or directory</code> o <code>WARNING: failed to connect to lvmetad: No such file or directory. Falling back to internal scanning.</code>.</li>
</ul>
<p>Questi messaggi sono causati dalla mancanza della directory <code>/run</code> nell'ambiente di chroot ma non pregiudicano l'avvio del sistema, percui è possibile proseguire tranquillamente con l'installazione.
</p>
<ul>
<li>Se non vengono specificate le opzioni <code>--target</code> o <code>--directory</code>, <code>grub-install</code> non riuscirà a determinare il tipo di firmware sul quale GRUB verrà installato, mostrando perciò il seguente messaggio d'errore: <code>source_dir doesn't exist. Please specify --target or --directory</code>.</li>
<li>Le opzioni <code>--efi-directory</code> e <code>--botloader-id</code> sono specifiche di GRUB UEFI. <code>--efi-directory</code> indica il punto di  mount della partizione EFI di sistema e sostituisce la vecchia opzione <code>--root-directory</code>, deprecata. <code>--bootloader-id</code> contiene il percorso alla directory che ospita il file <code>grubx64.efi</code>.</li>
<li>Si noti l'assenza di un riferimento a qualsivoglia disco rigido (es. <code>/dev/sda</code>) durante l'esecuzione di <code>grub-install</code>, a differenza di quanto avviene per sistemi BIOS. Eventuali riferimenti a dischi rigidi saranno ignorati dallo script di installazione, in quanto i bootloader UEFI non utilizzano MBR o i boot sector delle partizioni.</li>
</ul>
</div>
<p>A questo punto, GRUB è stato installato. Non dimenticarsi di <a href="#Generazione_del_file_di_configurazione_principale">generare il file di configurazione principale</a>.
</p>
<h5><span class="mw-headline" id="Workaround_per_alcuni_firmware_UEFI">Workaround per alcuni firmware UEFI</span></h5>
<p>Alcuni firmare UEFI richiedono che il file <code>.efi</code> avviabile abbia un nome ben definito e si trovi in una posizione specifica: <code>$esp/EFI/boot/bootx64.efi</code> (dove <code>$esp</code> corrisponde al punto di mount della partizione UEFI). In caso non si rispettino queste regole il sistema non riuscirà ad avviarsi.
Si noti che questi accorgimenti non creano problemi con altri firmware, e sono pertanto da considerarsi come il metodo di installazione ufficiale.
</p>
<p>Creare la cartella richiesta, quindi copiare il file <code>.efi</code> di GRUB rinominandolo nel modo corretto:
</p>
<pre># mkdir $esp/EFI/boot
# cp $esp/EFI/arch_grub/grubx64.efi  $esp/EFI/boot/bootx64.efi
</pre>
<h5><span class="mw-headline" id="Metodo_alternativo">Metodo alternativo</span></h5>
<p>Generalmente, GRUB posiziona i propri files, compresi quelli di configurazione, in <code>/boot</code>, a prescindere dal punto di mount della partizione EFI di sistema.
</p>
<p>Se si desidera memorizzare tali file nella partizione EFI di sistema, si aggiunga <code>--boot-directory=$esp</code> al comando <code>grub-install</code>:
</p>
<pre># grub-install --target=x86_64-efi --efi-directory=$esp --bootloader-id=grub --boot-directory=$esp --recheck --debug
</pre>
<p>Quanto sopra include tutti i files di GRUB in <code>$esp/grub</code>, invece di utilizzare <code>/boot/grub</code>.
Quando si utilizza questo metodo, assicurarsi che <code>grub-mkconfig</code> generi il file di configurazione nella posizione corretta:
</p>
<pre># grub-mkconfig -o $esp/grub/grub.cfg
</pre>
<p>Il resto della configurazione è identica.
</p>
<h4><span class="mw-headline" id="Creare_una_voce_per_GRUB_nel_Firmware_Boot_Manager">Creare una voce per GRUB nel Firmware Boot Manager</span></h4>
<p>Lo script <code>grub-install</code> cerca di creare automaticamente una voce di menù nel boot manager. Se ciò non dovesse avvenire, si consulti <a href="../en/Unified_Extensible_Firmware_Interface.html#efibootmgr" class="mw-redirect" title="UEFI">UEFI#efibootmgr</a> per istruzioni su come utilizzare <code>efibootmgr</code> per creare una voce.
</p>
<p>In ogni caso, il problema è solitamente relativo al mancato avvio dell'immagine di installazione in modalità UEFI, come descritto in <a href="../it/Unified_Extensible_Firmware_Interface.html#Creare_un_dispositivo_USB_avviabile_con_UEFI_dalla_ISO" title="Unified Extensible Firmware Interface (Italiano)">Unified Extensible Firmware Interface#Creare un dispositivo USB avviabile con UEFI dalla ISO</a>.
</p>
<h4><span class="mw-headline" id="GRUB_Standalone">GRUB Standalone</span></h4>
<p>È possibile creare una applicazione EFI standalone (grubx64_standalone.efi) che comprende tutti i moduli necessari in un archivio tar al suo interno, eliminando di fatto, la necessità di avere una directory separata contenente tutti i moduli UEFI di GRUB ed altri files ad essi relativi. Per raggiungere l'obiettivo, verrà utilizzato il comando <code>grub-mkstandalone</code>, incluso in <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=grub">grub</a></span>:
</p>
<pre># echo 'configfile ${cmdpath}/grub.cfg' &gt; /tmp/grub.cfg                                ## utilizzare apici singoli, ${cmdpath}/grub.cfg dovrebbe essere lasciato così com'è
# grub-mkstandalone -d /usr/lib/grub/x86_64-efi/ -O x86_64-efi --modules="part_gpt part_msdos" --fonts="unicode" --locales="en@quot" --themes="" -o "$esp/EFI/grub/grubx64_standalone.efi"  "boot/grub/grub.cfg=/tmp/grub.cfg" -v
</pre>
<p>Si copi quindi il file di configurazione di GRUB in <code>$esp/EFI/grub/grub.cfg</code> e si crei una voce nell'UEFI Boot Manager per il file <code>$esp/EFI/grub/grubx64_standalone.efi</code> utilizzando <a href="../it/Unified_Extensible_Firmware_Interface.html#efibootmgr" title="Unified Extensible Firmware Interface (Italiano)">efibootmgr</a>.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> L'opzione <code>--modules="part_gpt part_msdos"</code> (doppi apici compresi) è necessaria affinchè <code>${cmdpath</code>} funzioni correttamente.</div>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Attenzione:</strong> Potrebbe capitare che il file <code>grub.cfg</code> non venga caricato a causa della mancanza dello slash finale da <code>${cmdpath</code>} (es. <code>(hd1,msdos2)EFI/Boot</code> invece di <code>(hd1,msdos2)/EFI/Boot</code>), e si venga lasciati nella shell di GRUB. Se si  ha questo problema si verifichi il contenuto della variabile <code>${cmdpath} </code> (<code>echo ${cmdpath} </code>) e si proceda al caricamento manuale del file di configurazione (es. <code>configfile (hd1,msdos2)/EFI/Boot/grub.cfg</code>).</div>
<h5><span class="mw-headline" id="GRUB_Standalone_-_Informazioni_tecniche">GRUB Standalone - Informazioni tecniche</span></h5>
<p>L'applicazione EFI di GRUB assume che il relativo file di configurazione si trovi in <code>${prefix}/grub.cfg</code>. Tuttavia, nel file dell'applicazione Standalone, <code>${prefix} </code> è contenuto all'interno di un archivio tar dentro al suddetto file (identificato nell'ambiente GRUB come <code>"(memdisk)"</code>, senza doppi apici). L'archivio contiene tutti i files che normalmente si troverebbero sotto <code>/boot/grub</code> nel caso di un'installazione di GRUB EFI classica.
</p>
<p>A causa dell'embedding del contenuto di <code>/boot/grub</code> nell'immagine standalone, essa è completamente indipendente dal contenuto di una directory <code>/boot/grub</code> esterna. Ne consegue che per l'immagine EFI Standalone <code>${prefix}==(memdisk)/boot/grub</code>, quindi il file di configurazione dovrà trovarsi in <code>${prefix}/grub.cfg==(memdisk)/boot/grub/grub.cfg</code>.
</p>
<p>Per fare in modo che l'immagine EFI Standalone legga un <code>grub.cfg</code> esterno posizionato nella stessa directory dell'immagine (identificata  nell'ambiente GRUB come <code>${cmdpath} </code>, verrà creato un file <code>/tmp/grub.cfg</code> che costringe grub ad utilizzare <code>${cmdpath}/grub.cfg</code> come file di configurazione (il comando che esegue questa operazione è <code>configfile ${cmdpath}/grub.cfg</code>, contenuto in <code>(memdisk)/boot/grub/grub.cfg</code>). Infine, si indica a <code>grub-mkstandalone</code> di copiare il file <code>/tmp/grub.cfg</code> in <code>${prefix}/grub.cfg</code> (ovvero <code>(memdisk)/boot/grub/grub.cfg</code>) utilizzando l'opzione <code>"/boot/grub/grub.cfg=/tmp/grub.cfg"</code>.
</p>
<p>Così facendo, l'immagine Efi Standalone e il relativo <code>grub.cfg</code> possono essere memorizzati in qualsiasi directory della partizione EFI di sistema (a patto che i due file si trovino nella stessa directory), rendendoli di fatto portabili.
</p>
<h2><span class="mw-headline" id="Generazione_del_file_di_configurazione_principale">Generazione del file di configurazione principale</span></h2>
<p>Dopo l'installazione sarà necessario generare il file di configurazione principale <code>grub.cfg</code>. Il processo di creazione del suddetto file può essere influenzato dalle opzioni contenute in <code>/etc/default/grub</code> e dagli script in <code>/etc/grub.d</code>. È possibile reperire ulteriori informazioni leggendo i paragrafi <a href="#Configurazione_di_base">#Configurazione di base</a> o <a href="#Configurazione_avanzata">#Configurazione avanzata</a>.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Si ricordi che sarà necessario rigenerare il file <code>grub.cfg</code> dopo ogni cambiamento ad <code>/etc/default/grub</code> o ai files in <code>/etc/grub.d/*</code>.</div>
<p>Utilizzare il tool <i>grub-mkconfig</i> per generare il <code>grub.cfg</code>:
</p>
<pre># grub-mkconfig -o /boot/grub/grub.cfg
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> 
<ul>
<li>Il percorso al file di configurazione è <code>/boot/grub/grub.cfg</code>, e NON <code>/boot/grub/i386-pc/grub.cfg</code>.</li>
<li>Se si sta cercando di effettuare questa operazione da dentro un ambiente di chroot o da un container <code>systemd-nspawn</code>, è possibile che <code>grub-probe</code> mostri un errore relativo all'impossibilità di ottenere il path di <code>/dev/sdaX</code>. In questo caso si provi ad utilizzare <code>arch-chroot</code> come spiegato in <a rel="nofollow" class="external text" href="https://bbs.archlinux.org/viewtopic.php?pid=1225067#p1225067">questo</a> thread.</li>
<li>Quando si genera il file di configurazione di GRUB su un sistema LVM dall'interno di un ambiente di chroot (anche <i>arch-chroot</i>, utilizzato durante l'installazione), è possibile che vengano visualizzati messaggi come <code>/run/lvm/lvmetad.socket: connect failed: No such file or directory</code> o <code>WARNING: failed to connect to lvmetad: No such file or directory. Falling back to internal scanning.</code>. Ciò è dovuto alla mancanza di <code>/run</code> nell'ambiente di chroot. Tali messaggi non impediranno al sistema di avviarsi, a patto che tutti i passaggi siano stati completati correttamente, quindi è possibile procedere con l'installazione.</li>
</ul>
</div>
<p>Di default, lo script di generazione aggiunge automaticamente le voci di menù per Arch Linux a qualsiasi configurazione venga generata, mentre ciò non accade per eventuali voci relative ad altri sistemi operativi. Su sistemi BIOS, si installi il pacchetto <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=os-prober">os-prober</a></span>, che individua i sistemi operativi installati sulla macchina e li aggiunge al <code>grub.cfg</code> durante l'esecuzione di <code>grub-mkconfig</code>. Si veda <a href="#Dual-booting">#Dual-booting</a> per eventuali configurazioni avanzate.
</p>
<h3><span class="mw-headline" id="Conversione_del_file_di_configurazione_di_GRUB_Legacy_al_nuovo_formato">Conversione del file di configurazione di GRUB Legacy al nuovo formato</span></h3>
<p>Se <code>grub-mkconfig</code> non funziona, si converta il proprio <code>/boot/grub/menu.lst</code> nel <code>/boot/grub/grub.cfg</code> eseguendo:
</p>
<pre># grub-menulst2cfg /boot/grub/menu.lst /boot/grub/grub.cfg
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Questa operazione funziona solamente su sistemi BIOS.</div>
<p>Ad esempio:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/boot/grub/menu.lst</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">default=0
timeout=5

title  Arch Linux Stock Kernel
root   (hd0,0)
kernel /vmlinuz-linux root=/dev/sda2 ro
initrd /initramfs-linux.img

title  Arch Linux Stock Kernel Fallback
root   (hd0,0)
kernel /vmlinuz-linux root=/dev/sda2 ro
initrd /initramfs-linux-fallback.img
</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/boot/grub/grub.cfg</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">set default='0'; if [ x"$default" = xsaved ]; then load_env; set default="$saved_entry"; fi
set timeout=5

menuentry 'Arch Linux Stock Kernel' {
  set root='(hd0,1)'; set legacy_hdbias='0'
  legacy_kernel   '/vmlinuz-linux' '/vmlinuz-linux' 'root=/dev/sda2' 'ro'
  legacy_initrd '/initramfs-linux.img' '/initramfs-linux.img'
}

menuentry 'Arch Linux Stock Kernel Fallback' {
  set root='(hd0,1)'; set legacy_hdbias='0'
  legacy_kernel   '/vmlinuz-linux' '/vmlinuz-linux' 'root=/dev/sda2' 'ro'
  legacy_initrd '/initramfs-linux-fallback.img' '/initramfs-linux-fallback.img'
}
</pre>
<p>Se si è riavviato il sistema dimenticandosi di creare il <code>/boot/grub/grub.cfg</code>, si eseguano questi comandi nella shell di GRUB che apparirà al riavvio:
</p>
<pre>sh:grub&gt; insmod legacycfg
sh:grub&gt; legacy_configfile ${prefix}/menu.lst
</pre>
<p>Procedere quindi all'avvio di Arch Linux e si generi il file <code>/boot/grub/grub.cfg</code>.
</p>
<h2><span class="mw-headline" id="Configurazione_di_base">Configurazione di base</span></h2>
<p>Questa sezione copre le sole modifiche al file <code>/etc/default/grub</code>. Si veda <a href="#Configurazione_avanzata">#Configurazione avanzata</a> per ulteriori approfondimenti.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Ricordarsi di <a href="#Generazione_del_file_di_configurazione_principale">rigenerare</a> il file di configurazione principale dopo qualsiasi cambiamento ad <code>/etc/default/grub</code>.</div>
<h4><span class="mw-headline" id="Argomenti_aggiuntivi">Argomenti aggiuntivi</span></h4>
<p>Se si ha la necessità di passare dei parametri particolari all'immagine del kernel, è necessario inserirli nelle variabili <code>GRUB_CMDLINE_LINUX</code> e <code>GRUB_CMDLINE_LINUX_DEFAULT</code> contenute nel file <code>/etc/default/grub</code>. I valori delle due variabili vengono inseriti uno di seguito all'altro per le voci di avvio standard. Per quanto riguarda la generazione delle voci di avvio di ripristino, viene utilizzato solamente <code>GRUB_CMDLINE_LINUX</code>. 
</p>
<p>Non è necessario utilizzarli entrambi, ma può risultare utile: ad esempio, è possibile abilitare  il resume dopo l'ibernazione tramite <code>GRUB_CMDLINE_LINUX_DEFAULT="resume=/dev/sdaX quiet"</code> dove <code>sdaX</code> indica la propria partizione di swap.
</p>
<p>In questo modo verrebbe generata una voce di ripristino senza il supporto al resume e senza il parametro <code>quiet</code> che elimina i messaggi del kernel durante il boot. Di contro, la voce d'avvio standard mantiene i parametri di cui sopra.
</p>
<p>Per generare la voce di ripristino è necessario commentare l'opzione <code>GRUB_DISABLE_RECOVERY=true</code> in <code>/etc/default/grub</code>.
</p>
<p>E' anche possibile utilizzare <code>GRUB_CMDLINE_LINUX="resume=/dev/disk/by-uuid/${swap_uuid}"</code>, dove <code>${swap_uuid</code>} si riferisce all'<a href="../it/Persistent_block_device_naming.html" title="Persistent block device naming (Italiano)">uuid</a> della propria partizione di swap.
</p>
<p>Si veda <a href="../en/Kernel_parameters.html" title="Kernel parameters">Kernel parameters</a> per ulteriori informazioni.
</p>
<h3>
<span id="Configurazione_dell.27aspetto"></span><span class="mw-headline" id="Configurazione_dell'aspetto">Configurazione dell'aspetto</span>
</h3>
<p>In GRUB è possibile cambiare l'aspetto del menu.
Ci si assicuri di aver inizializzato il terminale grafico di GRUB (gfxterm), usando una modalità video appropriata (gfxmode). Ulteriori informazioni sono reperibili nella sezione <a href="#Correggere_l'errore_di_GRUB_%22no_suitable_mode_found%22">#Correggere l'errore di GRUB "no suitable mode found"</a>. La modalità video impostata di seguito, verrà passata al kernel via <code>gfxpayload</code>; di conseguenza, questa sarà richiesta affinchè ogni configurazione dell'aspetto abbia effetto.
</p>
<h4><span class="mw-headline" id="Impostare_la_risoluzione_del_framebuffer">Impostare la risoluzione del framebuffer</span></h4>
<p>GRUB può impostare il framebuffer sia per sé stesso che per il kernel. Il vecchio parametro <code>vga=</code> è deprecato. Il metodo consigliato è modificare <code>/etc/default/grub</code> come segue:
</p>
<pre>GRUB_GFXMODE=1024x768x32
GRUB_GFXPAYLOAD_LINUX=keep</pre>
<p>È possibile specificare diverse risoluzioni, incluso il valore di default <code>auto</code>. È quindi consigliabile che la variabile <code>GRUB_GFXMODE</code> abbia un valore simile a <code>GRUB_GFXMODE=&lt;risoluzione desiderata&gt;,&lt;fallback, ad esempio 1024x768&gt;,auto</code>. Per ulteriori informazioni, consultare la <a rel="nofollow" class="external text" href="https://www.gnu.org/software/grub/manual/html_node/gfxmode.html#gfxmode">documentazione di GRUB relativa a gfxmode</a>. L'opzione <a rel="nofollow" class="external text" href="https://www.gnu.org/software/grub/manual/html_node/gfxpayload.html#gfxpayload">gfxpayload</a> farà si che il kernel mantenga la risoluzione.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> È possibile utilizzare solamente le risoluzioni che la scheda grafica supporta tramite le <a href="https://en.wikipedia.org/wiki/VESA_BIOS_Extensions" class="extiw" title="wikipedia:VESA BIOS Extensions">estensioni VESA BIOS</a>. Per ottenere un elenco delle risoluzioni supportate, si installi <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=hwinfo">hwinfo</a></span> e si esegua <code>hwinfo --framebuffer</code> come utente root. In alternativa, si entri nella riga di comando di GRUB e si esegua <code>vbeinfo</code>.</div>
<p>Se quanto sopra non funziona, è possibile utilizzare il vecchio parametro <code>vga=</code>. Lo si aggiunga semplicemente alla variabile <code>"GRUB_CMDLINE_LINUX_DEFAULT="</code> in <code>/etc/default/grub</code>: ad esempio: <code>"GRUB_CMDLINE_LINUX_DEFAULT="quiet splash vga=792"</code> imposterà una risoluzione di <code>1024x768</code>.
</p>
<h4><span class="mw-headline" id="Hack_915resolution">Hack 915resolution</span></h4>
<p>Se si stanno utilizzando schede grafiche Intel, può accadere che nè <code># hwinfo --framebuffer</code> nè <code>vbeinfo</code> mostrino la risoluzione desiderata. In questo caso, è possibile utilizzare l'hack proposto, che modificherà temporaneamente il BIOS della scheda video aggiungendo la risoluzione richiesta. Si veda la home page di <a rel="nofollow" class="external text" href="http://915resolution.mango-lang.org/">915resolution</a>.
</p>
<p>Innanzitutto è necessario scegliere una modalità video da modificare più tardi. Si avvii quindi <code>915resolution</code> nella shell di GRUB:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">sh:grub&gt; 915resolution -l</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Intel 800/900 Series VBIOS Hack : version 0.5.3
[...]
Mode 30 : 640x480, 8 bits/pixel
[...]
</pre>
<p>L'obiettivo è quello di sovrascrivere la modalità 30 con la risoluzione <code>1440x900</code>:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/grub/00_header</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[...]
<b>915resolution 30 1440 900 # linea aggiunta</b>
set gfxmode=${GRUB_GFXMODE}
[...]
</pre>
<p>Sarà ora necessario impostare il valore di <code>GRUB_GFXMODE</code>, come spiegato in precedenza e rigenerare il file di configurazione di GRUB:
</p>
<pre># grub-mkconfig -o /boot/grub/grub.cfg
# reboot
</pre>
<h4><span class="mw-headline" id="Immagine_di_sfondo_e_caratteri_bitmap">Immagine di sfondo e caratteri bitmap</span></h4>
<p>GRUB supporta le immagini di sfondo e i caratteri bitmap nel formato <code>pf2</code>. Il font unifont è incluso nel pacchetto <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=grub">grub</a></span> con nome <code>unicode.pf2</code> oppure, in soli caratteri ASCII con nome <code>ascii.pf2</code>.
</p>
<p>I formati di immagine supportati includono tga, png e jpeg, a patto che i rispettivi moduli siano caricati. La risoluzione massima applicabile dipende dall'hardware in uso.
</p>
<p>Prima di procedere, seguire quanto indicato in <a href="#Impostare_la_risoluzione_del_framebuffer">#Impostare la risoluzione del framebuffer</a>.
</p>
<p>Si modifichi quindi il file <code>/etc/default/grub</code> come segue:
</p>
<pre>GRUB_BACKGROUND="/boot/grub/miaimmagine"
#GRUB_THEME="/path/to/gfxtheme"
GRUB_FONT="/path/to/font.pf2"
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Se si è installato GRUB in una partizione separata, <code>/boot/grub/miaimmagine</code> diventa <code>/grub/miaimmagine</code>.</div>
<p>Per applicare le modifiche al <code>grub.cfg</code>, si esegua:
</p>
<pre>grub-mkconfig -o /boot/grub/grub.cfg
</pre>
<p>Se l'inserimento dell'immagine è avvenuto con successo, dovrebbe essere visualizzato il messaggio <code>Found background image...</code>, durante l'esecuzione del precedente comando. Se questo non accade, significa che l'immagine non è stata incorporata nel grub.cfg.
</p>
<p>In tal caso, si controlli che:
</p>
<ul>
<li>il percorso e il nome dell'immagine in <code>/etc/default/grub</code> siano corretti</li>
<li>l'immagine abbia dimensioni e formato adeguati (tga, png, png a 8 bit)</li>
<li>l'immagine sia stata salvata in modalità RGB e non sia indicizzata</li>
<li>la modalità console non sia stata abilitata in /etc/default/grub</li>
<li>il comando <code>grub-mkconfig</code> sia stato eseguito per inserire le informazioni relative allo sfondo nell file <code>/boot/grub/grub.cfg</code>.</li>
</ul>
<h4><span class="mw-headline" id="Temi">Temi</span></h4>
<p>Di seguito viene proposto un esempio per la configurazione di GRUB con il tema Starfield, incluso nel pacchetto fornito con Arch.
</p>
<p>Si modifichi <code>/etc/default/grub</code>:
</p>
<pre>GRUB_THEME="/usr/share/grub/themes/starfield/theme.txt"
</pre>
<p>Si applichino le modifiche:
</p>
<pre>grub-mkconfig -o /boot/grub/grub.cfg
</pre>
<p>Se il tema è stato applicato correttamente, apparirà a video il messaggio <code>Found theme: /usr/share/grub/themes/starfield/theme.txt</code>.
</p>
<h4>
<span id="Colori_del_Men.C3.B9"></span><span class="mw-headline" id="Colori_del_Menù">Colori del Menù</span>
</h4>
<p>In GRUB è possibile cambiare i colori del menù. L'elenco dei colori disponibili è reperibile <a rel="nofollow" class="external text" href="https://www.gnu.org/software/grub/manual/html_node/Theme-file-format.html#Theme-file-format">qui</a>. Di seguito, un esempio:
</p>
<p>Si modifichi <code>/etc/default/grub</code> come segue:
</p>
<pre>GRUB_COLOR_NORMAL="light-blue/black"
GRUB_COLOR_HIGHLIGHT="light-cyan/blue"</pre>
<p>Per rendere effettivi i cambiamenti si esegua:
</p>
<pre>grub-mkconfig -o /boot/grub/grub.cfg
</pre>
<h4>
<span id="Men.C3.B9_nascosto"></span><span class="mw-headline" id="Menù_nascosto">Menù nascosto</span>
</h4>
<p>Una delle caratteristiche proprie di GRUB è la possibilità di nascondere il menù e renderlo visibile attraverso la pressione del tasto <code>Esc</code>, se necessario. È anche possibile decidere se visualizzare o meno il countdown.
</p>
<p>Si modifichi <code>/etc/default/grub</code>. Nell'esempio che segue, il countdown è stato impostato a 5 secondi e reso visibile all'utente:
</p>
<pre>GRUB_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT=5
GRUB_HIDDEN_TIMEOUT_QUIET=false</pre>
<p>La variabile <code>GRUB_HIDDEN_TIMEOUT</code> specifica quanti secondi aspettare prima di mostrare il menu. Sarà necessario impostare <code>GRUB_TIMEOUT=0</code> se lo si vuole nascondere.
</p>
<p>Si esegua:
</p>
<pre># grub-mkconfig -o /boot/grub/grub.cfg
</pre>
<h4><span class="mw-headline" id="Disabilitare_il_framebuffer">Disabilitare il framebuffer</span></h4>
<p>Se si usano i driver proprietari NVIDIA, potrebbe essere necessario disabilitare il framebuffer di GRUB, poichè potrebbe interferire con il driver.
</p>
<p>Per disabilitarlo, si modifichi <code>/etc/default/grub</code> decommentando la seguente linea:
</p>
<pre>GRUB_TERMINAL_OUTPUT=console
</pre>
<p>Si esegua poi:
</p>
<pre>grub-mkconfig -o /boot/grub/grub.cfg
</pre>
<p>Se si vuole comunque avviare GRUB in framebuffer è possibile tornare in modalità testuale prima dell'avvio del kernel. A tal proposito si modifichi la relativa variabile in <code>/etc/default/grub</code>:
</p>
<pre>GRUB_GFXPAYLOAD_LINUX=text
</pre>
<p>Si rigeneri quindi il file di configurazione come visto sopra.
</p>
<h3><span class="mw-headline" id="Nomenclatura_permanente_dei_dispositivi_a_blocchi">Nomenclatura permanente dei dispositivi a blocchi</span></h3>
<p>Un modo per identificare con una <a href="../it/Persistent_block_device_naming.html" title="Persistent block device naming (Italiano)">nomenclatura persistente i dispositivi a blocchi</a> è quello di utilizzare degli UUID univoci per le partizioni, invece dei vecchi valori <code>/dev/sd*</code>. I vantaggi sono spiegati nel link fornito sopra. 
</p>
<p>GRUB utilizza di default gli UUID dei filesystems per identificare in modo permanente i dispositivi a blocchi.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> È necessario rigenerare il file <code>/boot/grub/grub.cfg</code> affinchè vengano aggiornati gli UUID ogni volta che una partizione viene ridimensionata o formattata. Si tenga a mente questo particolare ogni volta che si modificano le partizioni con un LiveCD.</div>
<p>L'uso degli UUID è controllato da un'opzione in <code>/etc/default/grub</code>:
</p>
<pre># GRUB_DISABLE_LINUX_UUID=true
</pre>
<p>In ogni caso, ci si ricordi di applicare i cambiamenti:
</p>
<pre># grub-mkconfig -o /boot/grub/grub.cfg
</pre>
<h3>
<span id="Richiamare_l.27ultimo_sistema_avviato"></span><span class="mw-headline" id="Richiamare_l'ultimo_sistema_avviato">Richiamare l'ultimo sistema avviato</span>
</h3>
<p>GRUB è in grado di ricordarsi l'ultimo sistema avviato ed usarlo come default la prossima volta che si eseguirà il boot. Questa funzionalità è utile se si dispone di kernel multipli (ad esempio il kernel corrente di Arch e il LTS come fallback) o più sistemi operativi. Si modifichi <code>/etc/default/grub</code> e si cambi il valore di <code>GRUB_DEFAULT</code>:
</p>
<pre>GRUB_DEFAULT=saved
</pre>
<p>Ciò consentirà a GRUB di avviare il sistema operativo salvato. Per abilibare il salvataggio, si aggiunga la linea seguente ad <code>/etc/default/grub</code>:
</p>
<pre>GRUB_SAVEDEFAULT=true
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Le voci di menù aggiunte manualmente in <code>/etc/grub.d/40_custom</code> o <code>/boot/grub/custom.cfg</code> (ad esempio Windows), richiederanno l'opzione <code>savedefault</code>.</div>
<p>Ci si ricordi di <a href="#Generare_un_file_di_configurazione">rigenerare</a><sup>[<a href="../en/Help:Procedures.html#Fix_broken_section_links" title="Help:Procedures">broken link</a>: invalid section]</sup> il file di configurazione di GRUB.
</p>
<h3><span class="mw-headline" id="Cambiare_la_voce_di_menu_predefinita">Cambiare la voce di menu predefinita</span></h3>
<p>Per cambiare la voce selezionata in modo predefinito, si modifichi la variabile <code>GRUB_DEFAULT</code> in <code>/etc/default/grub</code>:
</p>
<p>Utilizzando numeri progressivi:
</p>
<pre>GRUB_DEFAULT=0
</pre>
<p>GRUB enumera le voci che appaiono nel menu partendo da zero, il che significa che 0 selezionerà la prima voce, 1 la seconda e così via.
</p>
<p>Oppure utilizzando i titoli delle voci:
</p>
<pre>GRUB_DEFAULT='Arch Linux, with Linux core repo kernel'
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Ricordarsi di <a href="#Generare_un_file_di_configurazione">rigenerare</a><sup>[<a href="../en/Help:Procedures.html#Fix_broken_section_links" title="Help:Procedures">broken link</a>: invalid section]</sup> il file di configurazione di GRUB.</div>
<h3><span class="mw-headline" id="Disabilitare_il_sottomenu">Disabilitare il sottomenu</span></h3>
<p>Se si hanno più kernel installati (ad esempio linux e linux-lts), <code>grub-mkconfig</code> li raggrupperà in un sottomenù.
</p>
<p>Se non si desidera utilizzare questa funzionalità si aggiunga la seguente linea al file <code>/etc/default/grub</code>:
</p>
<pre>GRUB_DISABLE_SUBMENU=y
</pre>
<h3><span class="mw-headline" id="Cifratura_della_partizione_root">Cifratura della partizione root</span></h3>
<p>Per far sì che GRUB passi automaticamente al kernel i parametri necessari per la cifratura della root, si aggiunga <code>cryptdevice=/dev/device:etichetta</code> a <code>GRUB_CMDLINE_LINUX</code> in <code>/etc/default/grub</code>.
</p>
<p>Si veda inoltre <a href="../en/Dm-crypt/System_configuration.html#Boot_loader" title="Dm-crypt/System configuration">Dm-crypt/System configuration#Boot loader</a> per ulteriori informazioni.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Suggerimento:</strong> Se si sta effettuando l'aggiornamento da GRUB Legacy, si controlli il file <code>/boot/grub/menu.lst.pacsave</code> per l'identificativo dispositivo o l'etichetta corretta da inserire. Si cerchi dopo la riga <code>kernel /vmlinuz-linux</code>.</div>
<p>Un esempio con la root mappata su <code>/dev/mapper/root</code>:
</p>
<pre>GRUB_CMDLINE_LINUX="cryptdevice=/dev/sda2:root"
</pre>
<p><br>	
</p>
<div class="noprint archwiki-template-message">
<p><a href="../File:Tango-inaccurate.png" class="image"><img alt="Tango-inaccurate.png" src="../File:Tango-inaccurate.png" decoding="async" width="48" height="48"></a><b>The factual accuracy of this article or section is disputed.</b><a href="../File:Tango-inaccurate.png" class="image"><img alt="Tango-inaccurate.png" src="../File:Tango-inaccurate.png" decoding="async" width="48" height="48"></a></p>
<div>
<b>Reason:</b> Il passaggio che segue è stato aggiunto qui: The following step was added with <a rel="nofollow" class="external autonumber" href="https://wiki.archlinux.org/index.php?title=GRUB&amp;diff=184194&amp;oldid=183020">[3]</a>, ma non è chiara la ragione per la quale sia necessario disabilitare l'utilizzo degli UUID per il filesystem root. (Discuss in <a rel="nofollow" class="external text" href="https://wiki.archlinux.org/index.php/Talk:GRUB_(Italiano)">Talk:GRUB (Italiano)#</a>)</div>
</div>
<p>Se si riscontrano problemi nell'effettuare il boot con <code>dm-crypt</code> su sistemi UEFI-GPT Si disabiliti l'uso degli UUID per il file system di root:
</p>
<pre>GRUB_DISABLE_LINUX_UUID=true
</pre>
<p>Ed assicurarsi di non utilizzare riferimenti agli UUID (ad esempio, utilizzare <code>/dev/sdb3</code> al posto di <code>/dev/disk/by-uuid/42d934c7-6199-4f11-9e01-807530111df6 o UUID=42d934c7-6199-4f11-9e01-807530111df6</code>).
</p>
<p>Rigenerare quindi il file di configurazione di GRUB.
</p>
<h3><span class="mw-headline" id="Effettuare_il_boot_di_una_voce_non_default_per_una_sola_volta">Effettuare il boot di una voce non default per una sola volta</span></h3>
<p>Il comando <code>grub-reboot</code> è molto utile per avviare una voce diversa da quella di default. GRUB caricherà la voce specificata come primo argomento del comando e il sistema operativo corrispondente verrà avviato al prossimo avvio.
Si noti che GRUB effettuerà il boot della scelta di default per tutti i riavvii successivi a quello effettuato subito dopo l'esecuzione del comando.
Non è necessario modificare il file di configurazione di GRUB o scegliere una voce nel menù di avvio.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Quanto sopra richiede l'opzione <code>GRUB_DEFAULT=saved</code> in <code>/etc/default/grub</code> (e successiva rigenerazione del <code>grub.cfg</code>) o, in caso di un <code>grub.cfg</code> scritto manualmente, la linea <code>set default="${saved_entry}"</code>.</div>
<h2><span class="mw-headline" id="Configurazione_avanzata">Configurazione avanzata</span></h2>
<p>Questa sezione si occupa delle modifiche manuali al <code>grub.cfg</code>, della scrittura di script personalizzati in <code>/etc/grub.d</code> e di altre impostazioni avanzate.
</p>
<h3><span class="mw-headline" id="Creazione_manuale_del_grub.cfg">Creazione manuale del grub.cfg</span></h3>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Attenzione:</strong> La modifica manuale di questo file è fortemente sconsigliata. Il <code>grub.cfg</code> è generato dal comando <code>grub-mkconfig</code>, ed è preferibile modificare il file <code>/etc/default/grub</code> o uno degli script contenuti nella cartella <code>/etc/grub.d</code>.</div>
<p>Un <code>grub.cfg</code> di base contiene le seguenti opzioni:
</p>
<ul>
<li>
<code>(hdX,Y)</code> indica la partizione Y sul disco X. La numerazione delle partizioni parte da 1, mentre quella dei dischi da 0</li>
<li>
<code>set default=N</code> permette di scegliere quale entry avviare in modo predefinito</li>
<li>
<code>set timeout=N</code> indica il limite di tempo in secondi prima che la scelta predefinita venga avviata</li>
<li>
<code>menuentry "title" {opzioni</code>} è un'entry di nome <code>title</code>
</li>
<li>
<code>set root=(hdX,Y)</code> imposta la partizione di boot, ossia quella contenente il kernel e i moduli di GRUB (non è necessario disporre di una partizione separata: <code>/boot</code> può essere contenuta all'interno della partizione di root).</li>
</ul>
<p>Una configurazione d'esempio:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/boot/grub/grub.cfg
</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;"># Config file for GRUB - The GNU GRand Unified Bootloader
# /boot/grub/grub.cfg

# DEVICE NAME CONVERSIONS
#
#  Linux           Grub
# -------------------------
#  /dev/fd0        (fd0)
#  /dev/sda        (hd0)
#  /dev/sdb2       (hd1,2)
#  /dev/sda3       (hd0,3)
#

# Timeout for menu
set timeout=5

# Set default boot entry as Entry 0
set default=0

# (0) Arch Linux
menuentry "Arch Linux" {
set root=(hd0,1)
linux /vmlinuz-linux root=/dev/sda3 ro
initrd /initramfs-linux.img
}

## (1) Windows
#menuentry "Windows" {
#set root=(hd0,3)
#chainloader +1
#}</pre>
<h3><span class="mw-headline" id="Dual-booting">Dual-booting</span></h3>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Suggerimento:</strong> Se si desidera che GRUB ricerchi automaticamente i sistemi operativi installati, è necessario installare <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=os-prober">os-prober</a></span>.</div>
<h4>
<span id="Generazione_automatica_utilizzando_il_file_.2Fetc.2Fgrub.d.2F40_custom_e_grub-mkconfig"></span><span class="mw-headline" id="Generazione_automatica_utilizzando_il_file_/etc/grub.d/40_custom_e_grub-mkconfig">Generazione automatica utilizzando il file /etc/grub.d/40_custom e grub-mkconfig</span>
</h4>
<p>Il modo migliore per aggiungere altre voci è modificare il file <code>/etc/grub.d/40_custom</code> oppure <code>/boot/grub/custom.cfg</code>, in modo che esse vengano automaticamente aggiunte al <code>grub.cfg</code> quando si lancia <code>grub-mkconfig</code>. Dopo aver effettuato le modifiche, si esegua:
</p>
<pre># grub-mkconfig -o /boot/grub/grub.cfg</pre>
<p>Oppure, per sistemi UEFI-GPT (come descritto nel metodo alternativo):
</p>
<pre># grub-mkconfig -o /boot/efi/EFI/GRUB/grub.cfg</pre>
<p>Per generare un <code>grub.cfg</code> aggiornato.
</p>
<p>Un file <code>/etc/grub.d/40_custom</code> generico potrebbe avere una struttura simile a quello postato sotto, creato per un <a rel="nofollow" class="external text" href="http://h10025.www1.hp.com/ewfrf/wc/product?cc=us&amp;destPage=product&amp;lc=en&amp;product=5402703&amp;tmp_docname=">HP Pavilion 15-e056sl notebook</a> con Windows 8 preinstallato. Ogni voce <code>menuentry</code> dovrebbe mantenere una struttura simile a quanto segue.
</p>
<p>Si noti inoltre che la partizione <code>/dev/sda2</code> viene identificata da GRUB come <code>hd0,gpt2</code> e <code>ahci0,gpt2</code>. Si consulti <a href="../en/GRUB.html#Voce_di_men%C3%B9_per_Windows_installato_in_modalit%C3%A0_UEFI-GPT" title="GRUB">GRUB#Voce di menù per Windows installato in modalità UEFI-GPT</a><sup>[<a href="../en/Help:Procedures.html#Fix_broken_section_links" title="Help:Procedures">broken link</a>: invalid section]</sup> per ulteriori informazioni.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/grub.d/40_custom</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">#!/bin/sh
exec tail -n +3 $0
# This file provides an easy way to add custom menu entries.  Simply type the
# menu entries you want to add after this comment.  Be careful not to change
# the 'exec tail' line above.

menuentry "HP / Microsoft Windows 8" {
	echo "Sto avviando HP / Microsoft Windows 8..."
	insmod part_gpt
	insmod fat
	insmod search_fs_uuid
	insmod chain
	search --fs-uuid --no-floppy --set=root --hint-bios=hd0,gpt2 --hint-efi=hd0,gpt2 --hint-baremetal=ahci0,gpt2 763A-9CB6
	chainloader (${root})/EFI/Microsoft/Boot/bootmgfw.efi
}

menuentry "Centro di controllo HP / Microsoft" {
	echo "Sto avviando Centro di controllo HP / Microsoft..."
	insmod part_gpt
	insmod fat
	insmod search_fs_uuid
	insmod chain
	search --fs-uuid --no-floppy --set=root --hint-bios=hd0,gpt2 --hint-efi=hd0,gpt2 --hint-baremetal=ahci0,gpt2 763A-9CB6
	chainloader (${root})/EFI/HP/boot/bootmgfw.efi
}

menuentry "Spegnimento del computer" {
	echo "Sto spegnendo il computer..."
	halt
}

menuentry "Riavvio del computer" {
	echo "Sto riavvinado il computer..."
	reboot
}</pre>
<h5>
<span id="Voce_di_men.C3.B9_per_GNU.2FLinux"></span><span class="mw-headline" id="Voce_di_menù_per_GNU/Linux">Voce di menù per GNU/Linux</span>
</h5>
<p>Se l'altra distro è in <code>/dev/sda2</code>:
</p>
<pre>menuentry "Other Linux" {
	set root=(hd0,2)
	linux /boot/vmlinuz (si aggiungano altre opzioni da passare al kernel, se richieste)
	initrd /boot/initrd.img (se il kernel lo richiede)
}</pre>
<h5>
<span id="Voce_di_men.C3.B9_per_FreeBSD"></span><span class="mw-headline" id="Voce_di_menù_per_FreeBSD">Voce di menù per FreeBSD</span>
</h5>
<p>Richiede che FreeBSD sia installato su una singola partizione formattata come UFS. Se FreeBSD risiede su <code>sda4</code>:
</p>
<pre>menuentry "FreeBSD" {
	set root=(hd0,4)
	chainloader +1
}</pre>
<h5>
<span id="Voce_di_men.C3.B9_per_Windows_XP"></span><span class="mw-headline" id="Voce_di_menù_per_Windows_XP">Voce di menù per Windows XP</span>
</h5>
<p>Se windows è installato in <code>/dev/sda3</code>:
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Si ricordi che è necessario puntare i comandi <code>set root</code> e <code>chainloader</code> alla partizione riservata di sistema, ossia quella che crea Windows durante l'installazione, e non alla partizione sulla quale risiede effettivamente Windows.
L'esempio trattato sotto funziona se la vostra partizione riservata è <code>sda3</code>.</div>
<pre>menuentry "Windows XP" {
	set root="(hd0,3)"
	chainloader +1
}</pre>
<p>Se il bootloader di Windows è su un disco rigido differente da quello di GRUB, potrebbe essere necessario ingannare Windows per fargli credere di risiedere nel primo drive. Ciò era possibile utilizzando <code>drivemap</code>. Assumendo che GRUB si trovi su <code>hd0</code> e Windows su  <code>hd2</code>, sarà necessario aggiungere la seguente riga dopo <code>set root</code>:
</p>
<pre>drivemap -s hd0 hd2</pre>
<h5>
<span id="Voce_di_men.C3.B9_per_Windows_installato_in_modalit.C3.A0_UEFI-GPT"></span><span class="mw-headline" id="Voce_di_menù_per_Windows_installato_in_modalità_UEFI-GPT">Voce di menù per Windows installato in modalità UEFI-GPT</span>
</h5>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Questa voce funzionerà solo se il sistema viene avviato in modalità UEFI e solo se la "bitness" di Windows corrisponde a quella di UEFI. Si noti che tale voce NON funzionerà su GRUB per sistemi BIOS. A tal proposito si legga <a href="../en/Dual_boot_with_Windows.html#Windows_UEFI_vs_BIOS_limitations" class="mw-redirect" title="Windows and Arch Dual Boot">qui</a> e <a href="../en/Dual_boot_with_Windows.html#Bootloader_UEFI_vs_BIOS_limitations" class="mw-redirect" title="Windows and Arch Dual Boot">qui</a> per ulteriori informazioni.</div>
<pre>if [ "${grub_platform}" == "efi" ]; then
	menuentry "Microsoft Windows Vista/7/8/8.1 x86_64 UEFI-GPT" {
		insmod part_gpt
		insmod fat
		insmod search_fs_uuid
		insmod chain
		search --fs-uuid --set=root $hints_string $fs_uuid
		chainloader /EFI/Microsoft/Boot/bootmgfw.efi
	}
fi
</pre>
<p>Il valore delle variabili <code>$hints_string</code> e <code>$fs_uuid</code> si ottiene con i seguenti comandi:
Per <code>$fs_uuid</code>:
</p>
<pre># grub-probe --target=fs_uuid $esp/EFI/Microsoft/Boot/bootmgfw.efi
1ce5-7f28</pre>
<p>Per <code>$hints_string</code>:
</p>
<pre># grub-probe --target=hints_string $esp/EFI/Microsoft/Boot/bootmgfw.efi
--hint-bios=hd0,gpt1 --hint-efi=hd0,gpt1 --hint-baremetal=ahci0,gpt1</pre>
<p>I due comandi di cui sopra assumono che la ESP di Windows sia montata in <code>$esp</code>. Si noti che potrebbero esserci differenze tra lettere maiuscole e minuscole nel percorso che identifica la posizione del file EFI di Windows.
</p>
<h5>
<span id="Voce_di_men.C3.B9_per_lo_spegnimento_del_sistema"></span><span class="mw-headline" id="Voce_di_menù_per_lo_spegnimento_del_sistema">Voce di menù per lo spegnimento del sistema</span>
</h5>
<pre>menuentry "System shutdown" {
	echo "System shutting down..."
	halt
}</pre>
<h5>
<span id="Voce_di_men.C3.B9_per_il_riavvio_del_sistema"></span><span class="mw-headline" id="Voce_di_menù_per_il_riavvio_del_sistema">Voce di menù per il riavvio del sistema</span>
</h5>
<pre>menuentry "System restart" {
	echo "System rebooting..."
	reboot
}</pre>
<h5>
<span id="Windows_installato_in_modalit.C3.A0_BIOS-MBR"></span><span class="mw-headline" id="Windows_installato_in_modalità_BIOS-MBR">Windows installato in modalità BIOS-MBR</span>
</h5>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> GRUB supporta l'avvio diretto di <code>bootmgr</code> e il chainload del settore di boot non è più richiesto per avviare Windows su configurazioni BIOS-MBR.</div>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Attenzione:</strong> Si noti che <code>bootmgr</code> è contenuto nella partizione di sistema, non in quella principale che ospita i file di sistema di Windows (C:). Quando si elencano tutti gli UUIDs con <code>blkid</code> la partizione viene evidenziata come <code>LABEL="SYSTEM RESERVED"</code> o <code>LABEL="SYSTEM"</code> ed ha una dimensione che varia dai 100 ai 200 MB, similmente alla partizione di boot di Arch. Si consulti <a href="https://en.wikipedia.org/wiki/System_partition_and_boot_partition" class="extiw" title="wikipedia:System partition and boot partition">wikipedia:System_partition_and_boot_partition</a> per ulteriori informazioni.</div>
<p>Per tutto il resto della sezione, si assumerà che la propria partizione di Windows sia <code>/dev/sda1</code>. Partizioni differenti varieranno di conseguenza anche il valore di <code>hd0,msdos1</code>. Si individui l'UUID della partizione di sistema di windows, dove bootmgr e i suoi files risiedono. Per esempio, se <code>bootmgr</code> si trova in <code>/media/SYSTEM_RESERVED/bootmgr</code>:
</p>
<p>Per Windows Vista/7/8/8.1:
</p>
<pre># grub-probe --target=fs_uuid /media/SYSTEM_RESERVED/bootmgr
69B235F6749E84CE
</pre>
<pre># grub-probe --target=hints_string /media/SYSTEM_RESERVED/bootmgr
--hint-bios=hd0,msdos1 --hint-efi=hd0,msdos1 --hint-baremetal=ahci0,msdos1
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Se si utilizza Windows XP, si sostituisca <code>bootmgr</code> con <code>ntldr</code> nei comandi di cui sopra. Si noti inoltre che potrebbe non essere presente una partizione di sistema separata: si effettui la ricerca del file NTLDR sulla partizione principale di Windows.</div>
<p>Si aggiunga quindi il codice sotto riportato al file <code>/etc/grub.d/40-custom</code> o <code>/boot/grub/custom.cfg</code> e si rigeneri il <code>grub.cfg</code> con <code>grub-mkconfig</code> come spiegato sopra per effettuare il chainload di Windows (XP, Vista, 7 o 8) installato in modalità BIOS-MBR:
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Le voci sotto riportate NON funzioneranno su GRUB per sistemi BIOS. A tal proposito si legga <a href="../en/Dual_boot_with_Windows.html#Windows_UEFI_vs_BIOS_limitations" class="mw-redirect" title="Windows and Arch Dual Boot">qui</a> e <a href="../en/Dual_boot_with_Windows.html#Bootloader_UEFI_vs_BIOS_limitations" class="mw-redirect" title="Windows and Arch Dual Boot">qui</a> per ulteriori informazioni.</div>
<p><br>
Per Windows Vista/7/8/8.1:
</p>
<pre>if [ "${grub_platform}" == "pc" ]; then
  menuentry "Microsoft Windows Vista/7/8/8.1 BIOS-MBR" {
    insmod part_msdos
    insmod ntfs
    insmod search_fs_uuid
    insmod ntldr     
    search --fs-uuid --set=root --hint-bios=hd0,msdos1 --hint-efi=hd0,msdos1 --hint-baremetal=ahci0,msdos1 69B235F6749E84CE
    ntldr /bootmgr
  }
fi</pre>
<p>Per Windows XP:
</p>
<pre>if [ "${grub_platform}" == "pc" ]; then
  menuentry "Microsoft Windows XP" {
    insmod part_msdos
    insmod ntfs
    insmod search_fs_uuid
    insmod ntldr     
    search --fs-uuid --set=root --hint-bios=hd0,msdos1 --hint-efi=hd0,msdos1 --hint-baremetal=ahci0,msdos1 69B235F6749E84CE
    ntldr /bootmgr
  }
fi</pre>
<p><br>
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> <code>nn</code> dovrebbe avere un valore superiore a <code>06</code> affinchè gli script di sistema siano eseguiti per primi.</div>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> In alcuni casi (ad esempio se GRUB viene installato prima di Windows 8), potrebbe verificarsi un errore riguardante <code>\boot\bcd</code> (codice errore <code>0xC000000F</code>) durante l'avvio di Windows. È possibile risolvere il problema avviando la console di ripristino di Windows (si utilizzi il suo disco di installazione) ed eseguendo:
<pre>x:\&gt;bootrec.exe /fixboot
x:\&gt;bootrec.exe /rebuildbcd
</pre>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Attenzione:</strong> Non utilizzare <code>bootrec.exe /Fixmbr</code>, poichè cancellerebbe GRUB.</div>
</div>
<p>Il file <code>/etc/grub.d/40_custom</code> può essere utilizzato come template per creare <code>/etc/grub.d/nn_custom</code>, dove il numero <code>nn</code> definisce l'ordine in cui gli script sono eseguiti, determinando di conseguenza il posizionamento delle voci nel menu di GRUB.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Il numero <code>nn</code> dovrebbe avere un valore maggiore di 6, affinchè vengano prima eseguiti altri script necessari.</div>
<h4><span class="mw-headline" id="Con_Windows_usando_EasyBCD_e_NeoGRUB">Con Windows usando EasyBCD e NeoGRUB</span></h4>
<p>Poichè NeoGRUB non capisce il nuovo formato dei menu di GRUB, sarà necessario effettuare il chainload di GRUB, sostituendo il contenuto del vostro <code>C:\NST\menu.lst</code> con:
</p>
<pre>default 0
timeout 1
</pre>
<pre>title       Chainload into GRUB v2
root        (hd0,7)
kernel      /boot/grub/i386-pc/core.img
</pre>
<h3>
<span id="Avviare_un.27immagine_ISO9660_direttamente_da_GRUB"></span><span class="mw-headline" id="Avviare_un'immagine_ISO9660_direttamente_da_GRUB">Avviare un'immagine ISO9660 direttamente da GRUB</span>
</h3>
<p>GRUB supporta l'avvio di immagini ISO attraveso l'utilizzo di dispositivi di loopback. Si veda a tal proposito <a href="../en/Multiboot_USB_drive.html#Using_GRUB_and_loopback_devices" title="Multiboot USB drive">Multiboot USB drive#Using GRUB and loopback devices</a>.
</p>
<h3><span class="mw-headline" id="LVM">LVM</span></h3>
<p>Se si usa <a href="../it/LVM.html" title="LVM (Italiano)">LVM</a> per la propria <code>/boot</code>, si aggiunga la seguente linea prima delle varie voci:
</p>
<pre>insmod lvm
</pre>
<p>e si specifichi la propria root nella menuentry in questo modo:
</p>
<pre>set root=lvm/"nome_gruppo_lvm"-"nome_partizione_logica_di_boot_lvm"
</pre>
<p>Esempio:
</p>
<pre># (0) Arch Linux
menuentry "Arch Linux" {
insmod lvm
set root=lvm/VolumeGroup-lv_boot
# you can only set following two lines
linux /vmlinuz-linux root=/dev/mapper/VolumeGroup-root ro
initrd /initramfs-linux.img
}</pre>
<h3><span class="mw-headline" id="RAID">RAID</span></h3>
<p>GRUB permette di trattare i volumi in configurazione RAID in modo semplice. Si aggiunga <code>insmod mdraid</code> al <code>grub.cfg</code> che consentirà di riferirsi al volume in modo nativo. Ad esempio, <code>/dev/md0</code> diventa:
</p>
<pre>set root=(md/0)
</pre>
<p>mentre un volume RAID partizionato (es. <code>/dev/md0p1</code> diventa:
</p>
<pre>set root=(md/0,1)
</pre>
<p>Per installare GRUB su una partizione <code>/boot</code> in RAID1 (o comunque se <code>/boot</code> si trova su una partizione root in RAID1) su sistemi con GPT e partizione di boot BIOS ef02, si esegua <code>grub-install</code> su ciascuna unità.
</p>
<p>Ad esempio:
</p>
<pre># grub-install --target=i386-pc --recheck --debug /dev/sda &amp;&amp; grub-install --target=i386-pc --recheck --debug /dev/sdb
</pre>
<p>Dove l'array RAID1 che ospita la partizione <code>/boot</code> è formato da <code>/dev/sda</code> e <code>/dev/sdb</code>.
</p>
<h3><span class="mw-headline" id="Usare_le_etichette">Usare le etichette</span></h3>
<p>È possibile usare le etichette (stringhe che identificano le partizioni in una maniera leggibile dall'utente), usando l'opzione <code>--label</code> del comando <code>search</code>. Innanzitutto, si apponga un'etichetta alle proprie partizioni:
</p>
<pre># tune2fs -L <i>ETICHETTA</i> <i>PARTIZIONE</i>
</pre>
<p>Poi si aggiunga una voce usando le etichette:
</p>
<pre>menuentry "Arch Linux, session texte" {
    search --label --set=root archroot
    linux /boot/vmlinuz-linux root=/dev/disk/by-label/archroot ro
    initrd /boot/initramfs-linux.img
}</pre>
<h3><span class="mw-headline" id="Proteggere_con_una_password_il_menu_di_GRUB">Proteggere con una password il menu di GRUB</span></h3>
<p>Se si desidera rendere più sicuro GRUB e fare in modo che nessuno possa cambiare i parametri di boot od usare la riga di comando, è possibile aggiungere un nome utente e password ai files di configurazione di GRUB. A tal fine, si esegua <code>grub-mkpasswd_pbkdf2</code>. Si inserisca una password e la si confermi.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">grub-mkpasswd-pbkdf2</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[...]
Your PBKDF2 is grub.pbkdf2.sha512.10000.C8ABD3E93C4DFC83138B0C7A3D719BC650E6234310DA069E6FDB0DD4156313DA3D0D9BFFC2846C21D5A2DDA515114CF6378F8A064C94198D0618E70D23717E82.509BFA8A4217EAD0B33C87432524C0B6B64B34FBAD22D3E6E6874D9B101996C5F98AB1746FE7C7199147ECF4ABD8661C222EEEDB7D14A843261FFF2C07B1269A</pre>
<p>Si aggiungano le seguenti stringhe a <code>/etc/grub.d/40_custom</code>:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/grub.d/40_custom</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">set superusers="<b>username</b>"
password_pbkdf2 <b>username</b> <b>&lt;password&gt;</b></pre>
<p>Dove a &lt;password&gt; corrisponde la stringa generata con <code>grub-mkpasswd_pbkdf2</code>.
</p>
<p>Si rigeneri il file di configurazione. La riga di comando e i parametri di boot di GRUB sono ora protetti.
</p>
<p>Le impostazioni di cui sopra possono essere rese meno restrittive e personalizzate aggiungendo più utenti, come spiegato nel capitolo "Security" del <a rel="nofollow" class="external text" href="https://www.gnu.org/software/grub/manual/grub.html#Security">manuale di GRUB</a>.
</p>
<h3><span class="mw-headline" id="Nascondere_il_menu_di_GRUB_e_farlo_apparire_alla_pressione_del_tasto_Shift">Nascondere il menu di GRUB e farlo apparire alla pressione del tasto Shift</span></h3>
<p>Per ridurre al minimo i tempi di boot è possibile nascondere il menu di GRUB, invece di aspettare lo scadere del timeout. È possibile nascondere il menu di default e farlo apparire solo qualora venga premuto il tasto <code>Shift</code> durante l'avvio di GRUB.
</p>
<p>Per ottenere questo risultato, aggiungere quanto segue al proprio <code>/etc/default/grub</code>:
</p>
<pre>GRUB_FORCE_HIDDEN_MENU="true"
</pre>
<p>Sarà inoltre necessario creare e rendere eseguibile il seguente file:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/grub.d/31_hold_shift</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">#! /bin/sh
set -e

# grub-mkconfig helper script.
# Copyright (C) 2006,2007,2008,2009  Free Software Foundation, Inc.
#
# GRUB is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# GRUB is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GRUB.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

prefix="/usr"
exec_prefix="${prefix}"
datarootdir="${prefix}/share"

export TEXTDOMAIN=grub
export TEXTDOMAINDIR="${datarootdir}/locale"

source "${datarootdir}/grub/grub-mkconfig_lib"

found_other_os=

make_timeout () {

  if [ "x${GRUB_FORCE_HIDDEN_MENU}" = "xtrue" ] ; then 
    if [ "x${1}" != "x" ] ; then
      if [ "x${GRUB_HIDDEN_TIMEOUT_QUIET}" = "xtrue" ] ; then
    verbose=
      else
    verbose=" --verbose"
      fi

      if [ "x${1}" = "x0" ] ; then
    cat &lt;&lt;EOF
if [ "x\${timeout}" != "x-1" ]; then
  if keystatus; then
    if keystatus --shift; then
      set timeout=-1
    else
      set timeout=0
    fi
  else
    if sleep$verbose --interruptible 3 ; then
      set timeout=0
    fi
  fi
fi
EOF
      else
    cat &lt;&lt; EOF
if [ "x\${timeout}" != "x-1" ]; then
  if sleep$verbose --interruptible ${GRUB_HIDDEN_TIMEOUT} ; then
    set timeout=0
  fi
fi
EOF
      fi
    fi
  fi
}

adjust_timeout () {
  if [ "x$GRUB_BUTTON_CMOS_ADDRESS" != "x" ]; then
    cat &lt;&lt;EOF
if cmostest $GRUB_BUTTON_CMOS_ADDRESS ; then
EOF
    make_timeout "${GRUB_HIDDEN_TIMEOUT_BUTTON}" "${GRUB_TIMEOUT_BUTTON}"
    echo else
    make_timeout "${GRUB_HIDDEN_TIMEOUT}" "${GRUB_TIMEOUT}"
    echo fi
  else
    make_timeout "${GRUB_HIDDEN_TIMEOUT}" "${GRUB_TIMEOUT}"
  fi
}

  adjust_timeout

    cat &lt;&lt;EOF
if [ "x\${timeout}" != "x-1" ]; then
  if keystatus; then
    if keystatus --shift; then
      set timeout=-1
    else
      set timeout=0
    fi
  else
    if sleep$verbose --interruptible 3 ; then
      set timeout=0
    fi
  fi
fi
EOF
</pre>
<p>Si renda eseguibile lo script e si rigeneri il file di configurazione di GRUB:
</p>
<pre># chmod a+x /etc/grub.d/31_hold_shift
# grub-mkconfig -o /boot/grub/grub.cfg
</pre>
<h2><span class="mw-headline" id="Combinare_UUID_e_scripting">Combinare UUID e scripting</span></h2>
<p>Se si vogliono usare gli UUID per sopperire al mapping inaffidabile dei dispositivi effettuato dal BIOS, oppure si stanno avendo difficoltà con la sintassi di GRUB, ecco un esempio che usa gli UUID e un piccolo script per far puntare GRUB alle giuste partizioni. Tutto ciò che si dovrà fare, sarà sostituire gli UUID dell'esempio con quelli corretti per il proprio sistema (L'esempio si applica a sistemi con una partizione di boot separata e va modificato di conseguenza in caso di partizioni aggiuntive).
</p>
<pre>menuentry "Arch Linux 64" {
     # Si impostino gli UUID delle proprie partizioni di boot e root
     set the_boot_uuid=ece0448f-bb08-486d-9864-ac3271bd8d07   
     set the_root_uuid=c55da16f-e2af-4603-9e0b-03f5f565ec4a
   
     # (Nota: In caso non si disponga di una partizione di boot separata, i due UUID saranno uguali)
   
     # Otteniamo gli identificativi dei dispositivi contenenti le partizioni di boot/root e li impostiamo nelle variabili "grub_boot" e "root"
     search --fs-uuid $the_root_uuid --set=root       
     search --fs-uuid $the_boot_uuid --set=grub_boot
   
     # Controllo per verificare che boot e root siano uguali
     # Se lo sono, allora aggiungo "/boot" a $grub_root, dal momento che $grub_root è effettivamente la partizione di root
     if [ $the_boot_uuid == $the_root_uuid] ; then
         set grub_boot=$grub_boot/boot
     else
         set grub_boot=($grub_boot)
     fi
   
     # $grub_boot indica ora il dispositivo corretto e i seguenti comandi saranno in grado di trovare il kernel e l'immagine initrd senza problemi
     linux ($grub_boot)/vmlinuz-linux root=/dev/disk/by-uuid/$uuid_os_root ro
     initrd ($grub_boot)/initramfs-linux.img
 }</pre>
<h2><span class="mw-headline" id="Usare_la_shell">Usare la shell</span></h2>
<p>Poichè l'MBR è troppo piccolo per contenere tutti i moduli di GRUB, solo il menù e i comandi fondamentali risiedono lì. La maggior parte delle funzionalità di GRUB è contenuta nei moduli in <code>/boot/grub</code>, che sono caricati quando necessario. In caso di errori (ad esempio se viene alterata la tabella delle partizioni), GRUB potrebbe non riuscire ad effettuare il boot, ed avviare una shell al posto del menù classico.
</p>
<p>GRUB offre diversi tipi di shell. Se vi sono problemi nella lettura del menu, ma il bootloader è comunque in grado di trovare il disco dove GRUB risiede, è probabile che si sarà lasciati nella shell "normale":
</p>
<pre>sh:grub&gt;
</pre>
<p>In caso di problemi più seri (GRUB non riesce a trovare i files richiesti), potrebbe venir visualizzata la shell di emergenza:
</p>
<pre>grub rescue&gt;
</pre>
<p>La shell di emergenza è una versione ridotta di quella normale, ed offre di conseguenza, un numero ridotto di funzionalità. Si provi a caricare il modulo <code>normal</code>, e poi ad avviare la shell classica:
</p>
<pre>grub rescue&gt; set prefix=(hdX,Y)/boot/grub
grub rescue&gt; insmod (hdX,Y)/boot/grub/normal.mod
rescue:grub&gt; normal</pre>
<h4><span class="mw-headline" id="Supporto_al_Pager">Supporto al Pager</span></h4>
<p>GRUB supporta il pager per rendere agevole la lettura di output lunghi. Si noti che questa funzionalità è disponibile solamente nella shell normale, e non in quella d'emergenza. Per attivarla, si scriva:
</p>
<pre>sh:grub&gt; set pager=1
</pre>
<h3><span class="mw-headline" id="Utilizzare_la_shell_dei_comanti_per_avviare_altri_sistemi_operativi">Utilizzare la shell dei comanti per avviare altri sistemi operativi</span></h3>
<pre>grub&gt;
</pre>
<p>È possibile utilizzare la shell di GRUB per avviare altri sistemi operativi, come ad esempio sistemi Windows o Linux installati su partizione e avviarli tramite <b>chainloading</b>.
</p>
<p>Il <i>chainloading</i> consiste nell'avviare un bootloader, che può trovarsi all'inizio del disco (per sistemi MBR) o all'inizio di una partizione, tramite un altro bootloader.
</p>
<h4><span class="mw-headline" id="Effettuare_il_chainloading_di_una_partizione">Effettuare il chainloading di una partizione</span></h4>
<pre>set root=(hdX,Y)
chainloader +1
boot
</pre>
<p>Dove <code>X</code> indica il disco fisso da cui avviare l'altro bootloader ed ha valori che partono da 0, mentre <code>Y</code> identifica il numero della partizione che ci interessa.
</p>
<p>L'esempio seguente mostra come avviare un'installazione di Windows situata nella prima partizione del primo hard disk:
</p>
<pre>set root=(hd0,1)
chainloader +1
boot
</pre>
<p>È inoltre possibile avviare un'installazione di GRUB in una partizione utilizzando lo stesso metodo di cui sopra.
</p>
<h4>
<span id="Effettuare_il_chainloading_di_un_disco.2Fdrive"></span><span class="mw-headline" id="Effettuare_il_chainloading_di_un_disco/drive">Effettuare il chainloading di un disco/drive</span>
</h4>
<pre>set root=hdX
chainloader +1
boot
</pre>
<h4>
<span id="Effettuare_il_chainloading_di_sistemi_Windows.2FLinux_installati_in_modalit.C3.A0_UEFI"></span><span class="mw-headline" id="Effettuare_il_chainloading_di_sistemi_Windows/Linux_installati_in_modalità_UEFI">Effettuare il chainloading di sistemi Windows/Linux installati in modalità UEFI</span>
</h4>
<pre>insmod ntfs
set root=(hd0,gpt4)
chainloader (${root})/EFI/Microsoft/Boot/bootmgfw.efi
boot
</pre>
<p><code>insmod ntfs</code> viene utilizzato per caricare il modulo NTFS necessario al caricamento di Windows.
</p>
<p><code>(hd0,gpt4)</code> o <code>/dev/sda4</code> identifica la partizione EFI di sistema (ESP).
</p>
<p>Il percorso che segue la voce <code>chainloader</code> identifica il file .efi del quale si vuole fare il chainloading.
</p>
<h4><span class="mw-headline" id="Avvio_normale">Avvio normale</span></h4>
<p>Si vedano gli esempi in <a href="#Usare_la_console_di_emergenza">#Usare la console di emergenza</a>.
</p>
<h2><span class="mw-headline" id="Tools_grafici_per_la_configurazione">Tools grafici per la configurazione</span></h2>
<p>È possibile installare i seguenti pacchetti:
</p>
<ul><li>
<b>grub-customizer</b> — Consente di personalizzare il bootloader (GRUB o BURG)</li></ul>
<dl><dd>
<a rel="nofollow" class="external free" href="https://launchpad.net/grub-customizer">https://launchpad.net/grub-customizer</a> || <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=grub-customizer">grub-customizer</a></span>
</dd></dl>
<ul><li>
<b>grub2-editor</b> — Control module di KDE4 per configurare GRUB</li></ul>
<dl><dd>
<a rel="nofollow" class="external free" href="https://kde-apps.org/content/show.php?content=139643">https://kde-apps.org/content/show.php?content=139643</a><sup>[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">link interrotto</a> 2020-08-02]</sup> || <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/grub2-editor/">grub2-editor</a></span><sup><small>AUR</small></sup><sup>[<a href="../en/Help:Procedures.html#Fix_broken_package_links" title="Help:Procedures">broken link</a>: package not found]</sup>
</dd></dl>
<ul><li>
<b>startupmanager</b> — Applicazione grafica per cambiare le impostazioni di GRUB Legacy, GRUB, Usplash e Splashy (<a rel="nofollow" class="external text" href="https://launchpad.net/startup-manager/+announcement/8300">abbandonato</a>)</li></ul>
<dl><dd>
<a rel="nofollow" class="external free" href="https://sourceforge.net/projects/startup-manager/">https://sourceforge.net/projects/startup-manager/</a> || <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/startupmanager/">startupmanager</a></span><sup><small>AUR</small></sup><sup>[<a href="../en/Help:Procedures.html#Fix_broken_package_links" title="Help:Procedures">broken link</a>: package not found]</sup>
</dd></dl>
<h2>
<span id="parttool_per_hide.2Funhide"></span><span class="mw-headline" id="parttool_per_hide/unhide">parttool per hide/unhide</span>
</h2>
<p>Se si hanno sistemi Windows 9x installati con dischi <code>C:\</code> nascosti, GRUB dispone delle opzioni <code>hide/unhide</code> attraverso <code>parttool</code>. Ad esempio, per effettuare ilboot del terzo disco <code>C:\</code> di tre sistemi Windows 9x installati, si avvii la shell e:
</p>
<pre>parttool hd0,1 hidden+ boot-
parttool hd0,2 hidden+ boot-
parttool hd0,3 hidden- boot+
set root=hd0,3
chainloader +1
boot</pre>
<h2><span class="mw-headline" id="Usare_la_console_di_emergenza">Usare la console di emergenza</span></h2>
<p>Si veda innanzitutto <a href="#Usare_la_shell">#Usare la shell</a>. Se non si è in grado di avviare la shell standard, una possibile soluzione è quella di effettuare il boot tramite LiveCD o con qualche altro disco di ripristino per correggere gli errori di configurazione e reinstallare GRUB. Tuttavia, un disco di ripristino non è sempre disponibile (né tantomeno necessario), e la console di emergenza è sorprendentemente robusta.
</p>
<p>I comandi disponibili in questa modalità includono <code>insmod</code>, <code>ls</code>, <code>set</code> e <code>unset</code>. Questo esempio usa <code>set</code> ed <code>insmod</code>. <code>set</code> modifica il valore delle variabili, mentre <code>insmod</code> aggiunge nuovi moduli per espandere le funzionalità di base.
</p>
<p>Prima di iniziare, è necessario che l'utente sappia la posizione della propria partizione di <code>/boot</code> (sia essa separata o una sottodirectory della partizione root):
</p>
<pre>grub rescue&gt; set prefix=(hdX,Y)/boot/grub
</pre>
<p>Dove X è il numero relativo al drive ed Y quello della partizione.
Per espandere le funzionalità della console, si inserisca il modulo <code>linux</code>.
</p>
<pre>grub rescue&gt; insmod i386-pc/linux.mod
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Se si sta usando una partizione di boot separata, si ometta <code>/boot</code> dal percorso. (esempio: <code>set prefix=(hdX,Y)/grub</code>).</div>
<p>Ciò rende disponibili i comandi <code>linux</code> ed <code>initrd</code>, che dovrebbero essere familiari (si veda <a href="#Configurazione_avanzata">#Configurazione avanzata</a>).
</p>
<p>Un esempio, avvio di Arch Linux:
</p>
<pre>set root=(hd0,5)
linux /boot/vmlinuz-linux root=/dev/sda5
initrd /boot/initramfs-linux.img
boot</pre>
<p>Di nuovo, in caso di partizione di boot separata, si cambino i comandi di conseguenza:
</p>
<pre>set root=(hd0,5)
linux /vmlinuz-linux root=/dev/sda6
initrd /initramfs-linux.img
boot</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Se si riscontra l'errore <code>error: premature end of file /NOME_KERNEL</code> durante l'esecuzione del comando <code>linux</code> è possibile provare ad utilizzare il comando <code>linux16</code> al suo posto.</div>
<p>Dopo aver avviato con successo l'installazione di Arch Linux, è possibile correggere <code>grub.cfg</code> e procedere con la reinstallazione di GRUB.
</p>
<p>Per reinstallare GRUB nel MBR, cambiando <code>/dev/sda</code> secondo le proprie esigenze. Si veda <a href="#Installazione">#Installazione</a> per i dettagli.
</p>
<h2><span class="mw-headline" id="Risoluzione_dei_problemi">Risoluzione dei problemi</span></h2>
<h3><span class="mw-headline" id="Sistemi_con_BIOS_Intel_non_effettuano_il_boot_da_partizioni_GPT">Sistemi con BIOS Intel non effettuano il boot da partizioni GPT</span></h3>
<h4><span class="mw-headline" id="MBR">MBR</span></h4>
<p>Alcuni BIOS Intel richiedono la presenza al boot di una partizione MBR contrassegnata come "avviabile", cosa che rende di fatto inusabili configurazioni basate su GPT.
</p>
<p>È possibile aggirare il problema utilizzando (ad esempio) <code>fdisk</code> per segnare una delle partizioni GPT (preferibilmente la partizione da 1007 KiB che si è creata per GRUB) come avviabile. Si utilizzi <code>fdisk</code> puntandolo all'HD relativo (ad esempio <code>/dev/sda</code>), quindi si prema <code>a</code> e si selezioni la partizione da contrassegnare come avviabile (probabilmente la prima) utilizzando il numero corrispondente e infine si prema <code>w</code> per scrivere le modifiche nel MBR.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Il procedimento di cui sopra deve essere eseguito in <code>fdisk</code> o tools simili e NON via GParted o altri, dal momento che questi non impostano il flag "avviabile" nel MBR.</div>
<p>Ulteriori informazioni sono disponibili a  <a rel="nofollow" class="external text" href="https://www.rodsbooks.com/gdisk/bios.html">questo</a> indirizzo.
</p>
<h4><span class="mw-headline" id="EFI">EFI</span></h4>
<p>Alcuni firmware UEFI richiedono la presenza di un'immagine avviabile in un percorso specifico prima di poter mostrare le voci di avvio. Se si rientra in questa categoria <code>grub-install</code> segnalerà che <code>efibootmgr</code> ha agiunto una voce per l'avvio di GRUB, ma quest'ultima non verrà poi visualizzata all'interno del menu di VisualBIOS per la scelta dell'ordine di boot.
La soluzione consiste nel posizionare un'ìmmagine in uno dei percorsi in questione.
Assumendo che la propria partizione EFI sia in <code>/boot/efi</code>, i seguenti comandi risolveranno il problema:
</p>
<pre>mkdir /boot/efi/EFI/boot
cp /boot/efi/EFI/grub/grubx64.efi /boot/efi/EFI/boot/bootx64.efi
</pre>
<p>La soluzione proposta ha funzionato su una scheda madre Intel DH87MC con firmware datato Gennaio 2014.
</p>
<h3><span class="mw-headline" id="Abilitare_i_messaggi_di_debug_in_GRUB">Abilitare i messaggi di debug in GRUB</span></h3>
<p>Si aggiunga:
</p>
<pre>set pager=1
set debug=all
</pre>
<p>Al <code>grub.cfg</code>.
</p>
<h3>
<span id="Correggere_l.27errore_di_GRUB_.22no_suitable_mode_found.22"></span><span class="mw-headline" id="Correggere_l'errore_di_GRUB_&quot;no_suitable_mode_found&quot;">Correggere l'errore di GRUB "no suitable mode found"</span>
</h3>
<p>Se si ottiene questo errore alla scelta di un'opzione di boot:
</p>
<pre>error: no suitable mode found
Booting however
</pre>
<p>Allora sarà necessario inizializzare il terminale grafico di GRUB (gfxterm), usando una modalità video appropriata (gfxmode). Quest'ultima viene passata da GRUB al kernel linux usando l'opzione <code>gfxpayload</code>.
Sui sistemi UEFI, se la modalità video di GRUB non viene inizializzata, non verranno visualizzati i messaggi di boot del kernel (almeno fino all'attivazione del KMS).
</p>
<p>Si copi <code>/usr/share/grub/unicode.pf2</code> in <code>${GRUB_PREFIX_DIR</code>} (<code>/boot/grub</code> su sistemi BIOS e UEFI. Se GRUB UEFI è stato installato con l'opzione <code>--boot-directory=$esp/EFI</code>  abilitata, allora il percorso sarà <code>$esp/EFI/grub</code>).
</p>
<pre># cp /usr/share/grub/unicode.pf2 ${GRUB_PREFIX_DIR}
</pre>
<p>Se il file <code>/usr/share/grub/unicode.pf2</code> non esiste, si installi il pacchetto <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=bdf-unifont">bdf-unifont</a></span> e si proceda alla creazione e copia dello stesso in <code>${GRUB_PREFIX_DIR</code>}.
</p>
<pre># grub-mkfont -o unicode.pf2 /usr/share/fonts/misc/unifont.bdf
</pre>
<p>Nel file <code>grub.cfg</code>, si aggiungano le seguenti linee per consentire a GRUB di passare correttamente la modalità video al kernel, altrimenti si otterrà uno schermo nero, benchè il boot sia effettuato regolarmente senza che il sistema si blocchi:
</p>
<p>Sistemi BIOS
</p>
<pre>insmod vbe
</pre>
<p>Sistemi UEFI
</p>
<pre>insmod efi_gop
insmod efi_uga
</pre>
<p>Si aggiunga poi il seguente codice (comune a sistemi BIOS e UEFI)
</p>
<pre>insmod font
</pre>
<pre>if loadfont ${prefix}/fonts/unicode.pf2
then
    insmod gfxterm
    set gfxmode=auto
    set gfxpayload=keep
    terminal_output gfxterm
fi</pre>
<p>Come si può notare, affinchè <code>gfxterm</code> funzioni correttamente, il font <code>unicode.pf2</code> deve esistere in <code>${GRUB_PREFIX_DIR</code>}.
</p>
<h3>
<span id="messaggio_d.27errore_msdos-style"></span><span class="mw-headline" id="messaggio_d'errore_msdos-style">messaggio d'errore msdos-style</span>
</h3>
<pre>grub-setup: warn: This msdos-style partition label has no post-MBR gap; embedding won't be possible!
grub-setup: warn: Embedding is not possible. GRUB can only be installed in this setup by using blocklists.
            However, blocklists are UNRELIABLE and its use is discouraged.
grub-setup: error: If you really want blocklists, use --force.
</pre>
<p>Questo problema si verifica quando si tenta di installare GRUB in VMWare. Ulteriori informazioni <a rel="nofollow" class="external text" href="https://bbs.archlinux.org/viewtopic.php?pid=581760#p581760">qui</a>. Si spera in un fix in tempi brevi.
</p>
<p>Può anche verificarsi quando la partizione inizia subito dopo l'MBR (blocco 63), senza lasciare uno spazio di circa 1MB (2048 blocchi) prima dell'inizio della prima partizione. Si veda <a href="#Istruzioni_specifiche_per_Master_Boot_Record_(MBR)">#Istruzioni specifiche per Master Boot Record (MBR)</a>
</p>
<h3><span class="mw-headline" id="GRUB_UEFI_torna_alla_shell">GRUB UEFI torna alla shell</span></h3>
<p>Se GRUB viene caricato, ma torna alla shell di ripristino senza errori, il <code>grub.cfg</code> potrebbe trovarsi in una posizione sbagliata o non esistere del tutto. Questo problema potrebbe verificarsi se GRUB UEFI è stato installato con l'opzione <code>--boot-directory</code> abilitata, e il file <code>grub.cfg</code> non esiste, OPPURE se il numero identificativo della partizione di boot è cambiato (tale valore è infatti "hardcoded" nel file <code>grubx64.efi</code>).
</p>
<h3><span class="mw-headline" id="GRUB_UEFI_non_viene_caricato">GRUB UEFI non viene caricato</span></h3>
<p>Esempio di un sistema EFI funzionante:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># efibootmgr -v</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">BootCurrent: 0000
Timeout: 3 seconds
BootOrder: 0000,0001,0002
Boot0000* Grub HD(1,800,32000,23532fbb-1bfa-4e46-851a-b494bfe9478c)File(\efi\grub\grub.efi)
Boot0001* Shell HD(1,800,32000,23532fbb-1bfa-4e46-851a-b494bfe9478c)File(\EfiShell.efi)
Boot0002* Festplatte BIOS(2,0,00)P0: SAMSUNG HD204UI
</pre>
<p>Se lo schermo diveta nero per qualche secondo e GRUB passa alla prossima opzione di boot, come scritto <a rel="nofollow" class="external text" href="https://bbs.archlinux.org/viewtopic.php?pid=981560#p981560">in questo post</a>, spostare GRUB sulla partizione di root potrebbe aiutare.
</p>
<p>L'opzione di boot deve essere eliminata e ricreata dopo l'operazione.
Il campo relativo a grub dovrebbe ora essere simile a questo:
</p>
<pre>Boot0000* Grub HD(1,800,32000,23532fbb-1bfa-4e46-851a-b494bfe9478c)File(\grub.efi)
</pre>
<h3><span class="mw-headline" id="Invalid_signature">Invalid signature</span></h3>
<p>Se si riceve l'errore "invalid signature" cercando di avviare Windows, ad esempio dopo aver alterato la tabella partizioni o aver aggiunto altri hard disks, si provi a rimuovere la configurazione dei dispositivi di GRUB e lasciare che lo stesso la rigeneri:
</p>
<pre># mv /boot/grub/device.map /boot/grub/device.map-old
# grub-mkconfig -o /boot/grub/grub.cfg
</pre>
<p><code>grub-mkconfig</code> dovrebbe ora mostrare tutte le opzioni di boot, incluso Windows. Se il problema è risolto, si rimuova <code>/boot/grub/device.map-old</code>.
</p>
<h3><span class="mw-headline" id="Freeze_al_boot">Freeze al boot</span></h3>
<p>Se il boot si blocca senza errori dopo che GRUB carica il kernel e l'eventuale ramdisk, si provi a rimuovere il parametro del kernel <code>add_efi_memmap</code>.
</p>
<h3><span class="mw-headline" id="Ripristinare_GRUB_Legacy">Ripristinare GRUB Legacy</span></h3>
<ul><li>Spostare i files di GRUB Legacy o GRUB:</li></ul>
<pre># mv /boot/grub /boot/grub.nonfunctional
</pre>
<ul><li>Ripristinare il backup di GRUB Legacy in <code>/boot</code>:</li></ul>
<pre># cp -a /path/to/backup/grub /boot/
</pre>
<ul><li>Ripristinare il MBR e i 62 settori successivi del disco sda (PERICOLOSO):</li></ul>
<pre># dd if=/path/to/backup/first-sectors of=/dev/sdX bs=512 count=1
</pre>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Attenzione:</strong> Il comando sopra riportato ripristina anche la tabella delle partizioni. Si proceda con cautela.</div>
<p>Una soluzione più sicura è il ripristino del solo MBR:
</p>
<pre># dd if=/path/to/backup/mbr-boot-code of=/dev/sdX bs=446 count=1
</pre>
<h3><span class="mw-headline" id="Arch_non_rilevata_da_altre_distribuzioni">Arch non rilevata da altre distribuzioni</span></h3>
<p>Alcuni utenti hanno riportato che altre distribuzioni hanno problemi a rilevare Arch Linux automaticamente tramite <code>os-prober</code>. È possibile mitigare la situazione attraverso la creazione del file <code>/etc/lsb-release</code>: il file in questione e relativo tool per l'aggiornamento dello stesso sono disponibili nel pacchetto <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=lsb-release">lsb-release</a></span>, disponibile nei <a href="../it/Official_repositories.html" title="Official repositories (Italiano)">repository ufficiali</a>.
</p>
<h2><span class="mw-headline" id="Riferimenti">Riferimenti</span></h2>
<ol>
<li>Manuale ufficiale di GRUB - <a rel="nofollow" class="external free" href="https://www.gnu.org/software/grub/manual/grub.html">https://www.gnu.org/software/grub/manual/grub.html</a>
</li>
<li>Pagina del wiki di Ubuntu su GRUB - <a rel="nofollow" class="external free" href="https://help.ubuntu.com/community/Grub2">https://help.ubuntu.com/community/Grub2</a>
</li>
<li>Pagina del wiki di GRUB che spiega come compilarlo per sistemi UEFI - <a rel="nofollow" class="external free" href="https://help.ubuntu.com/community/UEFIBooting">https://help.ubuntu.com/community/UEFIBooting</a>
</li>
<li>La pagina di Wikipedia relativa alla <a href="https://en.wikipedia.org/wiki/BIOS_Boot_partition" class="extiw" title="wikipedia:BIOS Boot partition">partizione di Boot del BIOS</a>.</li>
</ol>
</div>
</div>
<div id="catlinks" class="catlinks" data-mw="interface">
<div id="mw-normal-catlinks" class="mw-normal-catlinks">
<a href="../Special:Categories.html" title="Special:Categories">Category</a>: <ul><li><a href="../it/Category:Boot_loaders.html" title="Category:Boot loaders (Italiano)">Boot loaders (Italiano)</a></li></ul>
</div>
<div id="mw-hidden-catlinks" class="mw-hidden-catlinks mw-hidden-cats-hidden">Hidden categories: <ul>
<li><a href="../en/Category:Pages_or_sections_flagged_with_Template:Translateme.html" title="Category:Pages or sections flagged with Template:Translateme">Pages or sections flagged with Template:Translateme</a></li>
<li><a href="../en/Category:Pages_with_broken_section_links.html" title="Category:Pages with broken section links">Pages with broken section links</a></li>
<li><a href="../en/Category:Pages_or_sections_flagged_with_Template:Accuracy.html" title="Category:Pages or sections flagged with Template:Accuracy">Pages or sections flagged with Template:Accuracy</a></li>
<li><a href="../en/Category:Pages_with_broken_package_links.html" title="Category:Pages with broken package links">Pages with broken package links</a></li>
</ul>
</div>
</div>
	</div>
</div>

<footer id="footer" class="mw-footer" role="contentinfo" style="margin: 0">
	<ul id="footer-info">
		<li>Retrieved from "<a dir="ltr" href="https://wiki.archlinux.org/index.php?title=GRUB_(Italiano)&amp;oldid=661232">https://wiki.archlinux.org/index.php?title=GRUB_(Italiano)&amp;oldid=661232</a>"</li>
		<li id="footer-info-lastmod"> This page was last edited on 17 April 2021, at 14:20.</li>
		<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3 or later</a> unless otherwise noted.</li>
	<br>
</ul>
	<ul id="footer-places">
		<li id="footer-places-privacy"><a href="../en/ArchWiki:Privacy_policy.html" title="ArchWiki:Privacy policy">Privacy policy</a></li>
		<li id="footer-places-about"><a href="../en/ArchWiki:About.html" title="ArchWiki:About">About ArchWiki</a></li>
		<li id="footer-places-disclaimer"><a href="../en/ArchWiki:General_disclaimer.html" title="ArchWiki:General disclaimer">Disclaimers</a></li>
	</ul>
	<ul id="footer-icons" class="noprint">
		<li id="footer-copyrightico">
	</ul>
	<div style="clear: both;"></div>
</footer>



</body>
</html>
