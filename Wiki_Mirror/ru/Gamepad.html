<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<title>Gamepad (Русский) - ArchWiki</title>
<link rel="stylesheet" href="../ArchWikiOffline.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<meta name="generator" content="MediaWiki 1.35.0">
<meta name="referrer" content="no-referrer-when-downgrade">
<meta name="robots" content="noindex,follow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="/opensearch_desc.php" title="ArchWiki (en)">
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.archlinux.org/api.php?action=rsd">
<link rel="license" href="http://www.gnu.org/copyleft/fdl.html">
<link rel="alternate" type="application/atom+xml" title="ArchWiki Atom feed" href="/index.php?title=Special:RecentChanges&amp;feed=atom">
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Gamepad_Русский rootpage-Gamepad_Русский skin-vector action-view skin-vector-legacy">
<div id="content" class="mw-body" role="main" style="margin: 0">
	<a id="top"></a>
	<div id="siteNotice" class="mw-body-content"></div>
	<div class="mw-indicators mw-body-content">
	</div>
	<h1 id="firstHeading" class="firstHeading" lang="en">Gamepad (Русский)</h1>
	<div id="bodyContent" class="mw-body-content">
		<div id="siteSub" class="noprint">From ArchWiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="#searchInput">Jump to search</a>
		<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<div class="warningbox">The printable version is no longer supported and may have rendering errors. Please update your browser bookmarks and please use the default browser print function instead.</div>
<div class="mw-parser-output">
<p><br>
Работа с джойстиками в Linux подразумевает некоторые сложности. Не потому что они плохо поддерживаются, а потому, что вам нужно определить, какие модули подключить, чтобы ваш геймпад заработал, а это не всегда очевидно.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading">
<input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none"><div class="toctitle" lang="en" dir="ltr">
<h2 id="mw-toc-heading">Contents</h2>
<span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span>
</div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B_%D0%B2%D0%B2%D0%BE%D0%B4%D0%B0_%D0%B4%D0%BB%D1%8F_%D0%B3%D0%B5%D0%B9%D0%BC%D0%BF%D0%B0%D0%B4%D0%BE%D0%B2"><span class="tocnumber">1</span> <span class="toctext">Системы ввода для геймпадов</span></a></li>
<li class="toclevel-1 tocsection-2">
<a href="#%D0%9E%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BD%D1%83%D0%B6%D0%BD%D1%8B%D1%85_%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D0%B5%D0%B9"><span class="tocnumber">2</span> <span class="toctext">Определение нужных модулей</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#%D0%9F%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D0%B5%D0%B9_%D0%B4%D0%BB%D1%8F_%D0%B0%D0%BD%D0%B0%D0%BB%D0%BE%D0%B3%D0%BE%D0%B2%D1%8B%D1%85_%D1%83%D1%81%D1%82%D1%80%D0%BE%D0%B9%D1%81%D1%82%D0%B2"><span class="tocnumber">2.1</span> <span class="toctext">Подключение модулей для аналоговых устройств</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#%D0%94%D0%B6%D0%BE%D0%B9%D1%81%D1%82%D0%B8%D0%BA%D0%B8_USB"><span class="tocnumber">2.2</span> <span class="toctext">Джойстики USB</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-5">
<a href="#%D0%9F%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D0%BA%D0%B0_%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D0%B8"><span class="tocnumber">3</span> <span class="toctext">Проверка конфигурации</span></a>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#Joystick_API"><span class="tocnumber">3.1</span> <span class="toctext">Joystick API</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#evdev_API"><span class="tocnumber">3.2</span> <span class="toctext">evdev API</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-8">
<a href="#%D0%9D%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0_%22%D0%BC%D0%B5%D1%80%D1%82%D0%B2%D1%8B%D1%85_%D0%B7%D0%BE%D0%BD%22_%D0%B8_%D0%BA%D0%B0%D0%BB%D0%B8%D0%B1%D1%80%D0%BE%D0%B2%D0%BA%D0%B0"><span class="tocnumber">4</span> <span class="toctext">Настройка "мертвых зон" и калибровка</span></a>
<ul>
<li class="toclevel-2 tocsection-9"><a href="#%22%D0%9C%D0%B5%D1%80%D1%82%D0%B2%D1%8B%D0%B5_%D0%B7%D0%BE%D0%BD%D1%8B%22_%D0%B2_wine"><span class="tocnumber">4.1</span> <span class="toctext">"Мертвые зоны" в wine</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#%22%D0%9C%D0%B5%D1%80%D1%82%D0%B2%D1%8B%D0%B5_%D0%B7%D0%BE%D0%BD%D1%8B%22_%D0%B2_Xorg"><span class="tocnumber">4.2</span> <span class="toctext">"Мертвые зоны" в Xorg</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#%22%D0%9C%D0%B5%D1%80%D1%82%D0%B2%D1%8B%D0%B5_%D0%B7%D0%BE%D0%BD%D1%8B%22_Joystick_API"><span class="tocnumber">4.3</span> <span class="toctext">"Мертвые зоны" Joystick API</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#%22%D0%9C%D0%B5%D1%80%D1%82%D0%B2%D1%8B%D0%B5_%D0%B7%D0%BE%D0%BD%D1%8B%22_evdev_API"><span class="tocnumber">4.4</span> <span class="toctext">"Мертвые зоны" evdev API</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#%D0%9D%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0_%D0%BA%D1%80%D0%B8%D0%B2%D1%8B%D1%85"><span class="tocnumber">4.5</span> <span class="toctext">Настройка кривых</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-14"><a href="#%D0%9E%D1%82%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F_%D0%BC%D1%8B%D1%88%D1%8C%D1%8E_%D0%BF%D1%80%D0%B8_%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D0%B8_%D0%B4%D0%B6%D0%BE%D0%B9%D1%81%D1%82%D0%B8%D0%BA%D0%B0"><span class="tocnumber">5</span> <span class="toctext">Отключение управления мышью при помощи джойстика</span></a></li>
<li class="toclevel-1 tocsection-15">
<a href="#%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%B4%D0%B6%D0%BE%D0%B9%D1%81%D1%82%D0%B8%D0%BA%D0%B0_%D0%B4%D0%BB%D1%8F_%D0%BE%D1%82%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B8_%D0%BD%D0%B0%D0%B6%D0%B0%D1%82%D0%B8%D1%8F_%D0%BA%D0%BB%D0%B0%D0%B2%D0%B8%D1%88"><span class="tocnumber">6</span> <span class="toctext">Использование джойстика для отправки нажатия клавиш</span></a>
<ul>
<li class="toclevel-2 tocsection-16"><a href="#%D0%BF%D1%80%D0%B8_%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D0%B8_X.org"><span class="tocnumber">6.1</span> <span class="toctext">при помощи X.org</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-17">
<a href="#%D0%A1%D0%BF%D0%B5%D1%86%D0%B8%D1%84%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D1%83%D1%81%D1%82%D1%80%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0"><span class="tocnumber">7</span> <span class="toctext">Специфические устройства</span></a>
<ul>
<li class="toclevel-2 tocsection-18"><a href="#%D0%A2%D0%B0%D0%BD%D1%86%D0%B5%D0%B2%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5_%D0%BF%D0%BB%D0%B0%D1%82%D1%84%D0%BE%D1%80%D0%BC%D1%8B"><span class="tocnumber">7.1</span> <span class="toctext">Танцевальные платформы</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="#Logitech_Thunderpad_Digital"><span class="tocnumber">7.2</span> <span class="toctext">Logitech Thunderpad Digital</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="#%D0%9A%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D0%BB%D0%B5%D1%80_Nintendo_Gamecube"><span class="tocnumber">7.3</span> <span class="toctext">Контроллер Nintendo Gamecube</span></a></li>
<li class="toclevel-2 tocsection-21">
<a href="#%D0%9A%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D0%BB%D0%B5%D1%80_PlayStation_3/4"><span class="tocnumber">7.4</span> <span class="toctext">Контроллер PlayStation 3/4</span></a>
<ul>
<li class="toclevel-3 tocsection-22"><a href="#%D0%9F%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5_%D1%87%D0%B5%D1%80%D0%B5%D0%B7_Bluetooth"><span class="tocnumber">7.4.1</span> <span class="toctext">Подключение через Bluetooth</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-23">
<a href="#Steam_Controller"><span class="tocnumber">7.5</span> <span class="toctext">Steam Controller</span></a>
<ul>
<li class="toclevel-3 tocsection-24"><a href="#Wine"><span class="tocnumber">7.5.1</span> <span class="toctext">Wine</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-25">
<a href="#%D0%9A%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D0%BB%D0%B5%D1%80_Xbox_360"><span class="tocnumber">7.6</span> <span class="toctext">Контроллер Xbox 360</span></a>
<ul>
<li class="toclevel-3 tocsection-26"><a href="#SteamOS_xpad"><span class="tocnumber">7.6.1</span> <span class="toctext">SteamOS xpad</span></a></li>
<li class="toclevel-3 tocsection-27">
<a href="#xboxdrv"><span class="tocnumber">7.6.2</span> <span class="toctext">xboxdrv</span></a>
<ul>
<li class="toclevel-4 tocsection-28"><a href="#%D0%9D%D0%B5%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE_%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D0%BB%D0%B5%D1%80%D0%BE%D0%B2"><span class="tocnumber">7.6.2.1</span> <span class="toctext">Несколько контроллеров</span></a></li>
<li class="toclevel-4 tocsection-29">
<a href="#%D0%98%D0%BC%D0%B8%D1%82%D0%B0%D1%86%D0%B8%D1%8F_%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D0%BB%D0%B5%D1%80%D0%B0_XBox360_%D0%B4%D1%80%D1%83%D0%B3%D0%B8%D0%BC%D0%B8_%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D0%BB%D0%B5%D1%80%D0%B0%D0%BC%D0%B8"><span class="tocnumber">7.6.2.2</span> <span class="toctext">Имитация контроллера XBox360 другими контроллерами</span></a>
<ul>
<li class="toclevel-5 tocsection-30"><a href="#Logitech_Dual_Action"><span class="tocnumber">7.6.2.2.1</span> <span class="toctext">Logitech Dual Action</span></a></li>
<li class="toclevel-5 tocsection-31"><a href="#%D0%9A%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D0%BB%D0%B5%D1%80_PlayStation_2_%D1%87%D0%B5%D1%80%D0%B5%D0%B7_%D0%B0%D0%B4%D0%B0%D0%BF%D1%82%D0%B5%D1%80_USB"><span class="tocnumber">7.6.2.2.2</span> <span class="toctext">Контроллер PlayStation 2 через адаптер USB</span></a></li>
<li class="toclevel-5 tocsection-32"><a href="#%D0%9A%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D0%BB%D0%B5%D1%80_PlayStation_2_%D1%87%D0%B5%D1%80%D0%B5%D0%B7_USB"><span class="tocnumber">7.6.2.2.3</span> <span class="toctext">Контроллер PlayStation 2 через USB</span></a></li>
<li class="toclevel-5 tocsection-33"><a href="#%D0%9A%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D0%BB%D0%B5%D1%80_PlayStation_2_%D1%87%D0%B5%D1%80%D0%B5%D0%B7_Bluetooth"><span class="tocnumber">7.6.2.2.4</span> <span class="toctext">Контроллер PlayStation 2 через Bluetooth</span></a></li>
<li class="toclevel-5 tocsection-34"><a href="#%D0%9A%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D0%BB%D0%B5%D1%80_PlayStation_4"><span class="tocnumber">7.6.2.2.5</span> <span class="toctext">Контроллер PlayStation 4</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-35">
<a href="#%D0%A0%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC"><span class="tocnumber">8</span> <span class="toctext">Решение проблем</span></a>
<ul>
<li class="toclevel-2 tocsection-36"><a href="#%D0%9F%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D1%89%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BA%D1%83%D1%80%D1%81%D0%BE%D1%80%D0%B0_%D0%BC%D1%8B%D1%88%D0%B8_%D0%B4%D0%B6%D0%BE%D0%B9%D1%81%D1%82%D0%B8%D0%BA%D0%BE%D0%BC"><span class="tocnumber">8.1</span> <span class="toctext">Перемещение курсора мыши джойстиком</span></a></li>
<li class="toclevel-2 tocsection-37"><a href="#%D0%94%D0%B6%D0%BE%D0%B9%D1%81%D1%82%D0%B8%D0%BA_%D0%BD%D0%B5_%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82_%D0%B2_%D0%B8%D0%B3%D1%80%D0%B0%D1%85_%D0%BD%D0%B0_FNA/SDL"><span class="tocnumber">8.2</span> <span class="toctext">Джойстик не работает в играх на FNA/SDL</span></a></li>
<li class="toclevel-2 tocsection-38"><a href="#%D0%93%D0%B5%D0%B9%D0%BC%D0%BF%D0%B0%D0%B4_%D0%BD%D0%B5_%D1%80%D0%B0%D1%81%D0%BF%D0%BE%D0%B7%D0%BD%D0%B0%D0%B5%D1%82%D1%81%D1%8F_%D0%BD%D0%B8%D0%BA%D0%B0%D0%BA%D0%B8%D0%BC%D0%B8_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0%D0%BC%D0%B8"><span class="tocnumber">8.3</span> <span class="toctext">Геймпад не распознается никакими программами</span></a></li>
<li class="toclevel-2 tocsection-39"><a href="#%D0%9D%D0%B5_%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82_Steam_Controller"><span class="tocnumber">8.4</span> <span class="toctext">Не работает Steam Controller</span></a></li>
</ul>
</li>
</ul>
</div>

<h2>
<span id=".D0.A1.D0.B8.D1.81.D1.82.D0.B5.D0.BC.D1.8B_.D0.B2.D0.B2.D0.BE.D0.B4.D0.B0_.D0.B4.D0.BB.D1.8F_.D0.B3.D0.B5.D0.B9.D0.BC.D0.BF.D0.B0.D0.B4.D0.BE.D0.B2"></span><span class="mw-headline" id="Системы_ввода_для_геймпадов">Системы ввода для геймпадов</span>
</h2>
<p>Вообще, в Linux имеется две различных системы ввода для джойстиков. Оригинальный интерфейс 'Joystick' и более новый, основанный на 'evdev'.
</p>
<p><code>/dev/input/jsX</code> указывают на интерфейс API 'Joystick', а <code>/dev/input/event*</code>  - на варианты с 'evdev'(то же относится и к другим устройствам, таким, как мыши и клавиатуры). Символические ссылки на эти устройства также находятся тут: <code>/dev/input/by-id/</code> и тут: <code>/dev/input/by-path/</code>,  где традиционные названия, использующие API 'Joystick' заканчиваются на <code>-joystick</code>, в то время, как использующие'evdev' - на <code>-event-joystick</code>.
</p>
<p>Большинство новых игр используют по умолчанию интерфейс 'evdev', так как он поддерживает более детализированную информацию о доступных кнопках и аналоговых стиках, а также поддерживает функцию обратной связи.
</p>
<p>Хотя SDL1.x по умолчанию использует интерфейс 'evdev', вы можете принудительно заставить ее использовать старый API 'Joystick', установив переменную окружения <code>SDL_JOYSTICK_DEVICE=/dev/input/js0</code>. Это может помочь во многих играх, таких, как X3. SDL2.x поддерживает только новый интерфейс 'evdev'.
</p>
<p>Также стоит упомянуть, что существует еще драйвер xorg <code>xf86-input-joystick</code>. Он лишь позволяет вам контролировать клавиатуру и мышь при помощи джойстика в xorg, что не актуально для большинства пользователей. Отключение этой функции описано ниже в <a href="#Disable_Joystick_From_Controlling_Mouse">Disable Joystick From Controlling Mouse</a><sup>[<a href="/title/Help:Procedures#Fix_broken_section_links" title="Help:Procedures">ссылка недействительна</a>: раздел не найден]</sup>, но в большинстве случаев вам нужно просто-напросто удалить этот пакет.
</p>
<h2>
<span id=".D0.9E.D0.BF.D1.80.D0.B5.D0.B4.D0.B5.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BD.D1.83.D0.B6.D0.BD.D1.8B.D1.85_.D0.BC.D0.BE.D0.B4.D1.83.D0.BB.D0.B5.D0.B9"></span><span class="mw-headline" id="Определение_нужных_модулей">Определение нужных модулей</span>
</h2>
<p>Если вы не используете совсем старый джойстик, который использует гейм-порт или собственный USB-протокол, вам понадобятся только стандартные USB HID модули.
</p>
<p>Для подробного изучения модулей, связанных с джойстиками в Linux, вам нужно получить доступ к исходным кодам ядра Linux - в особенности к секции Documentation. К сожалению, пакеты ядра pacman не содержат необходимой информации. Если у вас есть скачанные исходные коды ядра, посмотрите в <code>Documentation/input/joystick.txt</code>. Вы также можете просматривать дерево ядра на сайте <a rel="nofollow" class="external text" href="https://kernel.org/">kernel.org</a>, нажав  ссылку "browse" для ядра, которые вы используете, а затем нажав на ссылку "tree" вверху. Вот ссылка на документацию по <a rel="nofollow" class="external text" href="https://git.kernel.org/cgit/linux/kernel/git/stable/linux-stable.git/tree/Documentation/input/joystick.txt">последней версии ядра</a><sup>[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">устаревшая ссылка</a> 2020-08-02]</sup>.
</p>
<p>Некоторые геймпады требуют специфических модулей. Например, такие, как контроллер Microsoft Sidewinder (<code>sidewinder</code>) или цифровые контроллеры Logitech (<code>adi</code>). Множество старых моделей джойстиков будут работать с простым модулем <code>analog</code>. Если ваш джойстик подключается к гейм-порту звуковой карты, вам понадобятся драйверы для вашей звуковой карты, однако, для некоторых из них, например для SoundBlaster Live, имеется специальный драйвер гейм-порта (<code>emu10k1-gp</code>). Старинные карты с интерфейсом ISA могут потребовать модуль <code>ns558</code>, который является стандартным модулем для гейм-порта.
</p>
<p>Как видите, существует большое количество различных модуей, которые могут понадобиться, чтобы ваш джойстик заработал в Linux, так что в рамках этой статьи невозможно рассмотреть все варианты. Пожалуйста, изучите документацию, упомянутую выше, для более подробной информации.
</p>
<h3>
<span id=".D0.9F.D0.BE.D0.B4.D0.BA.D0.BB.D1.8E.D1.87.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BC.D0.BE.D0.B4.D1.83.D0.BB.D0.B5.D0.B9_.D0.B4.D0.BB.D1.8F_.D0.B0.D0.BD.D0.B0.D0.BB.D0.BE.D0.B3.D0.BE.D0.B2.D1.8B.D1.85_.D1.83.D1.81.D1.82.D1.80.D0.BE.D0.B9.D1.81.D1.82.D0.B2"></span><span class="mw-headline" id="Подключение_модулей_для_аналоговых_устройств">Подключение модулей для аналоговых устройств</span>
</h3>
<p>Вам нужно подключить модуль для вашего гейм-порта (<code>ns558</code>, <code>emu10k1-gp</code>, <code>cs461x</code>, и т.д. ...), модуль джойстика (<code>analog</code>, <code>sidewinder</code>, <code>adi</code>, и т.д...) и в конце концов - драйвер джойстика для ядра (<code>joydev</code>). Создайте новый файл с названиями этих модулей в <code>/etc/modules-load.d/</code>, либо просто используйте modprobe. Модуль <code>gameport</code> должен подключиться автоматически, т.к. является зависимым от других.
</p>
<p><br>
</p>
<h3>
<span id=".D0.94.D0.B6.D0.BE.D0.B9.D1.81.D1.82.D0.B8.D0.BA.D0.B8_USB"></span><span class="mw-headline" id="Джойстики_USB">Джойстики USB</span>
</h3>
<p>Просто используйте modprobe для драйвера джойстика (<code>usbhid</code> и <code>joydev</code>). Если у вас мышь и клавиатура USB, модуль <code>usbhid</code> уже подключен, и вам остается только подключить модуль <code>joydev</code>.
</p>
<h2>
<span id=".D0.9F.D1.80.D0.BE.D0.B2.D0.B5.D1.80.D0.BA.D0.B0_.D0.BA.D0.BE.D0.BD.D1.84.D0.B8.D0.B3.D1.83.D1.80.D0.B0.D1.86.D0.B8.D0.B8"></span><span class="mw-headline" id="Проверка_конфигурации">Проверка конфигурации</span>
</h2>
<p>Когда все модули подключены, вы должны увидеть новое устройство <code>/dev/input/js0</code> и файл, заканчивающийся на <code>-event-joystick</code> в папке <code>/dev/input/by-id</code>. Просто используйте <code>cat</code> на этих файлах устройств, чтобы понять, что джойстик работает - покрутите стики, понажимайте кнопки, вы увидите кракозябры, выводимые на экран при взаимодействии с джойстиком.
</p>
<p>Оба интерфейса также поддерживаются wine и определяются как отдельные устройства. Это можно проверить при помощи <code>wine control joy.cpl</code>.
</p>
<p><br>
</p>
<h3><span class="mw-headline" id="Joystick_API">Joystick API</span></h3>
<p>Существует много приложений, которые позволяют проверить работу джойстика с использованием этого старого API, наиболее простое - <code>jstest</code> из пакета <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=joyutils">joyutils</a></span>. Если вывод программы сложно прочитать из-за того, что строка слишком длинная, вы можете воспользоваться графическими средствами. В KDE4 есть встроенная утилита в панели Input Devices системных настроек. Также можно воспользоваться пакетом <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/jstest-gtk-git/">jstest-gtk-git</a></span><sup><small>AUR</small></sup>.
</p>
<p>Пользоваться <code>jstest</code> очень просто - просто запустите <code>jstest /dev/input/js0</code>, и программа начнет выводить строку с состоянием всех осей стиков (нормализованных к {-32767,32767}) и кнопок.
</p>
<p>При запуске <code>jstest-gtk</code>, программа покажет список всех доступных геймпадов, и вам нужно будет только выбрать один из них и нажать кнопку "Properties"
</p>
<p><br>
</p>
<h3><span class="mw-headline" id="evdev_API">evdev API</span></h3>
<p>Новый API 'evdev' может быть проверен с использованием программы проверки геймпада SDL2, либо при помощи программы <code>evtest</code> из репозитория community. Установите <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/sdl2-jstest-git/">sdl2-jstest-git</a></span><sup><small>AUR</small></sup>, а затем запустите <code>sdl2-jstest --test 0</code>. Если у вас подключено несколько контроллеров, используйте <code>sdl2-jstest --list</code>, чтобы вывести список их ID.
</p>
<p>Для проверки обратной связи геймпада, используйте <code>fftest</code> из пакета <code>linuxconsole</code>:
</p>
<pre>$ fftest /dev/input/by-id/usb-*event-joystick
</pre>
<h2>
<span id=".D0.9D.D0.B0.D1.81.D1.82.D1.80.D0.BE.D0.B9.D0.BA.D0.B0_.22.D0.BC.D0.B5.D1.80.D1.82.D0.B2.D1.8B.D1.85_.D0.B7.D0.BE.D0.BD.22_.D0.B8_.D0.BA.D0.B0.D0.BB.D0.B8.D0.B1.D1.80.D0.BE.D0.B2.D0.BA.D0.B0"></span><span class="mw-headline" id='Настройка_"мертвых_зон"_и_калибровка'>Настройка "мертвых зон" и калибровка</span>
</h2>
<p>Если вы хотите настроить "мертвые зоны" (или вовсе убрать их) для ваших аналоговых устройств ввода, вы должны сделать это отдельно для xorg (для эмуляции клавиатуры и мыши), Joystick API и evdev API.
</p>
<p><br>
</p>
<h3>
<span id=".22.D0.9C.D0.B5.D1.80.D1.82.D0.B2.D1.8B.D0.B5_.D0.B7.D0.BE.D0.BD.D1.8B.22_.D0.B2_wine"></span><span class="mw-headline" id='"Мертвые_зоны"_в_wine'>"Мертвые зоны" в wine</span>
</h3>
<p>Добавьте следующую запись в реестр и пропишите ей строковое значение от 0 до 10000 (затрагивает все оси стиков)
</p>
<pre>HKEY_CURRENT_USER\Software\Wine\DirectInput\DefaultDeadZone
</pre>
<p>Источник: <a rel="nofollow" class="external text" href="https://wiki.winehq.org/UsefulRegistryKeys">UsefulRegistryKeys</a>
</p>
<h3>
<span id=".22.D0.9C.D0.B5.D1.80.D1.82.D0.B2.D1.8B.D0.B5_.D0.B7.D0.BE.D0.BD.D1.8B.22_.D0.B2_Xorg"></span><span class="mw-headline" id='"Мертвые_зоны"_в_Xorg'>"Мертвые зоны" в Xorg</span>
</h3>
<p>Добавьте примерно такую строку в <code>/etc/X11/xorg.conf.d/50-joystick.conf</code> перед <code>EndSection</code>:
</p>
<pre>Option "MapAxis1" "deadzone=1000"
</pre>
<p>1000 - это значение по умолчанию, но вы можете сделать его любым между 0 и 30 000. Чтобы узнать номер оси, смотрите раздел "Проверка конфигурации" этой статьи.
Если вы знаете номер конкретной оси, просто допишите <code>deadzone=value</code> после пробела в конце параметра.
</p>
<h3>
<span id=".22.D0.9C.D0.B5.D1.80.D1.82.D0.B2.D1.8B.D0.B5_.D0.B7.D0.BE.D0.BD.D1.8B.22_Joystick_API"></span><span class="mw-headline" id='"Мертвые_зоны"_Joystick_API'>"Мертвые зоны" Joystick API</span>
</h3>
<p>Самый простой способ - использовать <code>jstest-gtk</code> из пакета <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/jstest-gtk-git/">jstest-gtk-git</a></span><sup><small>AUR</small></sup>. Выберите контроллер, который вы хотите отредактировать, нажмите кнопку "Calibration" внизу диалогового окна (<b>не нажимайте</b> "Start Calibration" в этом окне!). Теперь вы можете установить значения параметров CenterMin и CenterMax (которые отвечают за центральную "мертвую зону"), RangeMin и RangeMax, которые отвечают за крайние точки "мертвых зон". Учтите, что настройки калибровки применяются, когда приложение подключается к геймпаду, так что вам придется перезапустить игру или приложение, чтобы увидеть изменения в калибровке. 
</p>
<p>После настройки "мертвых зон", используйте <code>jscal</code>, чтобы создать новый шелл-скрипт с нужными значениями.
</p>
<pre>$ jscal -p /dev/input/jsX &gt; jscal.sh # replace X with your joystick's number 
$ chmod +x jscal.sh
</pre>
<p>Теперь вам нужно создать правило для <a href="/title/Udev" title="Udev">udev</a>, например <code>/etc/udev/rules.d и назвать его 85-jscal.rules</code>, чтобы скрипт автоматически выполнялся, когда вы подключаете контроллер:
</p>
<pre>SUBSYSTEM=="input", ATTRS{idVendor}=="054c", ATTRS{idProduct}=="c268", ACTION=="add", RUN+="/usr/bin/jscal.sh"
</pre>
<p>Для получения idVendor и idProduct, используйте <code>udevadm info --attribute-walk --name /dev/input/jsX</code>.
Если у вас несколько джойстиков, используйте названия `/dev/input/by-id/*-joystick`.
</p>
<h3>
<span id=".22.D0.9C.D0.B5.D1.80.D1.82.D0.B2.D1.8B.D0.B5_.D0.B7.D0.BE.D0.BD.D1.8B.22_evdev_API"></span><span class="mw-headline" id='"Мертвые_зоны"_evdev_API'>"Мертвые зоны" evdev API</span>
</h3>
<p>В данный момент не существует отдельного приложения, позволяющего откалибровать джойстик для <code>evdev</code> API, но есть <code>G25manage</code>, распространяемое вместе с игрой VDrift, которое позволяет настраивать центральные "мертвые зоны".
</p>
<p>Самый простой способ получить VDrift - скачать его (<a rel="nofollow" class="external text" href="https://github.com/VDrift/vdrift/tree/master/tools/G25manage">github</a>) и скомпилировать при помощи <code>make</code>.  
</p>
<p>После этого вы сможете изменить конфигурацию при помощи:
</p>
<pre>$ ./G25manage --showcalibration /dev/input/by-id/usb-*-event-joystick
</pre>
<p>Для изменения "мертвых зон" любых осей, используйте следующую команду:
</p>
<pre>$ ./G25manage --evdev /dev/input/by-id/usb-*-event-joystick --axis 0 --deadzone 0
</pre>
<p>Используйтесь файлом правил udev для установки новых значений автоматически при подключении джойстика.
</p>
<p>Учтите, что внутри ядра этот параметр называется <code>flatness</code> и устанавливается при помощи <code>EVIOCSABS</code> <code>ioctl</code>.
</p>
<p>Конфигурация по умолчанию будет выглядеть примерно так:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$ ./G25manage --showcalibration /dev/input/by-id/usb-Madcatz_Saitek_Pro_Flight_X-55_Rhino_Stick_G0000090-event-joystick</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Supported Absolute axes:
   Absolute axis 0x00 (0) (X Axis) (min: 0, max: 65535, flatness: 4095 (=6.25%), fuzz: 255)
   Absolute axis 0x01 (1) (Y Axis) (min: 0, max: 65535, flatness: 4095 (=6.25%), fuzz: 255)
   Absolute axis 0x05 (5) (Z Rate Axis) (min: 0, max: 4095, flatness: 255 (=6.23%), fuzz: 15)
   Absolute axis 0x10 (16) (Hat zero, x axis) (min: -1, max: 1, flatness: 0 (=0.00%), fuzz: 0)
   Absolute axis 0x11 (17) (Hat zero, y axis) (min: -1, max: 1, flatness: 0 (=0.00%), fuzz: 0)</pre>
<p>В то время, как более удачная настройка может быть достигнута примерно так (повторить для каждой оси):
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$ ./G25manage --evdev /dev/input/by-id/usb-Madcatz_Saitek_Pro_Flight_X-55_Rhino_Stick_G0000090-event-joystick --axis 0 --deadzone 512</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Event device file: /dev/input/by-id/usb-Madcatz_Saitek_Pro_Flight_X-55_Rhino_Stick_G0000090-event-joystick
 Axis index to deal with: 0
 New dead zone value: 512
 Trying to set axis 0 deadzone to: 512
   Absolute axis 0x00 (0) (X Axis) Setting deadzone value to : 512
 (min: 0, max: 65535, flatness: 512 (=0.78%), fuzz: 255)</pre>
<h3>
<span id=".D0.9D.D0.B0.D1.81.D1.82.D1.80.D0.BE.D0.B9.D0.BA.D0.B0_.D0.BA.D1.80.D0.B8.D0.B2.D1.8B.D1.85"></span><span class="mw-headline" id="Настройка_кривых">Настройка кривых</span>
</h3>
<p>Если ваша игра использует ограниченное количество кнопок или поддерживает несколько контроллеров, можно достичь хороших результатов используя <code>xboxdrv</code> для изменения кривых джойстика.
</p>
<p>Ниже приведены настройки, которые я использовал для Saitek X-55 HOTAS:
</p>
<pre>$ xboxdrv --evdev /dev/input/by-id/usb-Madcatz_Saitek_Pro_Flight_X-55_Rhino_Throttle_G0000021-event-joystick \
  --evdev-no-grab --evdev-absmap 'ABS_#40=x1,ABS_#41=y1,ABS_X=x2,ABS_Y=y2' --device-name 'Hat and throttle' \
  --ui-axismap 'x2^cal:-32000:0:32000=,y2^cal:-32000:0:32000=' --silent
</pre>
<p>Это привязывает событие EV_ABS с id 40 и 41 (используйте xboxdrv с параметром --evdev-debug для просмотра списка зарегистрированных событий), которое является обычно недоступным "курсором мыши" на гашетке, на первый геймпад и гашетку второго геймпада, а также закрепляет верхние и нижние границы, потому что они не всегда полностью обрабатываются.
</p>
<p>Немного интереснее настройка для стика:
</p>
<pre>$ xboxdrv --evdev /dev/input/by-id/usb-Madcatz_Saitek_Pro_Flight_X-55_Rhino_Stick_G0000090-event-joystick \
  --evdev-no-grab --evdev-absmap 'ABS_X=x1' --evdev-absmap 'ABS_Y=y1' --device-name 'Joystick' \
  --ui-axismap 'x1^cal:-32537:-455:32561=,x1^dead:-900:700:1=,x1^resp:-32768:-21845:-2000:0:2000:21485:32767=' \
  --ui-axismap 'y1^cal:-32539:-177:32532=,y1^dead:-700:2500:1=,y1^resp:-32768:-21845:-2000:0:2000:21485:32767=' \
  --evdev-absmap 'ABS_RZ=x2' --ui-axismap 'x2^cal:-32000:-100:32000,x2^dead:-1500:1000:1=,x2^resp:-32768:-21845:-2000:0:2000:21485:32767=' \
  --silent
</pre>
<p>Здесь осуществляется привязка трех осей джойстика к осям геймпада и меняется их калибровка (минимальное значение, среднее значение, максимальное значение), "мертвые зоны" (отрицательная сторона, положительная сторона, флаг для включения сглаживания) и, наконец, смена кривой джойстика на более плоскую в середине.
</p>
<p>Вы также можете изменить отзывчивость, установив значение 'sen' (sensitivity). Установка этого значения в 0 даст вам линейную чувствительность, значение -1 - очень неотзывчивую ось, а значение 1 - очень отзывчивую. Можно использовать средние значения, чтобы сделать ее более или менее отзывчивой. Xboxdrv использует квадратичную формулу для подсчета финального значение, так что установка значения этого параметра даст более "гладкий" эффект, чем установка значения 'rest', приведенная выше.
</p>
<p>Еще одна полезная функция xboxdrv - программа может работать как со старым Joystick API, так и с новым evded, так что она должна быть совместима практически с каждым приложением.
</p>
<h2>
<span id=".D0.9E.D1.82.D0.BA.D0.BB.D1.8E.D1.87.D0.B5.D0.BD.D0.B8.D0.B5_.D1.83.D0.BF.D1.80.D0.B0.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D1.8F_.D0.BC.D1.8B.D1.88.D1.8C.D1.8E_.D0.BF.D1.80.D0.B8_.D0.BF.D0.BE.D0.BC.D0.BE.D1.89.D0.B8_.D0.B4.D0.B6.D0.BE.D0.B9.D1.81.D1.82.D0.B8.D0.BA.D0.B0"></span><span class="mw-headline" id="Отключение_управления_мышью_при_помощи_джойстика">Отключение управления мышью при помощи джойстика</span>
</h2>
<p>Если вы хотите играть в игры при помощи контроллера, вы, возможно, захотите отключить управление курсором мыши при помощью джойстика. Чтобы сделать это, отредактируйте файл /etc/X11/xorg.conf.d/50-joystick.conf примерно так:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/X11/xorg.conf.d/50-joystick.conf </pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Section "InputClass"
        Identifier "joystick catchall"
        MatchIsJoystick "on"
        MatchDevicePath "/dev/input/event*"
        Driver "joystick"
        Option "StartKeysEnabled" "False"       #Отключение поддержки
        Option "StartMouseEnabled" "False"      #мыши
EndSection</pre>
<h2>
<span id=".D0.98.D1.81.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D0.B4.D0.B6.D0.BE.D0.B9.D1.81.D1.82.D0.B8.D0.BA.D0.B0_.D0.B4.D0.BB.D1.8F_.D0.BE.D1.82.D0.BF.D1.80.D0.B0.D0.B2.D0.BA.D0.B8_.D0.BD.D0.B0.D0.B6.D0.B0.D1.82.D0.B8.D1.8F_.D0.BA.D0.BB.D0.B0.D0.B2.D0.B8.D1.88"></span><span class="mw-headline" id="Использование_джойстика_для_отправки_нажатия_клавиш">Использование джойстика для отправки нажатия клавиш</span>
</h2>
<p>Существует несколько программ, позволяющих отправлять нажатия клавиш при помощи джойстика, таких, как, например, <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/qjoypad/">qjoypad</a></span><sup><small>AUR</small></sup> или <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/antimicrox-git/">antimicrox-git</a></span><sup><small>AUR</small></sup>. Все они не требуют дополнительной настройки X.org.
</p>
<h3>
<span id=".D0.BF.D1.80.D0.B8_.D0.BF.D0.BE.D0.BC.D0.BE.D1.89.D0.B8_X.org"></span><span class="mw-headline" id="при_помощи_X.org">при помощи X.org</span>
</h3>
<p>Это хорошее решение для систем, где перезагрузка Xorg случается очень редко, потому что это статическая конфигурация, загружаемая только при запуске X. Я использую его на моем медиа-сервере под управлением XBMC с Logitech Cordless RublePad 2. Из-за проблемы с тем, что "крестовина" распознается как еще одна ось, мне приходилось запускать <a href="/title/Joy2key" class="mw-redirect" title="Joy2key">Joy2key</a> в качестве обходного пути. Когда я обновился до XBMC 11.0 с joy2key 1.6.3-1, эта настройка перестала работать. Так что в конце-концов я решил заставить Xorg обрабатывать события джойстика.
</p>
<p>Для начала, убедитесь, что у вас установлен <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/xf86-input-joystick/">xf86-input-joystick</a></span><sup><small>AUR</small></sup>. Затем создайте файл <code>/etc/X11/xorg.conf.d/51-joystick.conf</code> примерно такого вида:
</p>
<pre> Section "InputClass"
  Identifier "Joystick hat mapping"
  Option "StartKeysEnabled" "True"
  #MatchIsJoystick "on"
  Option "MapAxis5" "keylow=113 keyhigh=114"
  Option "MapAxis6" "keylow=111 keyhigh=116"
 EndSection
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> Строка <i>MatchIsJoystick "on"</i> вроде как не нужна для этого файла, но вы, возможно, захотите раскомментировать ее</div>
<p>Отключение управления мышью при помощи джойстика
</p>
<h2>
<span id=".D0.A1.D0.BF.D0.B5.D1.86.D0.B8.D1.84.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B8.D0.B5_.D1.83.D1.81.D1.82.D1.80.D0.BE.D0.B9.D1.81.D1.82.D0.B2.D0.B0"></span><span class="mw-headline" id="Специфические_устройства">Специфические устройства</span>
</h2>
<p>В то время, как большинство джойстиков, особенно USB-совместимые, просто должны работать, некоторые могут потребовать альтернативные драйверы (или будут лучше работать при их использовании). Если ничего не заработало с первого раза, не отчаивайтесь и еще раз вдумчиво прочитайте документацию!
</p>
<h3>
<span id=".D0.A2.D0.B0.D0.BD.D1.86.D0.B5.D0.B2.D0.B0.D0.BB.D1.8C.D0.BD.D1.8B.D0.B5_.D0.BF.D0.BB.D0.B0.D1.82.D1.84.D0.BE.D1.80.D0.BC.D1.8B"></span><span class="mw-headline" id="Танцевальные_платформы">Танцевальные платформы</span>
</h3>
<p>Большинство танцевальных платформ просто работают. Однако, некоторые платформы, особенно от игровых консолей, которые подключаются через адаптер, частенько грешат тем, что привязывают кнопки направлений к осям. Это приводит к тому, что "влево-вправо" или "вверх-вниз" нажимаются одновременно. Для устройств, распознанных xpad, это можно поправить при помощи модулей: 
</p>
<pre> # modprobe -r xpad
 # modprobe xpad dpad_to_buttons=1
</pre>
<h3><span class="mw-headline" id="Logitech_Thunderpad_Digital">Logitech Thunderpad Digital</span></h3>
<p>В Logitech Thunderpad Digital не будут отображаться все кнопки, если вы используете модуль <code>analog</code>. Воспользуйтесь специальным модулем <code>adi</code> для этого контроллера.
</p>
<h3>
<span id=".D0.9A.D0.BE.D0.BD.D1.82.D1.80.D0.BE.D0.BB.D0.BB.D0.B5.D1.80_Nintendo_Gamecube"></span><span class="mw-headline" id="Контроллер_Nintendo_Gamecube">Контроллер Nintendo Gamecube</span>
</h3>
<p>Отключение управления мышью при помощи джойстика
У Dolphin Emulator есть <a rel="nofollow" class="external text" href="https://wiki.dolphin-emu.org/index.php?title=How_to_use_the_Official_GameCube_Controller_Adapter_for_Wii_U_in_Dolphin">вики-страница</a>, на которой объясняется, как пользоваться официальным USB-адаптером Nintendo с контроллером от Gamecube. Эта конфигурация также работает с адаптером контроллера Mayflash, если установить переключатель в положение "Wii U".
</p>
<p>По умолчанию контроллер будет зарегистрирован <a href="/title/Udev" title="Udev">udev</a>, но будет доступен только для пользователя root. Вы можете исправить это, добавив правило для udev:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/udev/rules.d/51-gcadapter.rules</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">SUBSYSTEM=="usb", ENV{DEVTYPE}=="usb_device", ATTRS{idVendor}=="057e", ATTRS{idProduct}=="0337", MODE="0666"</pre>
<p>Это свяжет устройство USB с определенными ID изготовителя и продукта, а также установит разрешения для файла устройства в 0666, чтобы программы, запущенные не из-под root, могли получить доступ к контроллеру.
</p>
<p>Перезагрузить udev и применить новую конфигурацию можно при помощи
</p>
<pre> # udevadm control --reload-rules
</pre>
<h3>
<span id=".D0.9A.D0.BE.D0.BD.D1.82.D1.80.D0.BE.D0.BB.D0.BB.D0.B5.D1.80_PlayStation_3.2F4"></span><span class="mw-headline" id="Контроллер_PlayStation_3/4">Контроллер PlayStation 3/4</span>
</h3>
<p>Отключение управления мышью при помощи джойстика
Контроллеры Dualshock 3, Dualshock 4 и Sixaxis будут работать прямо "из коробки", будучи подключенными к USB (для начала работы необходимо нажать кнопку PS). Также возможна работа с ними через Bluetooth.
</p>
<p>Steam корректно распознает их как геймпады от PS3, так что можно включить режим Big Picture, нажав кнопку PS. В режиме Big Picture и в некоторых играх, эти геймпады могут вести себя как контроллеры от Xbox 360. Управление курсором мыши при помощи геймпада по умолчанию включено. Если вы хотите выключить его, см. <a href="#%D0%9E%D1%82%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F_%D0%BC%D1%8B%D1%88%D1%8C%D1%8E_%D0%BF%D1%80%D0%B8_%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D0%B8_%D0%B4%D0%B6%D0%BE%D0%B9%D1%81%D1%82%D0%B8%D0%BA%D0%B0">#Отключение управления мышью при помощи джойстика</a>
</p>
<h5>
<span id=".D0.9F.D0.BE.D0.B4.D0.BA.D0.BB.D1.8E.D1.87.D0.B5.D0.BD.D0.B8.D0.B5_.D1.87.D0.B5.D1.80.D0.B5.D0.B7_Bluetooth"></span><span class="mw-headline" id="Подключение_через_Bluetooth">Подключение через Bluetooth</span>
</h5>
<p>Установите пакеты <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=bluez-plugins">bluez-plugins</a></span> и <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=bluez-utils">bluez-utils</a></span>, в состав которого входит плагин <i>sixaxis</i>. Затем <a href="/title/%D0%97%D0%B0%D0%BF%D1%83%D1%81%D1%82%D0%B8%D1%82%D0%B5" class="mw-redirect" title="Запустите">запустите</a> <code>bluetooth.service</code>, подключите контроллер по USB, и плагин автоматически пошлет адрес вашего адаптера bluetooth в контроллер.
</p>
<p>Теперь можно отключить контроллер, в следующий раз, когда вы нажмете кнопку PS, он подключится без дополнительных действий.
Только не забывайте отключать контроллер, когда закончите, иначе, он будет оставаться подключенным, включенным и будет разряжаться батарея.
</p>
<h3><span class="mw-headline" id="Steam_Controller">Steam Controller</span></h3>
<p>Пакет <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=steam">steam</a></span> (начиная с версии 1.0.0.51-1) позволяет распознать контроллер и предоставляет эмуляцию клавиатуры/мыши/геймпада пока запущен Steam. Для работы эмуляции геймпада, нужно включить внутриигровое наложение в Steam. Вам, возможно, понадобится запустить <code>udevadm trigger</code> от root или отключить и вновь подключить донгл, если контроллер не работает сразу же после установки и запуска Steam. Если ничего не помогает, попробуйте перезагрузить компьютер, когда донгл подключен.
</p>
<p>Если вы не можете заставить Steam Controller работать, см. <a href="#Steam_Controller_Not_Pairing">#Steam Controller Not Pairing</a><sup>[<a href="/title/Help:Procedures#Fix_broken_section_links" title="Help:Procedures">ссылка недействительна</a>: раздел не найден]</sup>.
</p>
<p>В качестве альтернативы, можете установить <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/python-steamcontroller-git/">python-steamcontroller-git</a></span><sup><small>AUR</small></sup>, чтобы заработала эмуляция контроллера и мыши без Steam.
</p>
<h4><span class="mw-headline" id="Wine">Wine</span></h4>
<div class="noprint archwiki-template-message">
<p><a href="/title/File:Tango-inaccurate.png" class="image"><img alt="Tango-inaccurate.png" src="../File:Tango-inaccurate.png" decoding="async" width="48" height="48"></a><b>The factual accuracy of this article or section is disputed.</b><a href="/title/File:Tango-inaccurate.png" class="image"><img alt="Tango-inaccurate.png" src="../File:Tango-inaccurate.png" decoding="async" width="48" height="48"></a></p>
<div>
<b>Reason:</b> Binaries from questionable hoster. There is also <a rel="nofollow" class="external text" href="https://github.com/x360ce/x360ce">x360ce</a>, but it is most likely different project. (Discuss in <a rel="nofollow" class="external text" href="https://wiki.archlinux.org/title/Talk:Gamepad_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)">Talk:Gamepad (Русский)#</a>)</div>
</div>
<p>Вы можете также использовать <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/python-steamcontroller-git/">python-steamcontroller-git</a></span><sup><small>AUR</small></sup> для работы со Steam Controller в играх, запущенных из-под Wine. Вам нужно  найти и скачать файл <code>xbox360cemu.v.3.0.rar</code> (например, отсюда: <a rel="nofollow" class="external text" href="https://www.2shared.com/file/wcq8xuPf/xbox360cemuv30.html">ссылка с 2shared</a>). Затем скопируйте файлы <code>dinput8.dll</code>, <code>xbox360cemu.ini</code>, <code>xinput1_3.dll</code> и <code>xinput_9_1_0.dll</code> в папку с файлом запуска игры. Отредактируйте <code>xbox360cemu.ini</code>, изменив только следующие значения в разделе <code>[PAD1]</code>, чтобы корректно переназначить конфигурацию Steam Controller в XBox Controller.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">xbox360cemu.ini</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Right Analog X=4
Right Analog Y=-5
A=1
B=2
X=3
Y=4
Back=7
Start=8
Left Thumb=10
Right Thumb=11
Left Trigger=a3
Right Trigger=a6</pre>
<p>Теперь запустите python-steamcontroller в режиме Xbox360 (<code>sc-xbox.py start</code>). Возможно, вы также захотите скопировать <code>XInputTest.exe</code> из <code>xbox360cemu.v.3.0.rar</code> в ту же папку и запустить этот файл при помощи Wine, чтобы проверить работу геймпада. Однако, эмуляция клавиатуры и мыши при помощи этого метода не работает.
</p>
<p><br>
</p>
<h3>
<span id=".D0.9A.D0.BE.D0.BD.D1.82.D1.80.D0.BE.D0.BB.D0.BB.D0.B5.D1.80_Xbox_360"></span><span class="mw-headline" id="Контроллер_Xbox_360">Контроллер Xbox 360</span>
</h3>
<p>Как проводные, так и беспроводные (с модулем <i>Xbox 360 Wireless Receiver for Windows</i>) модели поддерживаются модулем ядра <code>xpad</code> и должны работать без установки дополнительных пакетов.
</p>
<p>Имеются сообщения о проблемах с некоторыми новыми моделями проводных и беспроводных контроллерах при использовании стандартного драйвера xpad, такие, как:
</p>
<ul>
<li>некорректное назначение кнопок. (<a rel="nofollow" class="external text" href="https://github.com/ValveSoftware/steam-for-linux/issues/95#issuecomment-14009081">обсуждение на баг-трекере Steam</a>)</li>
<li>неработающая синхронизация. Все четыре зеленых индикатора моргают, но контроллер работает. (<a rel="nofollow" class="external text" href="https://bbs.archlinux.org/viewtopic.php?id=156028">обсуждение на форуме Arch Linux</a>)</li>
</ul>
<p>Если вы испытываете подобные проблемы, можете использовать либо <a href="#SteamOS_xpad">#SteamOS xpad</a>, либо <a href="#xboxdrv">#xboxdrv</a> вместо стандартного драйвера <code>xpad</code>.
</p>
<p>Если вы хотите управлять мышью при помощи контроллера, либо назначить кнопки клавишам, используйте пакет <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/xf86-input-joystick/">xf86-input-joystick</a></span><sup><small>AUR</small></sup> (дополнительную информацию о настройке см. <code>man joystick</code>).
Если курсор мыши блокируется в углу экрана, может помочь изменение параметра <code>MatchDevicePath</code> в файле <code>/etc/X11/xorg.conf.d/50-joystick.conf</code> с <code>/dev/input/event*</code> на <code>/dev/input/js*</code>.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Совет:</strong> Если вы пользуетесь программой управления питанием <a href="/title/TLP" title="TLP">TLP</a>, могут возникнуть проблемы с подключением Microsoft Wireless Adapter (например, LED-индикатор может погаснуть через пару секунд после подключения адаптера, и контроллер не подключится). Это происходит из-за функции автоматического "засыпания" USB при использовании TLP, решением является добавление ID Wireless Adapter в черный список этой функции. (USB_BLACKLIST, см <a rel="nofollow" class="external text" href="https://linrunner.de/en/tlp/docs/tlp-configuration.html#usb">настройку TLP</a> для дополнительной информации).</div>
<h4><span class="mw-headline" id="SteamOS_xpad">SteamOS xpad</span></h4>
<p>Если у вас возникли проблемы со стандартным модулем ядра <code>xpad</code>, вы можете установить версию SteamOS. 
Также известно о проблемах совместимости беспроводных геймпадов Xbox360 с играми, созданными при помощи GameMaker Studio. Если вы столкнетесь с такой проблемой, единственный известный выход - использовать xboxdrv. В YoYo Games отказались рассматривать это как баг продукта, поэтому вряд ли, что когда-нибудь проблема будет решена.
</p>
<p>Для начала убедитесь, что у вас в системе установлен и запущен <a href="/title/DKMS" class="mw-redirect" title="DKMS">DKMS</a>, затем установите модифицированный модуль ядра <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/steamos-xpad-dkms/">steamos-xpad-dkms</a></span><sup><small>AUR</small></sup><sup>[<a href="/title/ArchWiki:Requests#Broken_package_links" class="mw-redirect" title="ArchWiki:Requests">ссылка недействительна</a>: package not found]</sup>. В процессе установки вы увидите сообщение о том, что новый модуль ядра xpad подключен к вашему текущему ядру:
</p>
<pre>Creating symlink /var/lib/dkms/steamos-xpad-dkms/0.1/source -&gt;
                 /usr/src/steamos-xpad-dkms-0.1
 
DKMS: add completed.
 
Kernel preparation unnecessary for this kernel.  Skipping...
 
Building module:
cleaning build area....
make KERNELRELEASE=3.12.8-1-ARCH KVERSION=3.12.8-1-ARCH....
cleaning build area....
</pre>
<p>Затем выгрузите старый модуль и подключите новый:
</p>
<pre># rmmod xpad
# modprobe steamos-xpad
</pre>
<p>Или просто перезагрузите компьютер.
</p>
<h4><span class="mw-headline" id="xboxdrv">xboxdrv</span></h4>
<p>xboxdrv - это альтернатива <code>xpad</code>, которая предоставляет бОльший функционал и может лучше работать с некоторыми контроллерами. Xboxdrv работает в пользовательском окружении и может быть запущен как системная служба.
Установите его при помощи пакета <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/xboxdrv/">xboxdrv</a></span><sup><small>AUR</small></sup>. Затем <a href="/title/%D0%97%D0%B0%D0%BF%D1%83%D1%81%D1%82%D0%B8%D1%82%D0%B5/%D0%B2%D0%BA%D0%BB%D1%8E%D1%87%D0%B8%D1%82%D0%B5" class="mw-redirect" title="Запустите/включите">запустите/включите</a> <code>xboxdrv.service</code>.
</p>
<h5>
<span id=".D0.9D.D0.B5.D1.81.D0.BA.D0.BE.D0.BB.D1.8C.D0.BA.D0.BE_.D0.BA.D0.BE.D0.BD.D1.82.D1.80.D0.BE.D0.BB.D0.BB.D0.B5.D1.80.D0.BE.D0.B2"></span><span class="mw-headline" id="Несколько_контроллеров">Несколько контроллеров</span>
</h5>
<p>xboxdrv поддерживает несколько контроллеров, но они должны быть сконфигурированы в <code>/etc/default/xboxdrv</code>. Для каждого дополнительного контроллера добавьте строку <code>next-controller = true</code>. Например, при использовании четырех контроллеров, добавьте ее три раза:
</p>
<pre> [xboxdrv]
 silent = true
 next-controller = true
 next-controller = true
 next-controller = true
 [xboxdrv-daemon]
 dbus = disabled
</pre>
<p>Затем <a href="/title/%D0%9F%D0%B5%D1%80%D0%B5%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D1%82%D0%B8%D1%82%D0%B5" class="mw-redirect" title="Перезапустите">перезапустите</a> <code>xboxdrv.service</code>.
</p>
<h5>
<span id=".D0.98.D0.BC.D0.B8.D1.82.D0.B0.D1.86.D0.B8.D1.8F_.D0.BA.D0.BE.D0.BD.D1.82.D1.80.D0.BE.D0.BB.D0.BB.D0.B5.D1.80.D0.B0_XBox360_.D0.B4.D1.80.D1.83.D0.B3.D0.B8.D0.BC.D0.B8_.D0.BA.D0.BE.D0.BD.D1.82.D1.80.D0.BE.D0.BB.D0.BB.D0.B5.D1.80.D0.B0.D0.BC.D0.B8"></span><span class="mw-headline" id="Имитация_контроллера_XBox360_другими_контроллерами">Имитация контроллера XBox360 другими контроллерами</span>
</h5>
<p>xboxdrv может использоваться для регистрации любого контроллера в качестве контроллера Xbox 360 с помощью <code>--mimic-xpad</code>. Это может помочь в играх, которые поддерживают контроллеры Xbox360, но имеют проблемы с обнаружением или работой с другими геймпадами.
</p>
<p>Для начала вам нужно выяснить, как называется каждая кнопка вашего контроллера. Для этого можно использовать <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=evtest">evtest</a></span>. Выполните <code>evtest</code> и выберите ID события устройства (<code>/dev/input/event*</code>), относящийся к вашему контроллеру. Нажимайте кнопки на контроллере и двигайте стики, чтобы прочитать их названия.
</p>
<p>Пример вывода:
</p>
<pre>

Event: time 1380985017.964843, type 4 (EV_MSC), code 4 (MSC_SCAN), value 90003
Event: time 1380985017.964843, type 1 (EV_KEY), code 290 (BTN_THUMB2), value 1
Event: time 1380985017.964843, -------------- SYN_REPORT ------------
Event: time 1380985018.076843, type 4 (EV_MSC), code 4 (MSC_SCAN), value 90003
Event: time 1380985018.076843, type 1 (EV_KEY), code 290 (BTN_THUMB2), value 0
Event: time 1380985018.076843, -------------- SYN_REPORT ------------
Event: time 1380985018.460841, type 4 (EV_MSC), code 4 (MSC_SCAN), value 90002
Event: time 1380985018.460841, type 1 (EV_KEY), code 289 (BTN_THUMB), value 1
Event: time 1380985018.460841, -------------- SYN_REPORT ------------
Event: time 1380985018.572835, type 4 (EV_MSC), code 4 (MSC_SCAN), value 90002
Event: time 1380985018.572835, type 1 (EV_KEY), code 289 (BTN_THUMB), value 0
Event: time 1380985018.572835, -------------- SYN_REPORT ------------
Event: time 1380985019.980824, type 4 (EV_MSC), code 4 (MSC_SCAN), value 90006
Event: time 1380985019.980824, type 1 (EV_KEY), code 293 (BTN_PINKIE), value 1
Event: time 1380985019.980824, -------------- SYN_REPORT ------------
Event: time 1380985020.092835, type 4 (EV_MSC), code 4 (MSC_SCAN), value 90006
Event: time 1380985020.092835, type 1 (EV_KEY), code 293 (BTN_PINKIE), value 0
Event: time 1380985020.092835, -------------- SYN_REPORT ------------
Event: time 1380985023.596806, type 3 (EV_ABS), code 3 (ABS_RX), value 18
Event: time 1380985023.596806, -------------- SYN_REPORT ------------
Event: time 1380985023.612811, type 3 (EV_ABS), code 3 (ABS_RX), value 0
Event: time 1380985023.612811, -------------- SYN_REPORT ------------
Event: time 1380985023.708768, type 3 (EV_ABS), code 3 (ABS_RX), value 14
Event: time 1380985023.708768, -------------- SYN_REPORT ------------
Event: time 1380985023.724772, type 3 (EV_ABS), code 3 (ABS_RX), value 128
Event: time 1380985023.724772, -------------- SYN_REPORT ------------
</pre>
<p>В данном случае <code>BTN_THUMB</code>, <code>BTN_THUMB2</code> и <code>BTN_PINKIE</code> являются кнопками, а <code>ABS_RX</code> - это ось Х аналогового стика.
Теперь можно имитировать контроллер Xbox360 следующей командой:
</p>
<pre>$ xboxdrv --evdev /dev/input/event* --evdev-absmap ABS_RX=X2 --evdev-keymap BTN_THUMB2=a,BTN_THUMB=b,BTN_PINKIE=rt --mimic-xpad
</pre>
<p>Приведенный выше пример является неполным. Он привязывает только одну ось стика и три кнопки в качестве примера. Используйте <code>xboxdrv --help-button</code>, чтобы узнать названия кнопок и осей стиков контроллера Xbox360 и привязать их в соответствии с командой выше. Привязки осей стиков должны следовать после <code>--evdev-absmap</code>, а привязки кнопок - после <code>--evdev-keymap</code> (список, разделенный запятыми; без пробелов).
</p>
<p>По умолчанию xboxdrv выводит все события в терминал. Таким образом, можно понять, что все привязки являются корректными. Используйте опцию <code>--silent</code>, чтобы отключить вывод в терминал.
</p>
<p><br>
</p>
<h6><span class="mw-headline" id="Logitech_Dual_Action">Logitech Dual Action</span></h6>
<p>Геймпад Logitech Dual Action очень похож (в контексте привязки кнопок) на геймпад от PS2, но некторые кнопки и гашетки нужно поменять местами, чтобы имитировать контроллер Xbox.
</p>
<pre> # xboxdrv --evdev /dev/input/event* \
   --evdev-absmap ABS_X=x1,ABS_Y=y1,ABS_RZ=x2,ABS_Z=y2,ABS_HAT0X=dpad_x,ABS_HAT0Y=dpad_y \
   --axismap -Y1=Y1,-Y2=Y2 \
   --evdev-keymap BTN_TRIGGER=x,BTN_TOP=y,BTN_THUMB=a,BTN_THUMB2=b,BTN_BASE3=back,BTN_BASE4=start,BTN_BASE=lt,BTN_BASE2=rt,BTN_TOP2=lb,BTN_PINKIE=rb,BTN_BASE5=tl,BTN_BASE6=tr \
   --mimic-xpad --silent
</pre>
<h6>
<span id=".D0.9A.D0.BE.D0.BD.D1.82.D1.80.D0.BE.D0.BB.D0.BB.D0.B5.D1.80_PlayStation_2_.D1.87.D0.B5.D1.80.D0.B5.D0.B7_.D0.B0.D0.B4.D0.B0.D0.BF.D1.82.D0.B5.D1.80_USB"></span><span class="mw-headline" id="Контроллер_PlayStation_2_через_адаптер_USB">Контроллер PlayStation 2 через адаптер USB</span>
</h6>
<p>Чтобы исправить назначение кнопок адаптеров PS2 и имитировать контроллер Xbox, выполните следующую команду:
</p>
<pre> # xboxdrv --evdev /dev/input/event* \
   --evdev-absmap ABS_X=x1,ABS_Y=y1,ABS_RZ=x2,ABS_Z=y2,ABS_HAT0X=dpad_x,ABS_HAT0Y=dpad_y \
   --axismap -Y1=Y1,-Y2=Y2 \
   --evdev-keymap   BTN_TOP=x,BTN_TRIGGER=y,BTN_THUMB2=a,BTN_THUMB=b,BTN_BASE3=back,BTN_BASE4=start,BTN_BASE=lb,BTN_BASE2=rb,BTN_TOP2=lt,BTN_PINKIE=rt,BTN_BASE5=tl,BTN_BASE6=tr \
   --mimic-xpad --silent
</pre>
<h6>
<span id=".D0.9A.D0.BE.D0.BD.D1.82.D1.80.D0.BE.D0.BB.D0.BB.D0.B5.D1.80_PlayStation_2_.D1.87.D0.B5.D1.80.D0.B5.D0.B7_USB"></span><span class="mw-headline" id="Контроллер_PlayStation_2_через_USB">Контроллер PlayStation 2 через USB</span>
</h6>
<p>Если взять контроллер PS3 и подключить его по USB, xboxdrv не нужно указывать никаких привязок (они встроены). Просто запустите программу (и отключите текущий запущенный драйвер), и все заработает.
</p>
<pre># xboxdrv --silent --detach-kernel-driver
</pre>
<h6>
<span id=".D0.9A.D0.BE.D0.BD.D1.82.D1.80.D0.BE.D0.BB.D0.BB.D0.B5.D1.80_PlayStation_2_.D1.87.D0.B5.D1.80.D0.B5.D0.B7_Bluetooth"></span><span class="mw-headline" id="Контроллер_PlayStation_2_через_Bluetooth">Контроллер PlayStation 2 через Bluetooth</span>
</h6>
<p>Подключив контроллер по Bluetooth, найдите его адрес при помощи <code>bluetoothctl</code>. Затем создайте новое правило для udev следующего содержания:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/udev/rules.d/99-dualshock.rules</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">KERNEL=="event*", SUBSYSTEM=="input", ATTRS{uniq}=="&lt;device_addr_you_got_on_pairing&gt;", SYMLINK+="input/dualshock3"</pre>
<p>Адрес контроллера пишется строчными буквами, например <code>06:9a:b4:c8:ef:8b</code>.
</p>
<p>Теперь запустите xboxdrv:
</p>
<pre>$ xboxdrv --evdev /dev/input/dualshock3 --mimic-xpad
</pre>
<h6>
<span id=".D0.9A.D0.BE.D0.BD.D1.82.D1.80.D0.BE.D0.BB.D0.BB.D0.B5.D1.80_PlayStation_4"></span><span class="mw-headline" id="Контроллер_PlayStation_4">Контроллер PlayStation 4</span>
</h6>
<p>Чтобы исправить привязяки кнопок контроллера PS4, воспользуйтесь следующей командой xboxdrv (или попробуйте программу <a rel="nofollow" class="external text" href="https://github.com/chrippa/ds4drv">ds4drv</a>):
</p>
<pre> # xboxdrv  \                                                                      
   --evdev /dev/input/by-id/usb-Sony_Computer_Entertainment_Wireless_Controller-event-joys&gt;
   --evdev-absmap ABS_X=x1,ABS_Y=y1                 \                               
   --evdev-absmap ABS_Z=x2,ABS_RZ=y2                \                               
   --evdev-absmap ABS_HAT0X=dpad_x,ABS_HAT0Y=dpad_y \                               
   --evdev-keymap BTN_A=x,BTN_B=a                   \                               
   --evdev-keymap BTN_C=b,BTN_X=y                   \                               
   --evdev-keymap BTN_Y=lb,BTN_Z=rb                 \                               
   --evdev-keymap BTN_TL=lt,BTN_TR=rt               \
   --evdev-keymap BTN_SELECT=tl,BTN_START=tr        \                               
   --evdev-keymap BTN_TL2=back,BTN_TR2=start        \                               
   --evdev-keymap BTN_MODE=guide                    \                               
   --axismap -y1=y1,-y2=y2                          \                               
   --mimic-xpad                                     \                               
   --silent
</pre>
<h2>
<span id=".D0.A0.D0.B5.D1.88.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BF.D1.80.D0.BE.D0.B1.D0.BB.D0.B5.D0.BC"></span><span class="mw-headline" id="Решение_проблем">Решение проблем</span>
</h2>
<h3>
<span id=".D0.9F.D0.B5.D1.80.D0.B5.D0.BC.D0.B5.D1.89.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BA.D1.83.D1.80.D1.81.D0.BE.D1.80.D0.B0_.D0.BC.D1.8B.D1.88.D0.B8_.D0.B4.D0.B6.D0.BE.D0.B9.D1.81.D1.82.D0.B8.D0.BA.D0.BE.D0.BC"></span><span class="mw-headline" id="Перемещение_курсора_мыши_джойстиком">Перемещение курсора мыши джойстиком</span>
</h3>
<p>Иногда USB-геймпад может быть распознан как HID-совместимая мышь (только в сеансе X, несмотря на то, что он установлен как устройство <code>/dev/input/js0</code>).
Известная проблема - когда курсоры мыши передвигается стиками джойстика или блокируется на краю экрана. Если ваша программа может определить геймпад сама, можете удалить пакет xf86-input-joystick.
Более элегантное решение -  <a href="#%D0%9E%D1%82%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F_%D0%BC%D1%8B%D1%88%D1%8C%D1%8E_%D0%BF%D1%80%D0%B8_%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D0%B8_%D0%B4%D0%B6%D0%BE%D0%B9%D1%81%D1%82%D0%B8%D0%BA%D0%B0">#Отключение управления мышью при помощи джойстика</a>.
</p>
<h3>
<span id=".D0.94.D0.B6.D0.BE.D0.B9.D1.81.D1.82.D0.B8.D0.BA_.D0.BD.D0.B5_.D1.80.D0.B0.D0.B1.D0.BE.D1.82.D0.B0.D0.B5.D1.82_.D0.B2_.D0.B8.D0.B3.D1.80.D0.B0.D1.85_.D0.BD.D0.B0_FNA.2FSDL"></span><span class="mw-headline" id="Джойстик_не_работает_в_играх_на_FNA/SDL">Джойстик не работает в играх на FNA/SDL</span>
</h3>
<p>Если вы пользуетесь ноунейм-геймпадом, вы можете столкнуться с проблемами с его определением в играх на SDL. С <a rel="nofollow" class="external text" href="https://github.com/flibitijibibo/FNA/commit/e55742cfe7e38b778a21ed8a12cb2f2081490d8d">14 мая 2015</a> вы можете положить файл <code>gamecontrollerdb.txt </code> в папку с запускаемым файлом гры на FNA, например, <a rel="nofollow" class="external text" href="https://github.com/gabomdq/SDL_GameControllerDB">SDL_GameControllerDB</a>.
</p>
<p>Другой способ, который подходит также для более ранних версий FNA и SDL - создание привязки кнопок самостоятельно. Для этого необходимо скачать исходники SDL отсюда: <a rel="nofollow" class="external free" href="https://libsdl.org/">https://libsdl.org/</a>, перейти в папку <code>/test/</code>, собрать программу <code>controllermap.c</code> (или установить пакет <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/controllermap/">controllermap</a></span><sup><small>AUR</small></sup>) и запустить тест. После завершения теста controllermap, будет сгенерирован guid, который нужно подставить в переменную окружения <code>SDL_GAMECONTROLLERCONFIG</code>, которой в последствии будут пользоваться игры на SDL/FNA. Например:
</p>
<pre> $ export SDL_GAMECONTROLLERCONFIG="030000008f0e00000300000010010000,GreenAsia Inc. USB Joystick ,platform:Linux,x:b3,a:b2,b:b1,y:b0,back:b8,start:b9,dpleft:h0.8,dpdown:h0.0,dpdown:h0.4,dpright:h0.0,dpright:h0.2,dpup:h0.0,dpup:h0.1,leftshoulder:h0.0,leftshoulder:b6,lefttrigger:b4,rightshoulder:b7,righttrigger:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a3,righty:a2,"
</pre>
<h3>
<span id=".D0.93.D0.B5.D0.B9.D0.BC.D0.BF.D0.B0.D0.B4_.D0.BD.D0.B5_.D1.80.D0.B0.D1.81.D0.BF.D0.BE.D0.B7.D0.BD.D0.B0.D0.B5.D1.82.D1.81.D1.8F_.D0.BD.D0.B8.D0.BA.D0.B0.D0.BA.D0.B8.D0.BC.D0.B8_.D0.BF.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D0.B0.D0.BC.D0.B8"></span><span class="mw-headline" id="Геймпад_не_распознается_никакими_программами">Геймпад не распознается никакими программами</span>
</h3>
<p>Некоторые программы, например, Steam, могут распознать только первый джойстик, с которым столкнутся. Из-за бага в драйвере беспроводных устройств Microsoft, это может быть донгл bluetooth от беспроводной клавиатуры или мыши. Если вы увидите, что <code>/dev/input/js*</code> и <code>/dev/input/event*</code> принадлежат приемнику bluetooth-клавиатуры, вы можете автоматически избавиться от них, создав соответствующие правила udev.
Создайте <code>/</code>:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/udev/rules.d/99-btcleanup.rules</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">ACTION=="add", KERNEL=="js[0-9]*", SUBSYSTEM=="input", KERNELS=="...", ATTRS{bInterfaceSubClass}=="00", ATTRS{bInterfaceProtocol}=="00", ATTRS{bInterfaceNumber}=="02", RUN+="/usr/bin/rm /dev/input/js%n"
ACTION=="add", KERNEL=="event*", SUBSYSTEM=="input", KERNELS=="...", ATTRS{bInterfaceSubClass}=="00", ATTRS{bInterfaceProtocol}=="00", ATTRS{bInterfaceNumber}=="02", RUN+="/usr/bin/rm /dev/input/event%n"
</pre>
<p>Correct the <code>KERNELS=="..."</code>. Узнать нужные значения можно так:
</p>
<pre># udevadm info -an /dev/input/js0
</pre>
<p>Предпожим, что устройство "под вопросом" - это <code>/dev/input/js0</code>. После создания правила выполните:
</p>
<pre># udevadm control --reload
</pre>
<p>Затем переподключите проблемное устройство. Файлы должны исчезнуть.
</p>
<h3>
<span id=".D0.9D.D0.B5_.D1.80.D0.B0.D0.B1.D0.BE.D1.82.D0.B0.D0.B5.D1.82_Steam_Controller"></span><span class="mw-headline" id="Не_работает_Steam_Controller">Не работает Steam Controller</span>
</h3>
<div class="noprint archwiki-template-message">
<p><a href="/title/File:Tango-view-fullscreen.png" class="image"><img alt="Tango-view-fullscreen.png" src="../File:Tango-view-fullscreen.png" decoding="async" width="48" height="48"></a><b>This article or section needs expansion.</b><a href="/title/File:Tango-view-fullscreen.png" class="image"><img alt="Tango-view-fullscreen.png" src="../File:Tango-view-fullscreen.png" decoding="async" width="48" height="48"></a></p>
<div>
<b>Reason:</b> Under what circumstances do the recommendations under <a href="#Steam_Controller">#Steam Controller</a> not work? When are these alternatives required? (Discuss in <a rel="nofollow" class="external text" href="https://wiki.archlinux.org/title/Talk:Gamepad_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)">Talk:Gamepad (Русский)#</a>)</div>
</div>
<p>Если Steam Controller не подключается в беспроводном режиме, но работает с использованием кабеля, вам, возможно, необходимо создать следующее правило udev, предложенное Valve <a rel="nofollow" class="external autonumber" href="https://steamcommunity.com/app/353370/discussions/0/490123197956024380/">[1]</a>:
</p>
<p><code>/lib/udev/rules.d/99-steam-controller-perms.rules</code>
</p>
<pre># This rule is needed for basic functionality of the controller in Steam and keyboard/mouse emulation
SUBSYSTEM=="usb", ATTRS{idVendor}=="28de", MODE="0666"

# This rule is necessary for gamepad emulation; make sure you replace 'pgriffais' with a group that the user that runs Steam belongs to
KERNEL=="uinput", MODE="0660", GROUP="steamcontroller", OPTIONS+="static_node=uinput"
</pre>
<p>Также создайте группу пользователей Steam Controller:
</p>
<pre># groupadd steamcontroller
</pre>
<p>И добавьте своего пользователя в эту группу:
</p>
<pre># gpasswd -a $USER steamcontroller
</pre>
</div>
</div>
<div id="catlinks" class="catlinks" data-mw="interface">
<div id="mw-normal-catlinks" class="mw-normal-catlinks">
<a href="/title/Special:Categories" title="Special:Categories">Categories</a>: <ul>
<li><a href="/title/Category:Input_devices_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)" title="Category:Input devices (Русский)">Input devices (Русский)</a></li>
<li><a href="/title/Category:Gaming_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)" title="Category:Gaming (Русский)">Gaming (Русский)</a></li>
</ul>
</div>
<div id="mw-hidden-catlinks" class="mw-hidden-catlinks mw-hidden-cats-hidden">Hidden categories: <ul>
<li><a href="/title/Category:Pages_with_broken_section_links" title="Category:Pages with broken section links">Pages with broken section links</a></li>
<li><a href="/title/Category:Pages_or_sections_flagged_with_Template:Accuracy" title="Category:Pages or sections flagged with Template:Accuracy">Pages or sections flagged with Template:Accuracy</a></li>
<li><a href="/title/Category:Pages_with_broken_package_links" title="Category:Pages with broken package links">Pages with broken package links</a></li>
<li><a href="/title/Category:Pages_or_sections_flagged_with_Template:Expansion" title="Category:Pages or sections flagged with Template:Expansion">Pages or sections flagged with Template:Expansion</a></li>
</ul>
</div>
</div>
	</div>
</div>

<footer id="footer" class="mw-footer" role="contentinfo" style="margin: 0">
	<ul id="footer-info">
		<li>Retrieved from "<a dir="ltr" href="https://wiki.archlinux.org/index.php?title=Gamepad_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)&amp;oldid=668818">https://wiki.archlinux.org/index.php?title=Gamepad_(Русский)&amp;oldid=668818</a>"</li>
		<li id="footer-info-lastmod"> This page was last edited on 8 May 2021, at 10:47.</li>
		<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3 or later</a> unless otherwise noted.</li>
	<br>
</ul>
	<ul id="footer-places">
		<li id="footer-places-privacy"><a href="/title/ArchWiki:Privacy_policy" title="ArchWiki:Privacy policy">Privacy policy</a></li>
		<li id="footer-places-about"><a href="/title/ArchWiki:About" title="ArchWiki:About">About ArchWiki</a></li>
		<li id="footer-places-disclaimer"><a href="/title/ArchWiki:General_disclaimer" title="ArchWiki:General disclaimer">Disclaimers</a></li>
	</ul>
	<ul id="footer-icons" class="noprint">
		<li id="footer-copyrightico">
	</ul>
	<div style="clear: both;"></div>
</footer>



</body>
</html>
