<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<title>Bumblebee (简体中文) - ArchWiki</title>
<link rel="stylesheet" href="../ArchWikiOffline.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<meta name="generator" content="MediaWiki 1.35.0">
<meta name="robots" content="noindex,follow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="/opensearch_desc.php" title="ArchWiki (en)">
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.archlinux.org/api.php?action=rsd">
<link rel="license" href="http://www.gnu.org/copyleft/fdl.html">
<link rel="alternate" type="application/atom+xml" title="ArchWiki Atom feed" href="/index.php?title=Special:RecentChanges&amp;feed=atom">
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Bumblebee_简体中文 rootpage-Bumblebee_简体中文 skin-vector action-view skin-vector-legacy">
<div id="content" class="mw-body" role="main" style="margin: 0">
	<a id="top"></a>
	<div id="siteNotice" class="mw-body-content"></div>
	<div class="mw-indicators mw-body-content">
	</div>
	<h1 id="firstHeading" class="firstHeading" lang="en">Bumblebee (简体中文)</h1>
	<div id="bodyContent" class="mw-body-content">
		<div id="siteSub" class="noprint">From ArchWiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="#searchInput">Jump to search</a>
		<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<div class="warningbox">The printable version is no longer supported and may have rendering errors. Please update your browser bookmarks and please use the default browser print function instead.</div>
<div class="mw-parser-output">
<div class="archwiki-template-meta-related-articles-start">
<p>相关文章</p>
<ul>
<li><a href="../en/NVIDIA_Optimus.html" title="NVIDIA Optimus">NVIDIA Optimus</a></li>
<li><a href="../zh-CN/Nouveau.html" title="Nouveau (简体中文)">Nouveau (简体中文)</a></li>
<li><a href="../zh-CN/NVIDIA.html" title="NVIDIA (简体中文)">NVIDIA (简体中文)</a></li>
<li><a href="../zh-CN/Intel_graphics.html" class="mw-redirect" title="Intel Graphics (简体中文)">Intel图形卡</a></li>
</ul>
</div>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>翻译状态：</strong>本文是 <a href="../en/Bumblebee.html" title="Bumblebee">Bumblebee</a> 的<a href="../zh-CN/ArchWiki:Translation_Team.html" title="ArchWiki:Translation Team (简体中文)">翻译</a>。上次翻译日期：2017-12-01。如果英文版本有所<a rel="nofollow" class="external text" href="https://wiki.archlinux.org/index.php?title=Bumblebee&amp;diff=0&amp;oldid=359259">更改</a>，则您可以帮助同步翻译。</div>
<p>引自 Bumblebee <a rel="nofollow" class="external text" href="https://github.com/Bumblebee-Project/Bumblebee/wiki/FAQ">FAQ</a>:
</p>
<p>"<i>Bumblebee 致力于使 NVIDIA Optimus 在 GNU/Linux 系统上可用，实现两块不同的供电配置的显卡同时插入使用，共享同一个 framebuffer。</i>"
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading">
<input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none"><div class="toctitle" lang="en" dir="ltr">
<h2 id="mw-toc-heading">Contents</h2>
<span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span>
</div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Bumblebee:_Linux%E4%B8%8A%E7%9A%84_Optimus"><span class="tocnumber">1</span> <span class="toctext">Bumblebee: Linux上的 Optimus</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#%E5%AE%89%E8%A3%85"><span class="tocnumber">2</span> <span class="toctext">安装</span></a></li>
<li class="toclevel-1 tocsection-3">
<a href="#%E7%94%A8%E6%B3%95"><span class="tocnumber">3</span> <span class="toctext">用法</span></a>
<ul>
<li class="toclevel-2 tocsection-4"><a href="#%E6%B5%8B%E8%AF%95"><span class="tocnumber">3.1</span> <span class="toctext">测试</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#%E4%B8%80%E8%88%AC%E7%94%A8%E6%B3%95"><span class="tocnumber">3.2</span> <span class="toctext">一般用法</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-6">
<a href="#%E9%85%8D%E7%BD%AE"><span class="tocnumber">4</span> <span class="toctext">配置</span></a>
<ul>
<li class="toclevel-2 tocsection-7">
<a href="#%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96"><span class="tocnumber">4.1</span> <span class="toctext">速度优化</span></a>
<ul>
<li class="toclevel-3 tocsection-8"><a href="#%E4%BD%BF%E7%94%A8VirtualGL%E4%BD%9C%E4%B8%BA%E6%A1%A5%E6%8E%A5"><span class="tocnumber">4.1.1</span> <span class="toctext">使用VirtualGL作为桥接</span></a></li>
<li class="toclevel-3 tocsection-9"><a href="#Primusrun"><span class="tocnumber">4.1.2</span> <span class="toctext">Primusrun</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-10">
<a href="#%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86"><span class="tocnumber">4.2</span> <span class="toctext">电源管理</span></a>
<ul>
<li class="toclevel-3 tocsection-11"><a href="#%E4%BD%BF%E7%94%A8bbswitch%E6%97%B6%E9%BB%98%E8%AE%A4%E7%9A%84_NVIDIA_%E7%94%B5%E6%BA%90%E7%8A%B6%E6%80%81"><span class="tocnumber">4.2.1</span> <span class="toctext">使用bbswitch时默认的 NVIDIA 电源状态</span></a></li>
<li class="toclevel-3 tocsection-12"><a href="#%E5%85%B3%E6%9C%BA%E6%97%B6%E5%90%AF%E7%94%A8NVIDIA%E6%98%BE%E5%8D%A1"><span class="tocnumber">4.2.2</span> <span class="toctext">关机时启用NVIDIA显卡</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-13">
<a href="#%E5%A4%9A%E6%98%BE%E7%A4%BA%E5%99%A8"><span class="tocnumber">4.3</span> <span class="toctext">多显示器</span></a>
<ul>
<li class="toclevel-3 tocsection-14"><a href="#%E6%98%BE%E7%A4%BA%E5%99%A8%E8%BF%9E%E6%8E%A5%E5%9C%A8_Intel_%E6%98%BE%E5%8D%A1%E4%B8%8A"><span class="tocnumber">4.3.1</span> <span class="toctext">显示器连接在 Intel 显卡上</span></a></li>
<li class="toclevel-3 tocsection-15">
<a href="#%E6%98%BE%E7%A4%BA%E5%99%A8%E8%BF%9E%E6%8E%A5%E5%9C%A8_NVIDIA_%E6%98%BE%E5%8D%A1%E4%B8%8A"><span class="tocnumber">4.3.2</span> <span class="toctext">显示器连接在 NVIDIA 显卡上</span></a>
<ul>
<li class="toclevel-4 tocsection-16"><a href="#xf86-video-intel-virtual-crtc_%E5%92%8C_hybrid-screenclone"><span class="tocnumber">4.3.2.1</span> <span class="toctext">xf86-video-intel-virtual-crtc 和 hybrid-screenclone</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-17"><a href="#%E5%A6%82_Windows_%E4%B8%80%E8%88%AC%E5%9C%A8%E9%9B%86%E6%98%BE%E5%92%8C%E7%8B%AC%E6%98%BE%E9%97%B4%E5%88%87%E6%8D%A2"><span class="tocnumber">5</span> <span class="toctext">如 Windows 一般在集显和独显间切换</span></a></li>
<li class="toclevel-1 tocsection-18"><a href="#%E4%B8%8D%E4%BE%9D%E8%B5%96Bumblebee%E6%9D%A5%E4%BD%BF%E7%94%A8CUDA"><span class="tocnumber">6</span> <span class="toctext">不依赖Bumblebee来使用CUDA</span></a></li>
<li class="toclevel-1 tocsection-19">
<a href="#%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98"><span class="tocnumber">7</span> <span class="toctext">疑难问题</span></a>
<ul>
<li class="toclevel-2 tocsection-20"><a href="#%5BVGL%5D_ERROR:_Could_not_open_display_:8"><span class="tocnumber">7.1</span> <span class="toctext">[VGL] ERROR: Could not open display :8</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="#Xlib:_extension_%22GLX%22_missing_on_display_%22:0.0%22"><span class="tocnumber">7.2</span> <span class="toctext">Xlib: extension "GLX" missing on display ":0.0"</span></a></li>
<li class="toclevel-2 tocsection-22">
<a href="#%5BERROR%5DCannot_access_secondary_GPU:_No_devices_detected"><span class="tocnumber">7.3</span> <span class="toctext">[ERROR]Cannot access secondary GPU: No devices detected</span></a>
<ul>
<li class="toclevel-3 tocsection-23"><a href="#NVIDIA(0):_Failed_to_assign_any_connected_display_devices_to_X_screen_0"><span class="tocnumber">7.3.1</span> <span class="toctext">NVIDIA(0): Failed to assign any connected display devices to X screen 0</span></a></li>
<li class="toclevel-3 tocsection-24"><a href="#systemd-logind:_failed_to_get_session:_PID_XXX_does_not_belong_to_any_known_session"><span class="tocnumber">7.3.2</span> <span class="toctext">systemd-logind: failed to get session: PID XXX does not belong to any known session</span></a></li>
<li class="toclevel-3 tocsection-25"><a href="#Failed_to_initialize_the_NVIDIA_GPU_at_PCI:1:0:0_(GPU_fallen_off_the_bus_/_RmInitAdapter_failed!)"><span class="tocnumber">7.3.3</span> <span class="toctext">Failed to initialize the NVIDIA GPU at PCI:1:0:0 (GPU fallen off the bus / RmInitAdapter failed!)</span></a></li>
<li class="toclevel-3 tocsection-26"><a href="#Could_not_load_GPU_driver"><span class="tocnumber">7.3.4</span> <span class="toctext">Could not load GPU driver</span></a></li>
<li class="toclevel-3 tocsection-27"><a href="#NOUVEAU(0):_%5Bdrm%5D_failed_to_set_drm_interface_version"><span class="tocnumber">7.3.5</span> <span class="toctext">NOUVEAU(0): [drm] failed to set drm interface version</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-28"><a href="#%5BERROR%5DCannot_access_secondary_GPU_-_error:_X_did_not_start_properly"><span class="tocnumber">7.4</span> <span class="toctext">[ERROR]Cannot access secondary GPU - error: X did not start properly</span></a></li>
<li class="toclevel-2 tocsection-29"><a href="#/dev/dri/card0:_failed_to_set_DRM_interface_version_1.4:_Permission_denied"><span class="tocnumber">7.5</span> <span class="toctext">/dev/dri/card0: failed to set DRM interface version 1.4: Permission denied</span></a></li>
<li class="toclevel-2 tocsection-30"><a href="#ERROR:_ld.so:_object_'libdlfaker.so'_from_LD_PRELOAD_cannot_be_preloaded:_ignored"><span class="tocnumber">7.6</span> <span class="toctext">ERROR: ld.so: object 'libdlfaker.so' from LD_PRELOAD cannot be preloaded: ignored</span></a></li>
<li class="toclevel-2 tocsection-31"><a href="#Fatal_IO_error_11_(Resource_temporarily_unavailable)_on_X_server"><span class="tocnumber">7.7</span> <span class="toctext">Fatal IO error 11 (Resource temporarily unavailable) on X server</span></a></li>
<li class="toclevel-2 tocsection-32"><a href="#%E8%A7%86%E9%A2%91%E6%92%95%E8%A3%82"><span class="tocnumber">7.8</span> <span class="toctext">视频撕裂</span></a></li>
<li class="toclevel-2 tocsection-33"><a href="#Bumblebee_cannot_connect_to_socket"><span class="tocnumber">7.9</span> <span class="toctext">Bumblebee cannot connect to socket</span></a></li>
<li class="toclevel-2 tocsection-34"><a href="#Running_X.org_from_console_after_login_(rootless_X.org)"><span class="tocnumber">7.10</span> <span class="toctext">Running X.org from console after login (rootless X.org)</span></a></li>
<li class="toclevel-2 tocsection-35"><a href="#Primusrun_%E9%BC%A0%E6%A0%87%E5%BB%B6%E8%BF%9F/%E7%A6%81%E7%94%A8_VSYNC"><span class="tocnumber">7.11</span> <span class="toctext">Primusrun 鼠标延迟/禁用 VSYNC</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-36"><a href="#%E5%8F%A6%E8%A7%81"><span class="tocnumber">8</span> <span class="toctext">另见</span></a></li>
</ul>
</div>

<h2>
<span id="Bumblebee:_Linux.E4.B8.8A.E7.9A.84_Optimus"></span><span class="mw-headline" id="Bumblebee:_Linux上的_Optimus">Bumblebee: Linux上的 Optimus</span>
</h2>
<p><a rel="nofollow" class="external text" href="http://www.nvidia.cn/object/optimus_technology_cn.html">Optimus 技术</a> 是不依赖于硬件复杂结构的 <i><a rel="nofollow" class="external text" href="http://hybrid-graphics-linux.tuxfamily.org/index.php?title=Hybrid_graphics">交火显卡 </a></i> 实现。独立显卡按需渲染，并传输给集成显卡，集成显卡则负责显示功能。当笔记本通过电池供电时，独立显卡将关闭，以延长电池寿命。在使用 Intel 集成显卡和 NVIDIA 独立显卡的台式机上也能使用这项技术。
</p>
<p>Bumblebee 通过软件来实现它的功能，包括两个部分：
</p>
<ul>
<li>利用独立显卡渲染程序，并通过集成显卡将图像显示在屏幕上。这是利用 VirtualGL 或 primus （见后面小节）实现的，相当于连接到了一个供独立显卡使用的 X 服务器。</li>
<li>独立显卡空闲的时候会被禁用。（参见 <a href="#%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86">#电源管理</a> ）</li>
</ul>
<p>Bumblebee 试图模拟 Optimus 技术的行为；当需要的时候，使用独立显卡进行渲染，不使用的时候则关闭。当前的版本仅支持按需渲染，高负荷程序自动调用独立显卡的功能仍然在开发之中。
</p>
<h2>
<span id=".E5.AE.89.E8.A3.85"></span><span class="mw-headline" id="安装">安装</span>
</h2>
<p>安装 Bumblebee 之前，检查你的 BIOS 并尽可能激活 Optimus (老式电脑称之为"可切换显卡"，BIOS有可能没有提供此项设置)。如果 "Optimus" 和 "switchable" 都没有在BIOS里，就保证两种GPU都已启用并且集成显卡是主要显示设备。显示应该连接在主板上的集成显卡，而不是独立显卡。如果集成显卡之前被禁用而安装了独立显卡的驱动，那就删除 <code>/etc/X11/xorg.conf</code> 或者有关独立显卡的 <code>/etc/X11/xorg.conf.d</code> 中的文件。
</p>
<p><a href="../zh-CN/Help:Reading.html#%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%8C%85" class="mw-redirect" title="安装">安装</a>:
</p>
<ul>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=bumblebee">bumblebee</a></span> - 提供守护进程以及程序的主要安装包。</li>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=mesa">mesa</a></span> - 开源的 <b>OpenGL</b> 标准实现。</li>
<li>对于合适的NVIDIA驱动，参看<a href="../zh-CN/NVIDIA.html#.E5.AE.89.E8.A3.85" title="NVIDIA (简体中文)">NVIDIA#安装</a> 。</li>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=xf86-video-intel">xf86-video-intel</a></span> - Intel 驱动（可选）。</li>
</ul>
<p>对于32位程序 (必须启用<a href="../en/Official_repositories.html#multilib" class="mw-redirect" title="Multilib">Multilib</a>）在64位机器上的支持，安装:
</p>
<ul>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=lib32-virtualgl">lib32-virtualgl</a></span> - 为32位应用提供的渲染/显示桥。</li>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=lib32-nvidia-utils">lib32-nvidia-utils</a></span> 或者 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/lib32-nvidia-340xx-utils/">lib32-nvidia-340xx-utils</a></span><sup><small>AUR</small></sup>（和64位对应）。</li>
</ul>
<p>要使用 Bumblebee，请确保添加你的用户到 <code>bumblebee</code> 组：
</p>
<pre># gpasswd -a <i>user</i> bumblebee
</pre>
<p>并 <a href="../en/Systemd.html#Using_units" class="mw-redirect" title="Enable">启用</a> <code>bumblebeed.service</code>。重启系统并参考<a href="#%E7%94%A8%E6%B3%95">#用法</a>。
</p>
<h2>
<span id=".E7.94.A8.E6.B3.95"></span><span class="mw-headline" id="用法">用法</span>
</h2>
<h3>
<span id=".E6.B5.8B.E8.AF.95"></span><span class="mw-headline" id="测试">测试</span>
</h3>
<p>安装 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=mesa-demos">mesa-demos</a></span> 并使用 <code>glxgears</code> 测试 Bumblebee 是否工作：
</p>
<pre>$ optirun glxgears -info
</pre>
<p>如果失败，尝试下列命令:
</p>
<ul><li>64位系统:</li></ul>
<pre>$ optirun glxspheres64
</pre>
<ul><li>32位系统:</li></ul>
<pre>$ optirun glxspheres32
</pre>
<p>如果一个内有动画的窗口出现，那么 Optimus 和 Bumblebee 正在工作。
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 如果 <code>glxgears</code> 失败但 <code>glxspheres<i>XX</i></code> 有效，替换所有 "<code>glxgears</code>" 为 "<code>glxspheres<i>XX</i></code>"。</div>
<h3>
<span id=".E4.B8.80.E8.88.AC.E7.94.A8.E6.B3.95"></span><span class="mw-headline" id="一般用法">一般用法</span>
</h3>
<pre>$ optirun [options] <i>application</i> [application-parameters]
</pre>
<p>例如，用 Optimus 启动 Windows 程序:
</p>
<pre>$ optirun wine application.exe
</pre>
<p>另外，用 Optimus 打开 NVIDIA 设置面板:
</p>
<pre>$ optirun -b none nvidia-settings -c :8
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 一个打了补丁的 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/nvdock/">nvdock</a></span><sup><small>AUR</small></sup> 版本可用： <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/nvdock-bumblebee/">nvdock-bumblebee</a></span><sup><small>AUR</small></sup>
</div>
<p>更多 <code>optirun</code> 的选项参见手册页:
</p>
<pre>$ man optirun
</pre>
<h2>
<span id=".E9.85.8D.E7.BD.AE"></span><span class="mw-headline" id="配置">配置</span>
</h2>
<p>你可以按需配置 Bumblebee 的行为，可以通过 <code>/etc/bumblebee/bumblebee.conf</code> 来调节诸如优化，电源管理，以及其他任务。
</p>
<h3>
<span id=".E9.80.9F.E5.BA.A6.E4.BC.98.E5.8C.96"></span><span class="mw-headline" id="速度优化">速度优化</span>
</h3>
<h4>
<span id=".E4.BD.BF.E7.94.A8VirtualGL.E4.BD.9C.E4.B8.BA.E6.A1.A5.E6.8E.A5"></span><span class="mw-headline" id="使用VirtualGL作为桥接">使用VirtualGL作为桥接</span>
</h4>
<p>Bumblebee 使用你的 Optimus NVIDIA 显卡来渲染一个配置了 VirtualGL 的不可见的 X 服务器，并且将结果传输到你当前的 X 服务器上。传输之前将压缩侦，这可以节省带宽并且能够用于加速 bumblebee 的优化。
</p>
<p>要为单个应用程序指定不同的压缩方法：
</p>
<pre>$ optirun -c <i>compress-method</i> application
</pre>
<p>压缩方法会影响 GPU性能和GPU使用，压缩方法会最大限度的使用 CPU,并且尽可能少的使用 GPU；非压缩的方法最大限度的使用 GPU，而尽可能少的使用 CPU。
</p>
<p>压缩方法
</p>
<dl><dd><ul>
<li><code>jpeg</code></li>
<li><code>rgb</code></li>
<li><code>yuv</code></li>
</ul></dd></dl>
<p>非压缩方法
</p>
<dl><dd><ul>
<li><code>proxy</code></li>
<li><code>xv</code></li>
</ul></dd></dl>
<p>以下是用 <a href="../en/ASUS_N550JV.html" title="ASUS N550JV">Asus N550JV</a> 笔记本和测试程序 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/unigine-heaven/">unigine-heaven</a></span><sup><small>AUR</small></sup>的性能测试结果:
</p>
<table class="wikitable">
<tbody>
<tr>
<th>Command</th>
<th>FPS</th>
<th>Score</th>
<th>Min FPS</th>
<th>Max FPS
</th>
</tr>
<tr>
<td>optirun unigine-heaven</td>
<td>25.0</td>
<td>630</td>
<td>16.4</td>
<td>36.1
</td>
</tr>
<tr>
<td>optirun -c jpeg unigine-heaven</td>
<td>24.2</td>
<td>610</td>
<td>9.5</td>
<td>36.8
</td>
</tr>
<tr>
<td>optirun -c rgb unigine-heaven</td>
<td>25.1</td>
<td>632</td>
<td>16.6</td>
<td>35.5
</td>
</tr>
<tr>
<td>optirun -c yuv unigine-heaven</td>
<td>24.9</td>
<td>626</td>
<td>16.5</td>
<td>35.8
</td>
</tr>
<tr>
<td>optirun -c proxy unigine-heaven</td>
<td>25.0</td>
<td>629</td>
<td>16.0</td>
<td>36.1
</td>
</tr>
<tr>
<td>optirun -c xv unigine-heaven</td>
<td>22.9</td>
<td>577</td>
<td>15.4</td>
<td>32.2
</td>
</tr>
</tbody>
</table>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 使用 <code>jpeg</code> 压缩方法时会有延迟。</div>
<p>要为所有应用程序使用一个标准的压缩方法， 在 <code>/etc/bumblebee/bumblebee.conf</code> 里把 <code>VGLTransport</code> 设为 <code><i>compress-method</i></code>:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/bumblebee/bumblebee.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[...]
[optirun]
VGLTransport=proxy
[...]</pre>
<p>你也可考虑 VirtualGL 从你的显卡读回像素的方式。设置 <code>VGL_READBACK</code> 环境变量为 <code>pbo</code> 应该能提升性能。比较以下两者:
</p>
<pre># PBO should be faster.
VGL_READBACK=pbo optirun glxgears
# The default value is sync.
VGL_READBACK=sync optirun glxgears
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 调整CPU频率将直接影响渲染性能</div>
<h4><span class="mw-headline" id="Primusrun">Primusrun</span></h4>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 因为合成会损害性能，所以不建议在合成窗口管理器（compositing WM）工作时使用primus。参照 <a href="#Primus_issues_under_compositing_window_managers">#Primus issues under compositing window managers</a><sup>[<a href="../en/ArchWiki:Requests.html#Broken_section_links" class="mw-redirect" title="ArchWiki:Requests">断开的链接</a>：无效的部分]</sup>。</div>
<p><code>primusrun</code> (来自 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=primus">primus</a></span>) 正成为默认选项，因为其耗电量更低并且有时可以提供比 <code>optirun</code>/<code>virtualgl</code>更好的性能。它可以独立运行，但不能接受 <code>optirun</code> 的选项。将 <code>primus</code> 设置为 <code>optirun</code> 的桥接可提供更过的灵活性。
</p>
<p>对于64位系统上32位程序的支持，安装 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=lib32-primus">lib32-primus</a></span>（须启用<a href="../en/Official_repositories.html#multilib" class="mw-redirect" title="Multilib">multilib</a>）。
</p>
<p>用法（独立运行）：
</p>
<pre>$ primusrun glxgears
</pre>
<p><code>optirun</code> 的桥接：
</p>
<p>默认的配置将 <code>virtualgl</code> 作为桥接。在命令行上将其覆盖：
</p>
<pre>$ optirun -b primus glxgears
</pre>
<p>或者，在 <code>/etc/bumblebee/bumblebee.conf</code> 中设置 <code>Bridge=primus</code> 使其永久生效。
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>提示：</strong> 如果要禁用 <code>VSYNC</code> 请参考 <a href="#Primusrun_mouse_delay_(disable_VSYNC)">#Primusrun mouse delay (disable VSYNC)</a><sup>[<a href="../en/ArchWiki:Requests.html#Broken_section_links" class="mw-redirect" title="ArchWiki:Requests">断开的链接</a>：无效的部分]</sup>。这也可以取消鼠标延迟并轻微提高性能。</div>
<h3>
<span id=".E7.94.B5.E6.BA.90.E7.AE.A1.E7.90.86"></span><span class="mw-headline" id="电源管理">电源管理</span>
</h3>
<p>电源管理的目的是为了自动关闭 bumblebee 不再使用的 NVIDIA 显卡。
如果已安装 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=bbswitch">bbswitch</a></span> ，Bumblebee 守护进程启动时会自动检测到，不需要特别设置。
</p>
<h4>
<span id=".E4.BD.BF.E7.94.A8bbswitch.E6.97.B6.E9.BB.98.E8.AE.A4.E7.9A.84_NVIDIA_.E7.94.B5.E6.BA.90.E7.8A.B6.E6.80.81"></span><span class="mw-headline" id="使用bbswitch时默认的_NVIDIA_电源状态">使用bbswitch时默认的 NVIDIA 电源状态</span>
</h4>
<p>bbswitch的默认行为是保持显卡的电源状态。 <code>bumblebeed</code> 启动时并不禁用显卡，所以你没有bumblebeed时使用bbswitch需要以下内容。
</p>
<p>根据需要设置 <code>load_state</code> 和 <code>unload_state</code> 模块选项 (见 <a rel="nofollow" class="external text" href="https://github.com/Bumblebee-Project/bbswitch">bbswitch documentation</a>).
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/modprobe.d/bbswitch.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">options bbswitch load_state=0 unload_state=1</pre>
<h4>
<span id=".E5.85.B3.E6.9C.BA.E6.97.B6.E5.90.AF.E7.94.A8NVIDIA.E6.98.BE.E5.8D.A1"></span><span class="mw-headline" id="关机时启用NVIDIA显卡">关机时启用NVIDIA显卡</span>
</h4>
<p>如果上次关机时关闭了NVIDIA显卡的电源，NVIDIA显卡可能会在下一次启动时初始化异常。一个解决的办法是在 <code>/etc/bumblebee/bumblebee.conf</code> 里设置 <code>TurnCardOffAtExit=false</code>， 然而这么做会导致每次停止bumblebee守护进程时启用NVIDIA显卡，就算是手动停止也是一样。为确保NVIDIA显卡总是在关机时启用，添加如下 <a href="../en/Systemd.html" title="Systemd">systemd</a> 服务(如果使用 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=bbswitch">bbswitch</a></span> 的话):
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/systemd/system/nvidia-enable.service</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[Unit]
Description=Enable NVIDIA card
DefaultDependencies=no

[Service]
Type=oneshot
ExecStart=/bin/sh -c 'echo ON &gt; /proc/acpi/bbswitch'

[Install]
WantedBy=shutdown.target</pre>
<p>然后以root权限运行 <code>systemctl enable nvidia-enable.service</code> 以启用服务。
</p>
<h3>
<span id=".E5.A4.9A.E6.98.BE.E7.A4.BA.E5.99.A8"></span><span class="mw-headline" id="多显示器">多显示器</span>
</h3>
<h4>
<span id=".E6.98.BE.E7.A4.BA.E5.99.A8.E8.BF.9E.E6.8E.A5.E5.9C.A8_Intel_.E6.98.BE.E5.8D.A1.E4.B8.8A"></span><span class="mw-headline" id="显示器连接在_Intel_显卡上">显示器连接在 Intel 显卡上</span>
</h4>
<p>如果 (DisplayPort/HDMI/VGA) 接口连接到 Intel 显卡上，你可以通过 xorg.conf 设置多个显示器。设置他们使用 Intel 显卡，同时 Bumblebee 仍然可以使用 NVIDIA 显卡。下面的配置文件示例配置了两个不同的 1080p 的显示器，并且使用了 HDMI 输出。
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/X11/xorg.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Section "Screen"
    Identifier     "Screen0"
    Device         "intelgpu0"
    Monitor        "Monitor0"
    DefaultDepth    24
    Option         "TwinView" "0"
    SubSection "Display"
        Depth          24
        Modes          "1980x1080_60.00"
    EndSubSection
EndSection

Section "Screen"
    Identifier     "Screen1"
    Device         "intelgpu1"
    Monitor        "Monitor1"
    DefaultDepth   24
    Option         "TwinView" "0"
    SubSection "Display"
        Depth          24
        Modes          "1980x1080_60.00"
    EndSubSection
EndSection

Section "Monitor"
    Identifier     "Monitor0"
    Option         "Enable" "true"
EndSection

Section "Monitor"
    Identifier     "Monitor1"
    Option         "Enable" "true"
EndSection

Section "Device"
    Identifier     "intelgpu0"
    Driver         "intel"
    Option         "XvMC" "true"
    Option         "UseEvents" "true"
    Option         "AccelMethod" "UXA"
    BusID          "PCI:0:2:0"
EndSection

Section "Device"
    Identifier     "intelgpu1"
    Driver         "intel"
    Option         "XvMC" "true"
    Option         "UseEvents" "true"
    Option         "AccelMethod" "UXA"
    BusID          "PCI:0:2:0"
EndSection

Section "Device"
    Identifier "nvidiagpu1"
    Driver "nvidia"
    BusID "PCI:0:1:0"
EndSection</pre>
<p>你可能需要为Intel和NVIDIA显卡调整 BusID 字段的值:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$ lspci | grep VGA</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">00:02.0 VGA compatible controller: Intel Corporation 2nd Generation Core Processor Family Integrated Graphics Controller (rev 09)
</pre>
<p>BusID 值为 0:2:0
</p>
<h4>
<span id=".E6.98.BE.E7.A4.BA.E5.99.A8.E8.BF.9E.E6.8E.A5.E5.9C.A8_NVIDIA_.E6.98.BE.E5.8D.A1.E4.B8.8A"></span><span class="mw-headline" id="显示器连接在_NVIDIA_显卡上">显示器连接在 NVIDIA 显卡上</span>
</h4>
<p>在一些笔记本上，数字视频输出(HDMI 或 DisplayPort) 是硬线连接到NVIDIA芯片上的。如果你想同时使用所有的显示器，你需要开两个 X Server.第一个使用Intel驱动用于笔记本面板和连接到VGA上的显示，第二个由optirun启用NVIDIA显卡用于数字显示。
</p>
<p>目前网上有一些有关这个的设置教程。其中一个可在Bumblebee的 <a rel="nofollow" class="external text" href="https://github.com/Bumblebee-Project/Bumblebee/wiki/Multi-monitor-setup">wiki 页面</a>找到，另一个详见下文。
</p>
<h5>
<span id="xf86-video-intel-virtual-crtc_.E5.92.8C_hybrid-screenclone"></span><span class="mw-headline" id="xf86-video-intel-virtual-crtc_和_hybrid-screenclone">xf86-video-intel-virtual-crtc 和 hybrid-screenclone</span>
</h5>
<p>本方法使用了一个打了补丁来扩展为含有一个虚拟显示器的Intel驱动，而hybrid-screenclone程序用于把虚拟显示器的内容复制到通过optirun运行于NVIDIA显卡的第二个X Server上的显示器上。有幸发现 <a rel="nofollow" class="external text" href="http://judsonsnotes.com/notes/index.php?option=com_content&amp;view=article&amp;id=673:triple-head-monitors-on-thinkpad-t520&amp;catid=37:tech-notes&amp;Itemid=59">Triple-head monitors on a Thinkpad T520</a> <sup title="最后检查状态：domain name not resolved">[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">失效链接</a> 2020-08-02 ⓘ]</sup> 它是这一切在Ubuntu系统上如何完成的详细解说。
</p>
<p>精简起见，下文DP指代 Digital Output (DisplayPort).如果笔记本是HDMI接口的话教程也是一样。
</p>
<ul><li>设置系统为只使用 NVIDIA 显卡，测试 DP/显示器组合，并生成 xorg.nvidia.conf.这步并非必须但推荐在支持设置为nvidia-only的BIOS上执行。为此，首先卸载 bumblebee 包，并只安装 NVIDIA 驱动。然后重启，进入BIOS设置为NVIDIA-only.重启进入Arch时，把显示器连接到DP并使用 startx 来检测这一切是否正常工作。使用 Xorg -configure 来为你的NVIDIA显卡生成 xorg.conf 文件。这在向下进一步深入时会派上用场。</li></ul>
<ul>
<li>重新安装 bumlbebee 和 bbswitch,重启并在BIOS里设置系统 Gfx 值回到 Hybrid.</li>
<li>安装 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/xf86-video-intel-virtual-crtc/">xf86-video-intel-virtual-crtc</a></span><sup><small>AUR</small></sup><sup>[<a href="../en/Help:Procedures.html#Fix_broken_package_links" title="Help:Procedures">断开的链接</a>：package not found]</sup>,并以它替换掉 xf86-video-intel.</li>
<li>安装 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/screenclone-git/">screenclone-git</a></span><sup><small>AUR</small></sup><sup>[<a href="../en/Help:Procedures.html#Fix_broken_package_links" title="Help:Procedures">断开的链接</a>：package not found]</sup>
</li>
<li>改变以下 bumblebee.conf 设置:</li>
</ul>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/bumblebee/bumblebee.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">KeepUnusedXServer=true
Driver=nvidia</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 把 PMMethod 保留不变为 "bumblebee".这与上面链接里教程的做法相反，但在Arch里需这么做以使 bbswitch 模块自动加载。</div>
<ul>
<li>复制在第一步里生成的 xorg.conf 到 <code>/etc/X11</code> (例如 <code>/etc/X11/xorg.nvidia.conf</code>).在 <code>bumblebee.conf</code> 的[driver-nvidia]部分，修改 <code>XorgConfFile</code> 为它的路径。</li>
<li>测试你的 <code>/etc/X11/xorg.nvidia.conf</code> 是否有效 <code>startx -- -config /etc/X11/xorg.nvidia.conf</code>
</li>
<li>为了你的DP显示器在虚拟显示器上以正常分辨率出现，你需要编辑 <code>/etc/X11/xorg.nvidia.conf</code> 里的Monitor section.由于这是附加步骤，你仍需要测试你自动生成的 xorg.conf.当发现 xrandr 显示的虚拟显示器分辨率不对后，再回来参考教程里的这条步骤。
<ul><li>首先要生成 Modeline.你需要工具 <a rel="nofollow" class="external text" href="http://zi.fi/amlc/">amlc</a><sup title="最后检查状态：404">[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">失效链接</a> 2020-08-02 ⓘ]</sup>,它用于输入一些基本参数后自动生成 Modeline.</li></ul>
</li>
</ul>
<dl><dd><dl>
<dd>例子:  24" 1920x1080 Monitor</dd>
<dd>以 <code>amlc -c</code> 参数启动工具</dd>
</dl></dd></dl>
<pre>Monitor Identifier: Samsung 2494
Aspect Ratio: 2
physical size[cm]: 60
Ideal refresh rate, in Hz: 60
min HSync, kHz: 40
max HSync, kHz: 90
min VSync, Hz: 50
max VSync, Hz: 70
max pixel Clock, MHz: 400</pre>
<p>这就是 <code>amlc</code> 生成的 Monitor Section:
</p>
<pre>Section "Monitor"
    Identifier     "Samsung 2494"
    ModelName      "Generated by Another Modeline Calculator"
    HorizSync      40-90
    VertRefresh    50-70
    DisplaySize    532 299  # Aspect ratio 1.778:1
    # Custom modes
    Modeline "1920x1080" 174.83 1920 2056 2248 2536 1080 1081 1084 1149             # 174.83 MHz,  68.94 kHz,  60.00 Hz
EndSection  # Samsung 2494</pre>
<p>在 <code>xorg.nvidia.conf</code> 里加入这个 Monitor Section.你还可以编辑你的文件使其包含 ServerLayout, Monitor, Device 和 Screen 部分。以下是我的，仅供参考:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/X11/xorg.nvidia.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Section "ServerLayout"
        Identifier     "X.org Nvidia DP"
        Screen      0  "Screen0" 0 0
        InputDevice    "Mouse0" "CorePointer"
        InputDevice    "Keyboard0" "CoreKeyboard"
EndSection

Section "Monitor"
    Identifier     "Samsung 2494"
    ModelName      "Generated by Another Modeline Calculator"
    HorizSync      40-90
    VertRefresh    50-70
    DisplaySize    532 299  # Aspect ratio 1.778:1
    # Custom modes
    Modeline "1920x1080" 174.83 1920 2056 2248 2536 1080 1081 1084 1149             # 174.83 MHz,  68.94 kHz,  60.00 Hz
EndSection  # Samsung 2494

Section "Device"
        Identifier  "DiscreteNvidia"
        Driver      "nvidia"
        BusID       "PCI:1:0:0"
EndSection

Section "Screen"
        Identifier "Screen0"
        Device     "DiscreteNvidia"
        Monitor    "Samsung 2494"
        SubSection "Display"
                Viewport   0 0
                Depth     24
        EndSubSection
EndSection
</pre>
<ul>
<li>也要把额外显示器插上之后再 startx.查看 <code>/var/log/Xorg.0.log</code>.确保你的VGA显示器以正确的模式被检测出来。你也要看看虚拟输出出现的模式。</li>
<li>运行 <code>xrandr</code> 然后三个显示器以及它们支持的模式都会被列出来。</li>
<li>如果对于你的VIRTUAL显示器没有符合你原生分辨率的Modelines输出, 记下输出的名称。对我来说是 <code>VIRTUAL1</code>.然后再看看 Xorg.0.log 文件。你应该会看到一条消息: "Output VIRTUAL1 has no monitor section".我们需要在 <code>/etc/X11/xorg.conf.d</code> 里放入含有合适 Monitor Section 的文件，稍后退出并重启X.</li>
</ul>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/X11/xorg.conf.d/20-monitor_samsung.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Section "Monitor"
    Identifier     "VIRTUAL1"
    ModelName      "Generated by Another Modeline Calculator"
    HorizSync      40-90
    VertRefresh    50-70
    DisplaySize    532 299  # Aspect ratio 1.778:1
    # Custom modes
    Modeline "1920x1080" 174.83 1920 2056 2248 2536 1080 1081 1084 1149             # 174.83 MHz,  68.94 kHz,  60.00 Hz
EndSection  # Samsung 2494
</pre>
<ul>
<li>为开启NVIDIA显卡，运行: <code>sudo tee /proc/acpi/bbswitch &lt;&lt;&lt; ON</code>
</li>
<li>为 DisplayPort 显示器开启另一个X Server: <code>sudo optirun true</code>
</li>
<li>检查位于 <code>/var/log/Xorg.8.log</code> 的第二个 X Server 的日志。</li>
<li>运行 xrandr 以把 VIRTUAL 显示器设置成正确的大小和位置，例如: <code>xrandr --output VGA1 --auto --rotate normal --pos 0x0 --output VIRTUAL1 --mode 1920x1080 --right-of VGA1 --output LVDS1 --auto --rotate normal --right-of VIRTUAL1</code>
</li>
<li>请注意在 xrandr 输出列表中的 VIRTUAL 显示器的位置。计数从零开始，也就是说，如果它给出了第三个显示器，你会指定 <code>-x 2</code> 作为参数传递给 <code>screenclone</code>（注：这可能并不总是正确的。如果你看到内部的笔记本电脑显示屏克隆在监视器上，只管尝试 <code>-x 2</code>）。</li>
<li>克隆VIRTUAL显示器的内容到由Bumblebee创建的，经由NVIDIA的芯片连接到所述的DisplayPort显示器的X服务器:</li>
</ul>
<dl><dd><code>screenclone -d :8 -x 2</code></dd></dl>
<p>这就行了，三个显示器都应该配置好并正常工作。
</p>
<h2>
<span id=".E5.A6.82_Windows_.E4.B8.80.E8.88.AC.E5.9C.A8.E9.9B.86.E6.98.BE.E5.92.8C.E7.8B.AC.E6.98.BE.E9.97.B4.E5.88.87.E6.8D.A2"></span><span class="mw-headline" id="如_Windows_一般在集显和独显间切换">如 Windows 一般在集显和独显间切换</span>
</h2>
<p>在 Windows 里，Optimus 的工作方式是NVIDIA有一个请求 Optimus 的程序的白名单，并且你可以按需添加。当你启动程序时，会自动选择使用哪一张显卡。
</p>
<p>为了在Linux里模仿这一行为，你可以使用 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/libgl-switcheroo-git/">libgl-switcheroo-git</a></span><sup><small>AUR</small></sup><sup>[<a href="../en/Help:Procedures.html#Fix_broken_package_links" title="Help:Procedures">断开的链接</a>：package not found]</sup>.安装后，往 .xprofile 里添加:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">~/.xprofile</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">mkdir -p /tmp/libgl-switcheroo-$USER/fs
gtkglswitch &amp;
libgl-switcheroo /tmp/libgl-switcheroo-$USER/fs &amp;</pre>
<p>为此，你需要往你希望启动程序的shell里添加 (我一般就加到 .xprofile 里)
</p>
<pre>export LD_LIBRARY_PATH=/tmp/libgl-switcheroo-$USER/fs/\$LIB${LD_LIBRARY_PATH+:}$LD_LIBRARY_PATH
</pre>
<p>全部完成后，你从该shell运行的每一个程序都会弹出一个GTK+窗口询问该使用哪一张卡(你也可以往配置文件的白名单里添加程序)。配置文件位于 <code>$XDG_CONFIG_HOME/libgl-switcheroo.conf</code>, 通常是 <code>~/.config/libgl-switcheroo.conf</code>
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 此工具通过创建FUSE文件系统，然后将其添加到动态库搜索路径来生效，启动软件时，可能导致速度慢甚至段错误。</div>
<h2>
<span id=".E4.B8.8D.E4.BE.9D.E8.B5.96Bumblebee.E6.9D.A5.E4.BD.BF.E7.94.A8CUDA"></span><span class="mw-headline" id="不依赖Bumblebee来使用CUDA">不依赖Bumblebee来使用CUDA</span>
</h2>
<p>你可以不依赖Bumblebee来使用CUDA,只需确保你的NVIDIA显卡是开启的:
</p>
<pre> # tee /proc/acpi/bbswitch &lt;&lt;&lt; ON
</pre>
<p>现在你可以运行一个 CUDA 程序，它会自动加载所有需要的模块。
</p>
<p>使用完 CUDA 后为了停止NVIDIA显卡，运行:
</p>
<pre> # rmmod nvidia_uvm
 # rmmod nvidia
 # tee /proc/acpi/bbswitch &lt;&lt;&lt; OFF
</pre>
<h2>
<span id=".E7.96.91.E9.9A.BE.E9.97.AE.E9.A2.98"></span><span class="mw-headline" id="疑难问题">疑难问题</span>
</h2>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 报告 Bug 的位置在 <a rel="nofollow" class="external text" href="https://github.com/Bumblebee-Project/Bumblebee">Bumblebee-Project</a>，Bumblebee 的 <a rel="nofollow" class="external text" href="https://github.com/Bumblebee-Project/Bumblebee/wiki/Reporting-Issues">Wiki</a> 中描述。</div>
<h3>
<span id=".5BVGL.5D_ERROR:_Could_not_open_display_:8"></span><span class="mw-headline" id="[VGL]_ERROR:_Could_not_open_display_:8">[VGL] ERROR: Could not open display :8</span>
</h3>
<p>一个关于部分wine程序的已知问题是它会fork并杀死父进程而不是跟踪它的动态(例如免费网络游戏 "Runes of Magic")
</p>
<p>这是一个关于 VirtualGL 的已知问题。自从bumblebee 3.1,只要你安装了它就可以用 Primus 作为渲染桥接:
</p>
<pre>$ optirun -b primus wine <i>windows program</i>.exe
</pre>
<p>如果没用的话，一个替代方案如下:
</p>
<pre>$ optirun bash
$ optirun wine <i>windows program</i>.exe
</pre>
<p>如果使用NVIDIA驱动的话，一个该问题的解决方案是修改 <code>/etc/bumblebee/xorg.conf.nvidia</code> 把 Option <code>ConnectedMonitor</code> 改为 <code>CRT-0</code>.
</p>
<h3>
<span id="Xlib:_extension_.22GLX.22_missing_on_display_.22:0.0.22"></span><span class="mw-headline" id='Xlib:_extension_"GLX"_missing_on_display_":0.0"'>Xlib: extension "GLX" missing on display ":0.0"</span>
</h3>
<p>从官网下载安装的NVIDIA驱动不会工作。
</p>
<p>1. 卸载驱动：
</p>
<pre># ./NVIDIA-Linux-*.run --uninstall
</pre>
<p>2. 删除生成的配置文件：
</p>
<pre># rm /etc/X11/xorg.conf
</pre>
<p>3. 重新从源里安装： <a href="#%E5%AE%89%E8%A3%85">#安装</a>
</p>
<h3>
<span id=".5BERROR.5DCannot_access_secondary_GPU:_No_devices_detected"></span><span class="mw-headline" id="[ERROR]Cannot_access_secondary_GPU:_No_devices_detected">[ERROR]Cannot access secondary GPU: No devices detected</span>
</h3>
<p>某些情况下，运行 <code>optirun</code> 会返回:
</p>
<pre>[ERROR]Cannot access secondary GPU - error: [XORG] (EE) No devices detected.
[ERROR]Aborting because fallback start is disabled.
</pre>
<p>这种情况下，你需要把 <code>/etc/X11/xorg.conf.d/20-intel.conf</code> 移动到别的地方， <a href="../en/Systemd.html#Using_units" class="mw-redirect" title="Restart">restart</a> bumblebeed 守护进程，这样应该有效。如果你要改变一些 Intel 模块的特性，把 <code>/etc/X11/xorg.conf.d/20-intel.conf</code> 合并到 <code>/etc/X11/xorg.conf</code> 中。
</p>
<p>也需要把 <code>/etc/X11/xorg.conf.d/10-monitor.conf</code> 里的driver行注释掉。
</p>
<p>如果你正在用 <code>nouveau</code> 驱动你应该试着换成 <code>nvidia</code> 驱动。
</p>
<p>你需要把 NVIDIA 显卡定位到别的地方 (例如文件 <code>/etc/X11/xorg.conf.d</code>),使用根据 <code>lspci</code> 的输出确定的 <code>BusID</code>:
</p>
<pre>Section "Device"
    Identifier "nvidiagpu1"
    Driver "nvidia"
    BusID "PCI:0:1:0"
EndSection
</pre>
<h4>
<span id="NVIDIA.280.29:_Failed_to_assign_any_connected_display_devices_to_X_screen_0"></span><span class="mw-headline" id="NVIDIA(0):_Failed_to_assign_any_connected_display_devices_to_X_screen_0">NVIDIA(0): Failed to assign any connected display devices to X screen 0</span>
</h4>
<p>如果终端输出如下:
</p>
<pre>[ERROR]Cannot access secondary GPU - error: [XORG] (EE) NVIDIA(0): Failed to assign any connected display devices to X screen 0
[ERROR]Aborting because fallback start is disabled.
</pre>
<p>你要修改 <code>/etc/bumblebee/xorg.conf.nvidia</code> 里的这行:
</p>
<pre>Option "ConnectedMonitor" "DFP"
</pre>
<p>为:
</p>
<pre>Option "ConnectedMonitor" "CRT"
</pre>
<h4><span class="mw-headline" id="systemd-logind:_failed_to_get_session:_PID_XXX_does_not_belong_to_any_known_session">systemd-logind: failed to get session: PID XXX does not belong to any known session</span></h4>
<p>如果终端输出如下 (<i>PID</i>会有所不同):
</p>
<pre>[ERROR]Cannot access secondary GPU - error: [XORG] (EE) systemd-logind: failed to get session: PID 753 does not belong to any known session
[ERROR]Aborting because fallback start is disabled.
</pre>
<p>在 /etc/mkinitcpio.conf 里改变 MODULES 为:
</p>
<pre>MODULES="i915 bbswitch"
</pre>
<p>或:
</p>
<pre>MODULES="i915 nouveau bbswitch"
</pre>
<p>然后运行:
</p>
<pre># mkinitcpio -p linux
</pre>
<p>每次内核更新之后你都要执行一次这个命令。
</p>
<p>另外，<a href="#Failed_to_initialize_the_NVIDIA_GPU_at_PCI:1:0:0_.28GPU_fallen_off_the_bus_.2F_RmInitAdapter_failed.21.29">如下 </a>内核参数需要加到 <a href="../en/Arch_boot_process.html#Boot_loader" class="mw-redirect" title="Boot loader">boot loader</a>配置中。
</p>
<h4>
<span id="Failed_to_initialize_the_NVIDIA_GPU_at_PCI:1:0:0_.28GPU_fallen_off_the_bus_.2F_RmInitAdapter_failed.21.29"></span><span class="mw-headline" id="Failed_to_initialize_the_NVIDIA_GPU_at_PCI:1:0:0_(GPU_fallen_off_the_bus_/_RmInitAdapter_failed!)">Failed to initialize the NVIDIA GPU at PCI:1:0:0 (GPU fallen off the bus / RmInitAdapter failed!)</span>
</h4>
<p>把 <code>rcutree.rcu_idle_gp_delay=1</code> 加到<a href="../en/Arch_boot_process.html#Boot_loader" class="mw-redirect" title="Boot loader">boot loader</a> 配置的内核参数中。 (参考设置另见<a rel="nofollow" class="external text" href="https://bbs.archlinux.org/viewtopic.php?id=169742">BBS post</a> )
</p>
<h4><span class="mw-headline" id="Could_not_load_GPU_driver">Could not load GPU driver</span></h4>
<p>如果终端输出如下:
</p>
<pre>[ERROR]Cannot access secondary GPU - error: Could not load GPU driver
</pre>
<p>并且尝试加载 nvidia 模块时得到:
</p>
<pre>modprobe nvidia
modprobe: ERROR: could not insert 'nvidia': Exec format error
</pre>
<p>你需要针对你的内核手动编译 nvidia 包，例如 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=nvidia-dkms">nvidia-dkms</a></span> 或从 <a href="../en/Arch_Build_System.html" class="mw-redirect" title="ABS">ABS</a> <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=nvidia">nvidia</a></span> 编译。
</p>
<h4>
<span id="NOUVEAU.280.29:_.5Bdrm.5D_failed_to_set_drm_interface_version"></span><span class="mw-headline" id="NOUVEAU(0):_[drm]_failed_to_set_drm_interface_version">NOUVEAU(0): [drm] failed to set drm interface version</span>
</h4>
<p>考虑切换到 nvidia 官方驱动。在<a rel="nofollow" class="external text" href="https://github.com/Bumblebee-Project/Bumblebee/issues/438#issuecomment-22005923">此</a>的评论说 nouveau 驱动在某些显卡和bumblebee上有问题。
</p>
<h3>
<span id=".5BERROR.5DCannot_access_secondary_GPU_-_error:_X_did_not_start_properly"></span><span class="mw-headline" id="[ERROR]Cannot_access_secondary_GPU_-_error:_X_did_not_start_properly">[ERROR]Cannot access secondary GPU - error: X did not start properly</span>
</h3>
<p>在 <code>/etc/bumblebee/xorg.conf.nvidia</code> 把 <code>"AutoAddDevices"</code> 设置为 <code>"true"</code>（看 <a rel="nofollow" class="external text" href="https://github.com/Bumblebee-Project/Bumblebee/issues/88">这里</a>）：
</p>
<pre>Section "ServerLayout"
    Identifier  "Layout0"
    Option      "AutoAddDevices" "true"
    Option      "AutoAddGPU" "false"
EndSection
</pre>
<h3>
<span id=".2Fdev.2Fdri.2Fcard0:_failed_to_set_DRM_interface_version_1.4:_Permission_denied"></span><span class="mw-headline" id="/dev/dri/card0:_failed_to_set_DRM_interface_version_1.4:_Permission_denied">/dev/dri/card0: failed to set DRM interface version 1.4: Permission denied</span>
</h3>
<p>这可以通过在 <code>/etc/bumblebee/xorg.conf.nvidia</code> 里添加几行解决(见 <a rel="nofollow" class="external text" href="https://github.com/Bumblebee-Project/Bumblebee/issues/580">这里</a>):
</p>
<pre>Section "Screen"
    Identifier "Default Screen"
    Device "DiscreteNvidia"
EndSection
</pre>
<h3>
<span id="ERROR:_ld.so:_object_.27libdlfaker.so.27_from_LD_PRELOAD_cannot_be_preloaded:_ignored"></span><span class="mw-headline" id="ERROR:_ld.so:_object_'libdlfaker.so'_from_LD_PRELOAD_cannot_be_preloaded:_ignored">ERROR: ld.so: object 'libdlfaker.so' from LD_PRELOAD cannot be preloaded: ignored</span>
</h3>
<p>你也许是想在64位系统上用bumblebee运行32位程序。见 "Note" box <a href="#Installation">Installation</a><sup>[<a href="../en/ArchWiki:Requests.html#Broken_section_links" class="mw-redirect" title="ArchWiki:Requests">断开的链接</a>：无效的部分]</sup>.
</p>
<h3>
<span id="Fatal_IO_error_11_.28Resource_temporarily_unavailable.29_on_X_server"></span><span class="mw-headline" id="Fatal_IO_error_11_(Resource_temporarily_unavailable)_on_X_server">Fatal IO error 11 (Resource temporarily unavailable) on X server</span>
</h3>
<p>把 <code>/etc/bumblebee/bumblebee.conf</code> 里的 <code>KeepUnusedXServer</code> 从 <code>false</code> 改为 <code>true</code>.这是因为你的程序fork到了后台并且 bumblebee 对此一无所知。
</p>
<h3>
<span id=".E8.A7.86.E9.A2.91.E6.92.95.E8.A3.82"></span><span class="mw-headline" id="视频撕裂">视频撕裂</span>
</h3>
<p>视频撕裂是 Bumblebee 上一个常见的问题，要修复这个问题，你需要启用 vsync。默认情况下，Intel 显卡已启用此设置，但是还是检查一下 Xorg 的日志，要检查 nvidia 是否启用了此设置，运行: 
</p>
<pre>$ optirun nvidia-settings -c :8
</pre>
<p><code>X Server XVideo Settings -&gt; Sync to VBlank</code> 以及 <code>OpenGL Settings -&gt; Sync to VBlank</code> 应该都是已经启用状态。 Intel 显卡通常有比较少的撕裂，所以应该作为视频回放设备。特别是使用 VA-API 编码视频的时候（比如：<code>mplayer-vaapi</code> 以及 <code>-vsync</code> 参数）。
</p>
<p>参考<a href="../zh-CN/Intel_graphics.html#%E9%81%BF%E5%85%8D%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%E6%97%B6%E5%B1%8F%E5%B9%95%E6%92%95%E8%A3%82" title="Intel graphics (简体中文)">Intel</a>了解如何修复 Intel 显卡的视频撕裂。
</p>
<p>如果仍然无效，尝试从桌面环境禁用 compositing。同时可尝试禁用 triple buffering.
</p>
<h3><span class="mw-headline" id="Bumblebee_cannot_connect_to_socket">Bumblebee cannot connect to socket</span></h3>
<p>你可能会得到这样的输出:
</p>
<pre>$ optirun glxspheres64
</pre>
<p>或 (32位):
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$ optirun glxspheres32</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[ 1648.179533] [ERROR]You've no permission to communicate with the Bumblebee daemon. Try adding yourself to the 'bumblebee' group
[ 1648.179628] [ERROR]Could not connect to bumblebee daemon - is it running?
</pre>
<p>如果你已在 <code>bumblebee</code> 群组中 (<code>$ groups | grep bumblebee</code>),尝试 <a rel="nofollow" class="external text" href="https://bbs.archlinux.org/viewtopic.php?pid=1178729#p1178729">removing the socket</a> <code>/var/run/bumblebeed.socket</code>.
</p>
<h3>
<span id="Running_X.org_from_console_after_login_.28rootless_X.org.29"></span><span class="mw-headline" id="Running_X.org_from_console_after_login_(rootless_X.org)">Running X.org from console after login (rootless X.org)</span>
</h3>
<p>见 <a href="../en/Xorg.html#Rootless_Xorg_(v1.16)" title="Xorg">Xorg#Rootless Xorg (v1.16)</a><sup>[<a href="../en/ArchWiki:Requests.html#Broken_section_links" class="mw-redirect" title="ArchWiki:Requests">断开的链接</a>：无效的部分]</sup>.
</p>
<h3>
<span id="Primusrun_.E9.BC.A0.E6.A0.87.E5.BB.B6.E8.BF.9F.2F.E7.A6.81.E7.94.A8_VSYNC"></span><span class="mw-headline" id="Primusrun_鼠标延迟/禁用_VSYNC">Primusrun 鼠标延迟/禁用 VSYNC</span>
</h3>
<p>对于 <code>primusrun</code>, <code>VSYNC</code> 默认启用，因此会导致鼠标输入延迟甚至轻微降低性能。不用 <code>VSYNC</code> 来测试 <code>primusrun</code>:
</p>
<pre>$ vblank_mode=0 primusrun glxgears
</pre>
<p>如果你想使用它替代 <code>primusrun</code>,新建文件:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/usr/bin/optiprime</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">#!/bin/sh
vblank_mode=0 primusrun "$@"
</pre>
<p>让它可执行:
</p>
<pre># chmod +x /usr/bin/optiprime
</pre>
<p>用法:
</p>
<pre>$ optiprime glxgears
</pre>
<p>总之它不会有重大性能提升，但会解决上述的鼠标延迟。
</p>
<table class="wikitable">
<tbody>
<tr>
<th>Command</th>
<th>FPS</th>
<th>Score</th>
<th>Min FPS</th>
<th>Max FPS
</th>
</tr>
<tr>
<td>optiprime unigine-heaven</td>
<td>31.5</td>
<td>793</td>
<td>22.3</td>
<td>54.8
</td>
</tr>
<tr>
<td>primusrun unigine-heaven</td>
<td>31.4</td>
<td>792</td>
<td>18.7</td>
<td>54.2
</td>
</tr>
</tbody>
</table>
<p><i>Tested with <a href="../en/ASUS_N550JV.html" title="ASUS N550JV">Asus N550JV</a> laptop and benchmark app <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/unigine-heaven/">unigine-heaven</a></span><sup><small>AUR</small></sup>.</i>
</p>
<h2>
<span id=".E5.8F.A6.E8.A7.81"></span><span class="mw-headline" id="另见">另见</span>
</h2>
<ul>
<li><a rel="nofollow" class="external text" href="http://www.bumblebee-project.org">Bumblebee project repository</a></li>
<li><a rel="nofollow" class="external text" href="http://wiki.bumblebee-project.org/">Bumblebee project wiki</a></li>
<li><a rel="nofollow" class="external text" href="https://github.com/Bumblebee-Project/bbswitch">Bumblebee project bbswitch repository</a></li>
</ul>
<p>Join us at #bumblebee at freenode.net.
</p>
</div>
</div>
<div id="catlinks" class="catlinks" data-mw="interface">
<div id="mw-normal-catlinks" class="mw-normal-catlinks">
<a href="../Special:Categories.html" title="Special:Categories">Categories</a>: <ul>
<li><a href="../zh-CN/Category:Graphics.html" title="Category:Graphics (简体中文)">Graphics (简体中文)</a></li>
<li><a href="../zh-CN/Category:X_server.html" title="Category:X server (简体中文)">X server (简体中文)</a></li>
</ul>
</div>
<div id="mw-hidden-catlinks" class="mw-hidden-catlinks mw-hidden-cats-hidden">Hidden categories: <ul>
<li><a href="../en/Category:Pages_with_broken_section_links.html" title="Category:Pages with broken section links">Pages with broken section links</a></li>
<li><a href="../en/Category:Pages_with_dead_links.html" title="Category:Pages with dead links">Pages with dead links</a></li>
<li><a href="../en/Category:Pages_with_broken_package_links.html" title="Category:Pages with broken package links">Pages with broken package links</a></li>
</ul>
</div>
</div>
	</div>
</div>

<footer id="footer" class="mw-footer" role="contentinfo" style="margin: 0">
	<ul id="footer-info">
		<li>Retrieved from "<a dir="ltr" href="https://wiki.archlinux.org/index.php?title=Bumblebee_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)&amp;oldid=628385">https://wiki.archlinux.org/index.php?title=Bumblebee_(简体中文)&amp;oldid=628385</a>"</li>
		<li id="footer-info-lastmod"> This page was last edited on 2 August 2020, at 11:47.</li>
		<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3 or later</a> unless otherwise noted.</li>
	<br>
</ul>
	<ul id="footer-places">
		<li id="footer-places-privacy"><a href="../en/ArchWiki:Privacy_policy.html" title="ArchWiki:Privacy policy">Privacy policy</a></li>
		<li id="footer-places-about"><a href="../en/ArchWiki:About.html" title="ArchWiki:About">About ArchWiki</a></li>
		<li id="footer-places-disclaimer"><a href="../en/ArchWiki:General_disclaimer.html" title="ArchWiki:General disclaimer">Disclaimers</a></li>
	</ul>
	<ul id="footer-icons" class="noprint">
		<li id="footer-copyrightico">
	</ul>
	<div style="clear: both;"></div>
</footer>



</body>
</html>
