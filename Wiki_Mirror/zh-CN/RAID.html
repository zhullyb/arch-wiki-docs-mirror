<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<title>RAID (简体中文) - ArchWiki</title>
<link rel="stylesheet" href="../ArchWikiOffline.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<meta name="generator" content="MediaWiki 1.35.0">
<meta name="robots" content="noindex,follow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="/opensearch_desc.php" title="ArchWiki (en)">
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.archlinux.org/api.php?action=rsd">
<link rel="license" href="http://www.gnu.org/copyleft/fdl.html">
<link rel="alternate" type="application/atom+xml" title="ArchWiki Atom feed" href="/index.php?title=Special:RecentChanges&amp;feed=atom">
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-RAID_简体中文 rootpage-RAID_简体中文 skin-vector action-view skin-vector-legacy">
<div id="content" class="mw-body" role="main" style="margin: 0">
	<a id="top"></a>
	<div id="siteNotice" class="mw-body-content"></div>
	<div class="mw-indicators mw-body-content">
	</div>
	<h1 id="firstHeading" class="firstHeading" lang="en">RAID (简体中文)</h1>
	<div id="bodyContent" class="mw-body-content">
		<div id="siteSub" class="noprint">From ArchWiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="#searchInput">Jump to search</a>
		<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<div class="warningbox">The printable version is no longer supported and may have rendering errors. Please update your browser bookmarks and please use the default browser print function instead.</div>
<div class="mw-parser-output">
<div class="archwiki-template-meta-related-articles-start">
<p>相关文章</p>
<ul>
<li><a href="../en/LVM_on_software_RAID.html" class="mw-redirect" title="Software RAID and LVM">Software RAID and LVM</a></li>
<li><a href="../en/LVM.html#RAID" title="LVM">LVM#RAID</a></li>
<li><a href="../en/Install_Arch_Linux_with_Fake_RAID.html" class="mw-redirect" title="Installing with Fake RAID">Installing with Fake RAID</a></li>
<li><a href="../en/Convert_a_single_drive_system_to_RAID.html" title="Convert a single drive system to RAID">Convert a single drive system to RAID</a></li>
<li><a href="../en/ZFS.html" title="ZFS">ZFS</a></li>
<li><a href="../en/ZFS/Virtual_disks.html" title="ZFS/Virtual disks">ZFS/Virtual disks</a></li>
<li><a href="../en/Swap.html#Striping" title="Swap">Swap#Striping</a></li>
<li><a href="../zh-CN/Btrfs.html#RAID" title="Btrfs (简体中文)">Btrfs (简体中文)#RAID</a></li>
</ul>
</div>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>翻译状态：</strong>本文是 <a href="../en/RAID.html" title="RAID">RAID</a> 的<a href="../zh-CN/ArchWiki:Translation_Team.html" title="ArchWiki:Translation Team (简体中文)">翻译</a>。上次翻译日期：2018-09-01。如果英文版本有所<a rel="nofollow" class="external text" href="https://wiki.archlinux.org/index.php?title=RAID&amp;diff=0&amp;oldid=539084">更改</a>，则您可以帮助同步翻译。</div>
<div class="noprint archwiki-template-message">
<p><a href="../File:Tango-edit-clear.png" class="image"><img alt="Tango-edit-clear.png" src="../File:Tango-edit-clear.png" decoding="async" width="48" height="48"></a><b>This article or section needs language, wiki syntax or style improvements. See <a href="../en/Help:Style.html" title="Help:Style">Help:Style</a> for reference.</b><a href="../File:Tango-edit-clear.png" class="image"><img alt="Tango-edit-clear.png" src="../File:Tango-edit-clear.png" decoding="async" width="48" height="48"></a></p>
<div>
<b>Reason:</b> Non-standard headers, other <a href="../en/Help:Style.html" title="Help:Style">Help:Style</a> issues (Discuss in <a rel="nofollow" class="external text" href="https://wiki.archlinux.org/index.php/Talk:RAID_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Talk:RAID (简体中文)#</a>)</div>
</div>
<p>独立磁盘冗余阵列 (Redundant Array of Independent Disks, <a href="https://en.wikipedia.org/wiki/RAID" class="extiw" title="wikipedia:RAID">RAID</a>) 是一种将多个磁盘驱动器组件（通常是多块硬盘或多个分区）组合为一个逻辑单元的存储技术。根据 RAID 的部署情况，这个逻辑单元可以是单个的文件系统，也可以是一个能在其上建立多个分区的透明中间层。根据所需的冗余量和性能要求，数据按照 <a href="#RAID_%E7%BA%A7%E5%88%AB">#RAID 级别</a> 中的某一种方式分布在驱动器中。所选的 RAID 级别决定了是否可以防止数据丢失（硬盘故障时）、是否提高性能或结合两者优势。
</p>
<p>本文介绍如何使用 mdadm 创建并管理一个软件磁盘阵列。
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>警告：</strong> 确保在操作前 <a href="../en/Synchronization_and_backup_programs.html" class="mw-redirect" title="Backup programs">备份</a> 所有数据。</div>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading">
<input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none"><div class="toctitle" lang="en" dir="ltr">
<h2 id="mw-toc-heading">Contents</h2>
<span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span>
</div>
<ul>
<li class="toclevel-1 tocsection-1">
<a href="#RAID_%E7%BA%A7%E5%88%AB"><span class="tocnumber">1</span> <span class="toctext">RAID 级别</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#%E5%9F%BA%E6%9C%AC_RAID_%E7%BA%A7%E5%88%AB"><span class="tocnumber">1.1</span> <span class="toctext">基本 RAID 级别</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#%E5%B5%8C%E5%A5%97_RAID_%E7%BA%A7%E5%88%AB"><span class="tocnumber">1.2</span> <span class="toctext">嵌套 RAID 级别</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#RAID_%E7%BA%A7%E5%88%AB%E5%AF%B9%E6%AF%94"><span class="tocnumber">1.3</span> <span class="toctext">RAID 级别对比</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-5">
<a href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="tocnumber">2</span> <span class="toctext">实现方式</span></a>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#%E6%88%91%E6%AD%A3%E5%9C%A8%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%80%E7%A7%8D_RAID%EF%BC%9F"><span class="tocnumber">2.1</span> <span class="toctext">我正在使用哪一种 RAID？</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-7">
<a href="#%E5%AE%89%E8%A3%85"><span class="tocnumber">3</span> <span class="toctext">安装</span></a>
<ul>
<li class="toclevel-2 tocsection-8"><a href="#%E5%87%86%E5%A4%87%E8%AE%BE%E5%A4%87"><span class="tocnumber">3.1</span> <span class="toctext">准备设备</span></a></li>
<li class="toclevel-2 tocsection-9">
<a href="#%E5%AF%B9%E7%A3%81%E7%9B%98%E8%BF%9B%E8%A1%8C%E5%88%86%E5%8C%BA"><span class="tocnumber">3.2</span> <span class="toctext">对磁盘进行分区</span></a>
<ul>
<li class="toclevel-3 tocsection-10"><a href="#GUID_%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="tocnumber">3.2.1</span> <span class="toctext">GUID 分区表</span></a></li>
<li class="toclevel-3 tocsection-11"><a href="#%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95_(MBR)"><span class="tocnumber">3.2.2</span> <span class="toctext">主引导记录 (MBR)</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-12"><a href="#%E5%88%9B%E5%BB%BA%E9%98%B5%E5%88%97"><span class="tocnumber">3.3</span> <span class="toctext">创建阵列</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#%E6%9B%B4%E6%96%B0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="tocnumber">3.4</span> <span class="toctext">更新配置文件</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="#%E7%BB%84%E5%90%88%E6%88%90%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97"><span class="tocnumber">3.5</span> <span class="toctext">组合成磁盘阵列</span></a></li>
<li class="toclevel-2 tocsection-15">
<a href="#%E6%A0%BC%E5%BC%8F%E5%8C%96_RAID_%E4%B8%8A%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="tocnumber">3.6</span> <span class="toctext">格式化 RAID 上的文件系统</span></a>
<ul>
<li class="toclevel-3 tocsection-16">
<a href="#%E8%AE%A1%E7%AE%97_stride%EF%BC%88%E8%B7%A8%E5%BA%A6%E5%A4%A7%E5%B0%8F%EF%BC%89%E5%92%8C_stripe_width%EF%BC%88%E5%B8%A6%E5%8C%BA%E5%AE%BD%E5%BA%A6%EF%BC%89"><span class="tocnumber">3.6.1</span> <span class="toctext">计算 stride（跨度大小）和 stripe width（带区宽度）</span></a>
<ul>
<li class="toclevel-4 tocsection-17"><a href="#%E8%8C%83%E4%BE%8B_1._RAID0"><span class="tocnumber">3.6.1.1</span> <span class="toctext">范例 1. RAID0</span></a></li>
<li class="toclevel-4 tocsection-18"><a href="#%E8%8C%83%E4%BE%8B_2._RAID5"><span class="tocnumber">3.6.1.2</span> <span class="toctext">范例 2. RAID5</span></a></li>
<li class="toclevel-4 tocsection-19"><a href="#%E8%8C%83%E4%BE%8B_3._RAID10,far2"><span class="tocnumber">3.6.1.3</span> <span class="toctext">范例 3. RAID10,far2</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-20"><a href="#%E5%9C%A8_Live_CD_%E4%B8%AD%E6%8C%82%E8%BD%BD_RAID"><span class="tocnumber">4</span> <span class="toctext">在 Live CD 中挂载 RAID</span></a></li>
<li class="toclevel-1 tocsection-21">
<a href="#%E5%9C%A8_RAID_%E4%B8%8A%E5%AE%89%E8%A3%85_Arch_Linux"><span class="tocnumber">5</span> <span class="toctext">在 RAID 上安装 Arch Linux</span></a>
<ul>
<li class="toclevel-2 tocsection-22"><a href="#%E6%9B%B4%E6%96%B0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6_2"><span class="tocnumber">5.1</span> <span class="toctext">更新配置文件</span></a></li>
<li class="toclevel-2 tocsection-23"><a href="#%E9%85%8D%E7%BD%AE_mkinitcpio"><span class="tocnumber">5.2</span> <span class="toctext">配置 mkinitcpio</span></a></li>
<li class="toclevel-2 tocsection-24"><a href="#%E9%85%8D%E7%BD%AE_boot_loader"><span class="tocnumber">5.3</span> <span class="toctext">配置 boot loader</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-25">
<a href="#%E7%BB%B4%E6%8A%A4_RAID"><span class="tocnumber">6</span> <span class="toctext">维护 RAID</span></a>
<ul>
<li class="toclevel-2 tocsection-26">
<a href="#%E6%95%B0%E6%8D%AE%E6%B8%85%E6%89%AB_(Scrubbing)"><span class="tocnumber">6.1</span> <span class="toctext">数据清扫 (Scrubbing)</span></a>
<ul>
<li class="toclevel-3 tocsection-27"><a href="#%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%B8%85%E6%89%AB%E7%9A%84%E4%B8%80%E8%88%AC%E8%AF%B4%E6%98%8E"><span class="tocnumber">6.1.1</span> <span class="toctext">关于数据清扫的一般说明</span></a></li>
<li class="toclevel-3 tocsection-28"><a href="#%E5%AF%B9%E6%B8%85%E6%89%AB_RAID1_%E5%92%8C_RAID10_%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="tocnumber">6.1.2</span> <span class="toctext">对清扫 RAID1 和 RAID10 的说明</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-29"><a href="#%E4%BB%8E%E9%98%B5%E5%88%97%E4%B8%AD%E7%A7%BB%E9%99%A4%E8%AE%BE%E5%A4%87"><span class="tocnumber">6.2</span> <span class="toctext">从阵列中移除设备</span></a></li>
<li class="toclevel-2 tocsection-30"><a href="#%E5%90%91%E9%98%B5%E5%88%97%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%AE%BE%E5%A4%87"><span class="tocnumber">6.3</span> <span class="toctext">向阵列中添加设备</span></a></li>
<li class="toclevel-2 tocsection-31"><a href="#%E5%A2%9E%E5%A4%A7_RAID_%E5%8D%B7%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="tocnumber">6.4</span> <span class="toctext">增大 RAID 卷的大小</span></a></li>
<li class="toclevel-2 tocsection-32"><a href="#%E4%BF%AE%E6%94%B9%E5%90%8C%E6%AD%A5%E9%80%9F%E5%BA%A6%E9%99%90%E5%88%B6"><span class="tocnumber">6.5</span> <span class="toctext">修改同步速度限制</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-33">
<a href="#%E7%9B%91%E8%A7%86%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5"><span class="tocnumber">7</span> <span class="toctext">监视运行情况</span></a>
<ul>
<li class="toclevel-2 tocsection-34"><a href="#%E7%94%A8_watch_%E7%9B%91%E8%A7%86_mdstat"><span class="tocnumber">7.1</span> <span class="toctext">用 watch 监视 mdstat</span></a></li>
<li class="toclevel-2 tocsection-35"><a href="#%E7%94%A8_iotop_%E8%BF%BD%E8%B8%AA_IO"><span class="tocnumber">7.2</span> <span class="toctext">用 iotop 追踪 IO</span></a></li>
<li class="toclevel-2 tocsection-36"><a href="#%E7%94%A8_iostat_%E8%BF%BD%E8%B8%AA_IO"><span class="tocnumber">7.3</span> <span class="toctext">用 iostat 追踪 IO</span></a></li>
<li class="toclevel-2 tocsection-37">
<a href="#%E5%90%AF%E7%94%A8%E4%BA%8B%E4%BB%B6%E9%82%AE%E4%BB%B6%E9%80%9A%E7%9F%A5"><span class="tocnumber">7.4</span> <span class="toctext">启用事件邮件通知</span></a>
<ul>
<li class="toclevel-3 tocsection-38"><a href="#%E5%85%B6%E4%BB%96%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="tocnumber">7.4.1</span> <span class="toctext">其他实现方式</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-39">
<a href="#%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4"><span class="tocnumber">8</span> <span class="toctext">故障排除</span></a>
<ul>
<li class="toclevel-2 tocsection-40"><a href="#Error:_%22kernel:_ataX.00:_revalidation_failed%22"><span class="tocnumber">8.1</span> <span class="toctext">Error: "kernel: ataX.00: revalidation failed"</span></a></li>
<li class="toclevel-2 tocsection-41"><a href="#%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E4%BB%A5%E5%8F%AA%E8%AF%BB%E6%A8%A1%E5%BC%8F%E5%90%AF%E5%8A%A8"><span class="tocnumber">8.2</span> <span class="toctext">磁盘阵列以只读模式启动</span></a></li>
<li class="toclevel-2 tocsection-42"><a href="#%E5%9C%A8%E6%8D%9F%E5%9D%8F%E6%88%96%E7%BC%BA%E5%A4%B1%E7%A3%81%E7%9B%98%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%81%A2%E5%A4%8D_RAID"><span class="tocnumber">8.3</span> <span class="toctext">在损坏或缺失磁盘的情况下恢复 RAID</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-43"><a href="#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95"><span class="tocnumber">9</span> <span class="toctext">基准测试</span></a></li>
<li class="toclevel-1 tocsection-44"><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="tocnumber">10</span> <span class="toctext">参考资料</span></a></li>
</ul>
</div>

<h2>
<span id="RAID_.E7.BA.A7.E5.88.AB"></span><span class="mw-headline" id="RAID_级别">RAID 级别</span>
</h2>
<p>尽管大部分 RAID 级别都或多或少地包含了数据冗余，RAID 并不能完全保证数据安全。如果遇到火灾、计算机被盗或者多块硬盘同时损坏，RAID 将无法保护数据。此外，配置一个带有 RAID 的系统是一个复杂的过程，可能会破坏现有数据。
</p>
<h3>
<span id=".E5.9F.BA.E6.9C.AC_RAID_.E7.BA.A7.E5.88.AB"></span><span class="mw-headline" id="基本_RAID_级别">基本 RAID 级别</span>
</h3>
<p>有多种不同的 <a href="https://en.wikipedia.org/wiki/Standard_RAID_levels" class="extiw" title="wikipedia:Standard RAID levels">基本 RAID 级别</a>，下面列出了最常用的几种。
</p>
<dl>
<dt><a href="https://en.wikipedia.org/wiki/Standard_RAID_levels#RAID_0" class="extiw" title="wikipedia:Standard RAID levels">RAID 0</a></dt>
<dd>将多块硬盘组合为一个带区卷，尽管它 <i>并不提供数据冗余</i>，它仍可以被当做是 RAID，而且它确实提供了 <i>巨幅的速度提升</i>。如果提高速度比数据安全更重要（比如作为 <a href="../en/Swap.html" title="Swap">swap</a> 分区），可以选择这种 RAID 级别。在服务器上，RAID 1 和 RAID 5 阵列更加合适。在 RAID 0 阵列中，块设备的大小是最小组成分区的大小乘以组成分区的数量。</dd>
</dl>
<dl>
<dt><a href="https://en.wikipedia.org/wiki/Standard_RAID_levels#RAID_1" class="extiw" title="wikipedia:Standard RAID levels">RAID 1</a></dt>
<dd>这是最直接的 RAID 级别：完全镜像。与其他 RAID 级别一样，它只在分区位于不同物理硬盘上才有效。如果某一块硬盘损坏，由 RAID 阵列提供的块设备将不受影响。可以使用 RAID 1 的情境包括了除 <a href="../en/Swap.html" title="Swap">swap</a> 和临时文件外的其他所有情境。请注意，如果使用由软件实现的 RAID，引导分区只能选择 RAID 1，因为读取引导分区的引导器通常无法辨识 RAID，但一个 RAID 1 的组成分区可以像常规分区一样读取。RAID 1 阵列块设备的大小是最小组成分区的大小。</dd>
</dl>
<dl>
<dt><a href="https://en.wikipedia.org/wiki/Standard_RAID_levels#RAID_5" class="extiw" title="wikipedia:Standard RAID levels">RAID 5</a></dt>
<dd>需要至少 3 块物理硬盘，并结合了 RAID 1 的数据冗余和 RAID 0 的速度与可用空间上的优势。RAID 5 使用了类似 RAID 0 的条带化技术，同时也将奇偶校验块<i>分布式地存储在每一块磁盘上</i>。如果遭遇硬盘损坏，这些奇偶校验块就可以用来在替代的新磁盘上重建损坏的数据。RAID 5 仅可弥补一个组成磁盘损坏带来的损失。</dd>
<dd><div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> RAID 5 是结合了速度与数据冗余优势的常用选择。但值得注意的是，当一块硬盘损坏而没有及时更换，此时若再有硬盘损坏，则所有数据都将丢失。此外，考虑到现代磁盘的超大容量和消费级硬盘无法恢复的读取错误率 (Unrecoverable read error, URE)，超过 4TiB 的阵列在重建数据时出现至少一处读取错误 (URE) 的概率几乎在<b>预料之中</b>（概率大于 50%）。因此，存储行业不再推荐使用 RAID 5。</div></dd>
</dl>
<dl>
<dt><a href="https://en.wikipedia.org/wiki/Standard_RAID_levels#RAID_6" class="extiw" title="wikipedia:Standard RAID levels">RAID 6</a></dt>
<dd>需要至少 4 块物理硬盘，提供了和 RAID 5 一样的优势并且在两块硬盘损坏时仍能保证数据安全。RAID 6 使用了和 RAID 5 类似的条带化技术，但是把两个不同的奇偶校验块 <i>分布式地存储在每一块磁盘上</i>。如果磁盘发生故障，这些奇偶校验块将用于重建替换磁盘上的数据。RAID 6 可以承担两个组成磁盘的损失。在抵御无法恢复的读取错误 (Unrecoverable read error, URE) 时也某种程度上更加可靠，因为磁盘阵列在重建某一块损坏硬盘的数据时仍然有奇偶校验块可以校验数据。但是，总体而言，RAID 6 开销较大，大多数时候 far2 布局的 RAID 10（参见下文）提供了更快的速度和更强的可靠性，因此更倾向于采用 RAID 10。</dd>
</dl>
<h3>
<span id=".E5.B5.8C.E5.A5.97_RAID_.E7.BA.A7.E5.88.AB"></span><span class="mw-headline" id="嵌套_RAID_级别">嵌套 RAID 级别</span>
</h3>
<dl>
<dt><a href="https://en.wikipedia.org/wiki/Nested_RAID_levels#RAID_10_.28RAID_1.2B0.29" class="extiw" title="wikipedia:Nested RAID levels">RAID 1+0</a></dt>
<dd>RAID1+0 是一种结合了两种基本 RAID 级别的嵌套级别，它相对基本级别提高了性能且增加了冗余量。它通常被称为 <i>RAID10</i>，但是，Linux MD（内核自带的 RAID 实现）支持的 RAID10 不是简单的两层 RAID 重叠，请看下文。</dd>
</dl>
<dl>
<dt><a href="https://en.wikipedia.org/wiki/Non-standard_RAID_levels#Linux_MD_RAID_10" class="extiw" title="wikipedia:Non-standard RAID levels">RAID 10</a></dt>
<dd>Linux 下的 RAID10 建立在 RAID1+0 的概念上，但它将其实现为单一的一层，这一层可以有多种不同的布局。可参考 <a rel="nofollow" class="external text" href="https://www.suse.com/zh-cn/documentation/sles11/stor_admin/data/raidmdadmr10cpx.html">创建复杂 RAID 10</a>。</dd>
<dd>在 Y 块硬盘上的 <i>近 X 布局</i> 在不同硬盘上重复储存每个数据块 X 次，但不需要 Y 可以被 X 整除。数据块放在所镜像的磁盘上几乎相同的位置，这就是 <i>近布局</i> 名字的来源。它可以工作在任意数量的磁盘上，最少是 2 块。在 2 块硬盘上的近 2 布局相当于 RAID1，4 块硬盘上的近 2 布局相当于 RAID1+0。</dd>
<dd>在 Y 块硬盘上的 <i>远 X 布局</i> 设计用于在镜像阵列中提供与条带化技术一样快的读取速度。它通过把每块硬盘分成前后两部分来实现这一点，写入第一块硬盘前半部分数据也会写入第二块硬盘的后半部分，反之亦然。这样可以达到一个效果，那就是把对连续数据的读取条带化，而这正是 RAID0 和 RAID5 读取性能高的原因。它的缺点在于写入连续数据时有轻微性能损失，因为硬盘磁头要运动到另一片区域来写入镜像。当数据读取性能和可用性/冗余性一样重要时，比起 RAID1+0 <b>和</b> RAID5，更应该优先考虑远 2 布局的 RAID10。需注意这种方式仍无法代替备份。详情请阅读维基百科相关页面。</dd>
</dl>
<h3>
<span id="RAID_.E7.BA.A7.E5.88.AB.E5.AF.B9.E6.AF.94"></span><span class="mw-headline" id="RAID_级别对比">RAID 级别对比</span>
</h3>
<table class="wikitable">
<tbody>
<tr>
<th>RAID 级别</th>
<th>数据冗余</th>
<th>物理设备利用率</th>
<th>读取性能</th>
<th>写入性能</th>
<th>最少磁盘数量
</th>
</tr>
<tr>
<td><b>0</b></td>
<td data-sort-value="1" style="background: #faa; color: inherit; vertical-align: middle; text-align: center;">No</td>
<td>100%</td>
<td>n 倍
<p><b>最优</b>
</p>
</td>
<td>n 倍
<p><b>最优</b>
</p>
</td>
<td>2
</td>
</tr>
<tr>
<td><b>1</b></td>
<td data-sort-value="5" style="background: #afa; color: inherit; vertical-align: middle; text-align: center;">Yes</td>
<td>50%</td>
<td>如果有多个进程同时读取，最多 n 倍，否则 1 倍
</td>
<td>1 倍</td>
<td>2
</td>
</tr>
<tr>
<td><b>5</b></td>
<td data-sort-value="5" style="background: #afa; color: inherit; vertical-align: middle; text-align: center;">Yes</td>
<td>67% - 94%</td>
<td>(n−1) 倍
<p><b>较优</b>
</p>
</td>
<td>(n−1) 倍
<p><b>较优</b>
</p>
</td>
<td>3
</td>
</tr>
<tr>
<td><b>6</b></td>
<td data-sort-value="5" style="background: #afa; color: inherit; vertical-align: middle; text-align: center;">Yes</td>
<td>50% - 88%</td>
<td>(n−2) 倍</td>
<td>(n−2) 倍</td>
<td>4
</td>
</tr>
<tr>
<td><b>10,far2</b></td>
<td data-sort-value="5" style="background: #afa; color: inherit; vertical-align: middle; text-align: center;">Yes</td>
<td>50%</td>
<td>n 倍
<p><b>最优;</b> 与 RAID0 相当但加入了数据冗余
</p>
</td>
<td>(n/2) 倍</td>
<td>2
</td>
</tr>
<tr>
<td><b>10,near2</b></td>
<td data-sort-value="5" style="background: #afa; color: inherit; vertical-align: middle; text-align: center;">Yes</td>
<td>50%</td>
<td>如果有多个进程同时读取，最多 n 倍，否则 1 倍</td>
<td>(n/2) 倍</td>
<td>2
</td>
</tr>
</tbody>
</table>
<p>* 其中 <i>n</i> 表示用于组成阵列的磁盘数量。
</p>
<h2>
<span id=".E5.AE.9E.E7.8E.B0.E6.96.B9.E5.BC.8F"></span><span class="mw-headline" id="实现方式">实现方式</span>
</h2>
<p>RAID 设备可以用不同方式来管理：
</p>
<dl>
<dt>软件 RAID</dt>
<dd>这是最简单的实现方式，因为它不依赖于专用固件或专有软件。这种阵列由操作系统通过以下方式进行管理：
<ul>
<li>通过抽象层管理（比如 <a href="#%E5%AE%89%E8%A3%85">mdadm</a>）； <div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 这是在本指南下文将要使用的方法。</div>
</li>
<li>通过逻辑卷管理器来管理（比如 <a href="../en/LVM.html#RAID" title="LVM">LVM</a>）；</li>
<li>通过文件系统的某个组件来管理（比如 <a href="../zh-CN/ZFS.html" title="ZFS (简体中文)">ZFS</a>，<a href="../en/Btrfs.html#RAID" title="Btrfs">Btrfs</a>）。</li>
</ul>
</dd>
</dl>
<dl>
<dt>硬件 RAID</dt>
<dd>这种阵列由安装在计算机上的专用硬件卡直接管理，硬盘直接连接在该计算机上。RAID 的处理逻辑由板载的处理器完成，它独立于 <a href="https://en.wikipedia.org/wiki/Central_processing_unit" class="extiw" title="wikipedia:Central processing unit">主处理器 (CPU)</a>。尽管这种方案独立于任何操作系统，但却需要驱动程序来使硬件 RAID 控制器正常工作。取决于不同的制造商，硬件 RAID 阵列可以在 option ROM 里设置或者操作系统安装完成后另行安装配套软件来设置。这种设置是独立于 Linux 内核的：内核并不能看到单独的每块硬盘。</dd>
</dl>
<dl>
<dt><a href="../en/Install_Arch_Linux_with_Fake_RAID.html" class="mw-redirect" title="Fakeraid">FakeRAID</a></dt>
<dd>这种类型的 RAID 应当称为 BIOS 或板载 RAID，却常被错误地当做硬件 RAID 来宣传。这种阵列由伪 RAID 控制器来管理，RAID 逻辑由 option ROM 或<a rel="nofollow" class="external text" href="http://www.win-raid.com/t19f13-Intel-EFI-RAID-quot-SataDriver-quot-BIOS-Modules.html">安装了 EFI Sata 驱动程序的</a> 固件本身（<a href="../zh-CN/Unified_Extensible_Firmware_Interface.html" title="Unified Extensible Firmware Interface (简体中文)">UEFI</a> 情况下）来完成，但并不是实现了 <i>所有</i> RAID 功能的完整硬件 RAID 控制器。因此，这种 RAID 有时被称为 FakeRAID。来自 <a href="../zh-CN/Official_repositories.html" title="Official repositories (简体中文)">官方仓库</a> 的 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=dmraid">dmraid</a></span> 用于处理这种控制器。这里列出一些 FakeRAID 控制器：<a href="https://en.wikipedia.org/wiki/Intel_Rapid_Storage_Technology" class="extiw" title="wikipedia:Intel Rapid Storage Technology">Intel Rapid Storage</a>，JMicron JMB36x RAID ROM，AMD RAID，ASMedia 106x 和 NVIDIA MediaShield。</dd>
</dl>
<h3>
<span id=".E6.88.91.E6.AD.A3.E5.9C.A8.E4.BD.BF.E7.94.A8.E5.93.AA.E4.B8.80.E7.A7.8D_RAID.EF.BC.9F"></span><span class="mw-headline" id="我正在使用哪一种_RAID？">我正在使用哪一种 RAID？</span>
</h3>
<p>由于软件 RAID 是由用户部署的，因此用户很容易就知道 RAID 的类型。
</p>
<p>但是，辨别 FakeRAID 和真正的硬件 RAID 是很困难的。如上所述，制造商经常错误地混淆这两种类型的 RAID，还可能进行虚假宣传。这种情况下应该采取的最好方式是运行 <code>lspci</code> 命令并在输出信息中找到你的 RAID 控制器，然后根据这些信息进行更进一步的搜索。硬件 RAID 控制器会在这一列表中出现，但 FakeRAID 不会。同时，真正的硬件 RAID 控制器通常价格很高，如果这个系统是自行组装的，那么很可能安装一个硬件 RAID 会使电脑的价格显著提高。
</p>
<h2>
<span id=".E5.AE.89.E8.A3.85"></span><span class="mw-headline" id="安装">安装</span>
</h2>
<p><a href="../en/Help:Reading.html#Installation_of_packages" class="mw-redirect" title="Install">安装</a> <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=mdadm">mdadm</a></span>。<i>mdadm</i> 用于管理在纯块设备上建立起来的纯软件 RAID：底层硬件不提供任何 RAID 逻辑，只是一些磁盘而已。<i>mdadm</i> 可以在任何块设备集合上工作，甚至是那些非常规的设备。比如，你可以用一堆 U 盘来建立 RAID 阵列。
</p>
<h3>
<span id=".E5.87.86.E5.A4.87.E8.AE.BE.E5.A4.87"></span><span class="mw-headline" id="准备设备">准备设备</span>
</h3>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>警告：</strong> 这些步骤会擦除指定设备上的所有数据，输入命令请小心！</div>
<p>如果设备是旧设备重用或刚从一个现有的阵列上拆下来，请擦除所有旧的 RAID 配置信息：
</p>
<pre># mdadm --misc --zero-superblock /dev/&lt;drive&gt;
</pre>
<p>或者是删除设备上的某个特定的分区：
</p>
<pre># mdadm --misc --zero-superblock /dev/&lt;partition&gt;
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 
<ul>
<li>清除一个分区的 superblock 不会影响到磁盘上的其他分区。</li>
<li>考虑到 RAID 本身的功能特点，在运行中的磁盘阵列中完全地 <a href="../en/Securely_wipe_disk.html" title="Securely wipe disk">安全擦除磁盘</a> 是很困难的。请在创建阵列前考虑要不要安全擦除磁盘。</li>
</ul>
</div>
<h3>
<span id=".E5.AF.B9.E7.A3.81.E7.9B.98.E8.BF.9B.E8.A1.8C.E5.88.86.E5.8C.BA"></span><span class="mw-headline" id="对磁盘进行分区">对磁盘进行分区</span>
</h3>
<p>强烈推荐对用于阵列的硬盘进行分区。考虑到大多数 RAID 用户会用到超过 2 TiB 的硬盘，因此推荐并要求使用 GPT。参阅 <a href="../zh-CN/Partitioning.html" title="Partitioning (简体中文)">Partitioning (简体中文)</a> 获取关于磁盘分区的更多信息以及可供使用的 <a href="../zh-CN/Partitioning.html#%E5%88%86%E5%8C%BA%E5%B7%A5%E5%85%B7" title="Partitioning (简体中文)">分区工具</a>。
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 也可以在裸磁盘（没有分区的磁盘）上直接创建 RAID，但不推荐这么做，因为这样可能会导致更换损坏硬盘时出现问题</div>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 当更换 RAID 中的某块损坏的硬盘时，新硬盘的大小必须恰好等于或大于损坏的硬盘，否则无法完成阵列重建过程。即使是同一厂商相同型号的硬盘也可能有容量上的细微差别。通过在磁盘末尾保留一些未分配的空间可以消除磁盘容量上的细微差异，这样可以使替代磁盘的型号选择更加容易。因此，最好在磁盘末尾留出大约 100 MiB 的未分配空间。</div>
<h4>
<span id="GUID_.E5.88.86.E5.8C.BA.E8.A1.A8"></span><span class="mw-headline" id="GUID_分区表">GUID 分区表</span>
</h4>
<ul>
<li>创建分区以后，这些分区的 <a href="https://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs" class="extiw" title="wikipedia:GUID Partition Table">类型标识符 (GUID)</a> 应该是 <code>A19D880F-05FC-4D3B-A006-743F0F84911E</code>（在 <i>fdisk</i> 里将分区类型改为 <code>Linux RAID</code> 或在 <i>gdisk</i> 里改为 <code>FD00</code> 可以给所选分区分配这个标识符）。</li>
<li>如果使用了一个更大的磁盘阵列，可以考虑分配 <a href="../zh-CN/Persistent_block_device_naming.html#by-label" title="Persistent block device naming (简体中文)">文件系统标签</a> 或 <a href="../zh-CN/Persistent_block_device_naming.html#by-partlabel" title="Persistent block device naming (简体中文)">分区标签</a> 用于以后区分每块单独的硬盘。</li>
<li>建议在每个设备上创建大小相同的分区。</li>
</ul>
<h4>
<span id=".E4.B8.BB.E5.BC.95.E5.AF.BC.E8.AE.B0.E5.BD.95_.28MBR.29"></span><span class="mw-headline" id="主引导记录_(MBR)">主引导记录 (MBR)</span>
</h4>
<p>对于在使用 MBR 的硬盘上创建分区的用户，可用的 <a href="https://en.wikipedia.org/wiki/Partition_type" class="extiw" title="wikipedia:Partition type">分区类型 ID</a> 包括：
</p>
<ul>
<li>
<code>0xFD</code>: 自动检测的 RAID（<i>fdisk</i> 中称为 <code>Linux raid autodetect</code>）</li>
<li>
<code>0xDA</code>: 无文件系统（<i>fdisk</i> 中称为 <code>Non-FS data</code>）</li>
</ul>
<p>更多信息请参阅 <a rel="nofollow" class="external text" href="https://raid.wiki.kernel.org/index.php/Partition_Types">Linux Raid Wiki:Partition Types</a>。
</p>
<h3>
<span id=".E5.88.9B.E5.BB.BA.E9.98.B5.E5.88.97"></span><span class="mw-headline" id="创建阵列">创建阵列</span>
</h3>
<p>使用 <code>mdadm</code> 来创建阵列。参阅 <span class="plainlinks archwiki-template-man" title="$ man 8 mdadm"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/mdadm.8">mdadm(8)</a></span> 获取支持的选项。下面列出部分使用范例。
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>警告：</strong> 不要简单地复制/粘贴下面的示例，确保你已经使用正确的选项和设备名称替代了示例中相应的内容。</div>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 
<ul>
<li>如果有一个从 <a href="../zh-CN/Syslinux.html" title="Syslinux (简体中文)">Syslinux</a> 启动的 RAID1 阵列，在 syslinux v4.07 中要求元数据值为 1.0，而不是默认的 1.2。</li>
<li>当用 <a href="../zh-CN/Archiso.html" title="Archiso (简体中文)">Arch 安装镜像</a> 创建磁盘阵列时，请使用 <code>--homehost=<i>myhostname</i></code> 选项设置 <a href="../en/Network_configuration.html#Set_the_hostname" class="mw-redirect" title="Hostname">主机名</a>（或者 <code>--homehost=any</code> 选项无论在什么主机上都用相同的主机名），否则主机名称 <code>archiso</code> 会被写入阵列的元数据中。</li>
</ul>
</div>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>提示：</strong> 要为 RAID 设备指定一个自定义的名称，可以使用 <code>--name=<i>MyRAIDName</i></code> 选项或将 RAID 设备路径改为 <code>/dev/md/<i>MyRAIDName</i></code>。Udev 会使用该名称创建指向 <code>/dev/md/</code> 内 RAID 阵列的符号链接。如果 <code>homehost</code> 与当前 <a href="../en/Network_configuration.html#Set_the_hostname" class="mw-redirect" title="Hostname">主机名</a> 匹配（或者 homehost 设为了 <code>any</code>）则链接将会是 <code>/dev/md/<i>name</i></code>，如果 homehost 不匹配那么链接将会是 <code>/dev/md/<i>homehost</i>:<i>name</i></code>。</div>
<p>下面这个例子展示了在 2 个设备上建立 RAID1 阵列：
</p>
<pre># mdadm --create --verbose --level=1 --metadata=1.2 --raid-devices=2 /dev/md/MyRAID1Array /dev/sdb1 /dev/sdc1
</pre>
<p>下面这个例子展示了使用 4 块磁盘作为工作 (active) 磁盘，1 块作为备用 (spare) 磁盘建立 RAID5 阵列：
</p>
<pre># mdadm --create --verbose --level=5 --metadata=1.2 --chunk=256 --raid-devices=4 /dev/md/MyRAID5Array /dev/sdb1 /dev/sdc1 /dev/sdd1 /dev/sde1 --spare-devices=1 /dev/sdf1
</pre>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>提示：</strong> <code>--chunk</code> 可用于修改默认的区块大小。更多关于优化区块大小的内容请参阅 <a rel="nofollow" class="external text" href="http://www.zdnet.com/article/chunks-the-hidden-key-to-raid-performance/">Chunks: the hidden key to RAID performance</a>。</div>
<p>下面这个例子展示了在 2 个设备上建立远 2 布局的 RAID10 阵列 (RAID10, far2)：
</p>
<pre># mdadm --create --verbose --level=10 --metadata=1.2 --chunk=512 --raid-devices=2 --layout=f2 /dev/md/MyRAID10Array /dev/sdb1 /dev/sdc1
</pre>
<p>这样，阵列就会在虚拟设备 <code>/dev/mdX</code> 下建立起来，容量已经合并且可以使用（但处于降级模式）。mdadm 在后台同步数据时你已经可以直接开始使用这个阵列了。储存奇偶校验位可能要花很长时间，可以用这个命令查看进度：
</p>
<pre>$ cat /proc/mdstat
</pre>
<h3>
<span id=".E6.9B.B4.E6.96.B0.E9.85.8D.E7.BD.AE.E6.96.87.E4.BB.B6"></span><span class="mw-headline" id="更新配置文件">更新配置文件</span>
</h3>
<p>默认情况下，<code>mdadm.conf</code> 中的大部分内容都被注释掉了，它应该只包含如下内容：
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/mdadm.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">...
DEVICE partitions
...
</pre>
<p>这一指令告诉 mdadm 检查由 <code>/proc/partitions</code> 引用的所有设备并尽可能将其中的阵列组合起来。如果你确实想启动所有可用的阵列并且确信不存在意料之外的超级块（比如安装了新的存储设备），那么这样的配置就很好。当然有一种更精准的控制方法，就是显式地将阵列添加到 <code>/etc/mdadm.conf</code>：
</p>
<pre># mdadm --detail --scan &gt;&gt; /etc/mdadm.conf
</pre>
<p>这将会在配置中添加类似这样的内容：
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/mdadm.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">...
DEVICE partitions
...
ARRAY /dev/md/MyRAID1Array metadata=1.2 name=pine:MyRAID1Array UUID=27664f0d:111e493d:4d810213:9f291abe</pre>
<p>这也会使 mdadm 检查由 <code>/proc/partitions</code> 引用的设备。但是，只有超级块的 UUID 是 <code>27664…</code> 的设备才会被组合成激活的阵列。
</p>
<p>更多信息请参阅 <span class="plainlinks archwiki-template-man" title="$ man 5 mdadm.conf"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/mdadm.conf.5">mdadm.conf(5)</a></span>。
</p>
<h3>
<span id=".E7.BB.84.E5.90.88.E6.88.90.E7.A3.81.E7.9B.98.E9.98.B5.E5.88.97"></span><span class="mw-headline" id="组合成磁盘阵列">组合成磁盘阵列</span>
</h3>
<p>更新配置文件后即可用 mdadm 组合磁盘阵列：
</p>
<pre># mdadm --assemble --scan
</pre>
<h3>
<span id=".E6.A0.BC.E5.BC.8F.E5.8C.96_RAID_.E4.B8.8A.E7.9A.84.E6.96.87.E4.BB.B6.E7.B3.BB.E7.BB.9F"></span><span class="mw-headline" id="格式化_RAID_上的文件系统">格式化 RAID 上的文件系统</span>
</h3>
<p>现在磁盘阵列已经可以像普通分区一样被格式化成某个 <a href="../zh-CN/File_systems.html" title="File systems (简体中文)">文件系统</a>，但要记住：
</p>
<ul>
<li>不是所有文件系统都支持超大分区（参阅 <a href="https://en.wikipedia.org/wiki/Comparison_of_file_systems#Limits" class="extiw" title="wikipedia:Comparison of file systems">Wikipedia:Comparison of file systems#Limits</a>）。</li>
<li>文件系统需要支持在线增大和收缩（参阅 <a href="https://en.wikipedia.org/wiki/Comparison_of_file_systems#Features" class="extiw" title="wikipedia:Comparison of file systems">Wikipedia:Comparison of file systems#Features</a>）。</li>
<li>应合理计算跨度大小和带区宽度来获得最佳性能。</li>
</ul>
<h4>
<span id=".E8.AE.A1.E7.AE.97_stride.EF.BC.88.E8.B7.A8.E5.BA.A6.E5.A4.A7.E5.B0.8F.EF.BC.89.E5.92.8C_stripe_width.EF.BC.88.E5.B8.A6.E5.8C.BA.E5.AE.BD.E5.BA.A6.EF.BC.89"></span><span class="mw-headline" id="计算_stride（跨度大小）和_stripe_width（带区宽度）">计算 stride（跨度大小）和 stripe width（带区宽度）</span>
</h4>
<p>优化文件系统结构以适应底层 RAID 结构需要 2 个参数：<i>stride</i> 和 <i>stripe width</i>。它们对应于 RAID 的 <i>chunk size（区块大小）</i> 、文件系统的 <i>block size（块大小）</i> 以及 <i>"data disks"（数据盘）的数量</i>。
</p>
<p>Chunk size（RAID 区块大小）是 RAID 阵列的一个属性，在阵列创建时就已经定好了。目前 <code>mdadm</code> 默认该值为 512 KiB。这个参数可以用 <code>mdadm</code> 读取：
</p>
<pre># mdadm --detail /dev/mdX | grep 'Chunk Size'
</pre>
<p>Block size（块大小）是文件系统的一个属性，在文件系统创建时就已经定好了。在大部分文件系统上（包括 ext4）默认是 4 KiB。更多关于当前系统 ext4 的信息可以查看 <code>/etc/mke2fs.conf</code> 文件。
</p>
<p>"Data disks"（数据盘）的数量指的是阵列能够完全重建数据所要求的最少可用设备。例如，对于 N 个设备的 raid0 来说这个数量是 N，对于 raid5 来说是 N-1。
</p>
<p>当你获得了这三个参数时，stride 和 stripe width 可以用下列公式来计算：
</p>
<pre>stride = chunk size / block size
stripe width = number of data disks * stride
</pre>
<h5>
<span id=".E8.8C.83.E4.BE.8B_1._RAID0"></span><span class="mw-headline" id="范例_1._RAID0">范例 1. RAID0</span>
</h5>
<p>本范例使用了正确的 stride 和 stripe width 将合并后的分区格式化成了 ext4：
</p>
<ul>
<li>假设这一 RAID0 阵列是由 2 块物理硬盘组成的。</li>
<li>Chunk size（RAID 区块大小）是 64 KiB。</li>
<li>Block size（文件系统块大小）是 4 KiB。</li>
</ul>
<p>因为 stride = chunk size / block size。在这个例子中，stride 大小是 64/4 = 16。
</p>
<p>因为 stripe width = # of physical <b>data</b> disks * stride。在这个例子中，stripe width 的大小是 2*16 = 32。
</p>
<pre># mkfs.ext4 -v -L myarray -m 0.5 -b 4096 -E stride=16,stripe-width=32 /dev/md0
</pre>
<h5>
<span id=".E8.8C.83.E4.BE.8B_2._RAID5"></span><span class="mw-headline" id="范例_2._RAID5">范例 2. RAID5</span>
</h5>
<p>本范例使用了正确的 stride 和 stripe width 将合并后的分区格式化成了 ext4：
</p>
<ul>
<li>假设这一 RAID5 阵列由 4 块物理硬盘组成，3 块是数据盘，1 块是奇偶校验盘。</li>
<li>Chunk size（RAID 区块大小）是 512 KiB。</li>
<li>Block size（文件系统块大小）是 4 KiB。</li>
</ul>
<p>因为 stride = chunk size / block size。在这个例子中，stride 大小是 512/4 = 128。
</p>
<p>因为 stripe width = # of physical <b>data</b> disks * stride。在这个例子中，stripe width 的大小是 3*128 = 384.
</p>
<pre># mkfs.ext4 -v -L myarray -m 0.01 -b 4096 -E stride=128,stripe-width=384 /dev/md0
</pre>
<p>关于 stride 和 stripe width 的更多信息，请参阅：<a rel="nofollow" class="external text" href="http://wiki.centos.org/HowTos/Disk_Optimization">RAID Math</a>。
</p>
<h5>
<span id=".E8.8C.83.E4.BE.8B_3._RAID10.2Cfar2"></span><span class="mw-headline" id="范例_3._RAID10,far2">范例 3. RAID10,far2</span>
</h5>
<p>本范例使用了正确的 stride 和 stripe width 将合并后的分区格式化成了 ext4：
</p>
<ul>
<li>假设这一 RAID10 阵列由 2 块物理硬盘组成。考虑到远 2 布局的 RAID10 的自身特性，两块硬盘都是数据盘。</li>
<li>Chunk size（RAID 区块大小）是 512 KiB。</li>
</ul>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># mdadm --detail /dev/md0 | grep 'Chunk Size'</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">    Chunk Size : 512K
</pre>
<ul><li>Block size（文件系统块大小）是 4 KiB。</li></ul>
<p>因为 stride = chunk size / block size。
在这个例子中，stride 大小是 512/4 = 128。
</p>
<p>因为 stripe width = # of physical <b>data</b> disks * stride。
在这个例子中，stripe width 的大小是 2*128 = 256。
</p>
<pre># mkfs.ext4 -v -L myarray -m 0.01 -b 4096 -E stride=128,stripe-width=256 /dev/md0
</pre>
<h2>
<span id=".E5.9C.A8_Live_CD_.E4.B8.AD.E6.8C.82.E8.BD.BD_RAID"></span><span class="mw-headline" id="在_Live_CD_中挂载_RAID">在 Live CD 中挂载 RAID</span>
</h2>
<p>如果你需要在 Live CD 中挂载 RAID 分区，用这个命令：
</p>
<pre># mdadm --assemble /dev/&lt;disk1&gt; /dev/&lt;disk2&gt; /dev/&lt;disk3&gt; /dev/&lt;disk4&gt;
</pre>
<p>如果缺一块盘的 RAID 1 被错误地识别为了 RAID 1（参照 <code>mdadm --detail /dev/md&lt;number&gt;</code>）并报告为非活动状态（参照 <code>cat /proc/mdstat</code>），需要先停止磁盘阵列：
</p>
<pre># mdadm --stop /dev/md&lt;number&gt;
</pre>
<h2>
<span id=".E5.9C.A8_RAID_.E4.B8.8A.E5.AE.89.E8.A3.85_Arch_Linux"></span><span class="mw-headline" id="在_RAID_上安装_Arch_Linux">在 RAID 上安装 Arch Linux</span>
</h2>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 本节仅适用于根文件系统在磁盘阵列上的情况。如果你的磁盘阵列上只是一个数据分区，那么可以跳过本节。</div>
<p>你应该在安装过程中的 <a href="../zh-CN/Partitioning.html" title="Partitioning (简体中文)">分区</a> 和 <a href="../zh-CN/File_systems.html#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F" title="File systems (简体中文)">格式化</a> 步骤之间创建 RAID 阵列。这将会把一个位于 RAID 阵列上的分区格式化成根文件系统，而不是直接格式化一个分区。
按照 <a href="#%E5%AE%89%E8%A3%85">#安装</a> 一节的步骤创建 RAID 阵列。，然后继续安装过程，直到 pacstrap 步骤完成。
当使用 <a href="../zh-CN/Unified_Extensible_Firmware_Interface.html" title="Unified Extensible Firmware Interface (简体中文)">UEFI 启动</a> 时，还需要阅读 <a href="../zh-CN/EFI_system_partition.html#RAID_%E4%B8%8A%E7%9A%84_ESP" title="EFI system partition (简体中文)">EFI system partition (简体中文)#RAID 上的 ESP</a>。
</p>
<h3>
<span id=".E6.9B.B4.E6.96.B0.E9.85.8D.E7.BD.AE.E6.96.87.E4.BB.B6_2"></span><span class="mw-headline" id="更新配置文件_2">更新配置文件</span>
</h3>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 这些操作应该在 chroot 以外完成，因此要在文件路径前加上 <code>/mnt</code>。</div>
<p>在基本系统安装完成以后，RAID 的默认配置文件 <code>mdadm.conf</code> 需要这样来更新：
</p>
<pre># mdadm --detail --scan &gt;&gt; /mnt/etc/mdadm.conf
</pre>
<p>在运行这个命令以后一定要用文本编辑器检查 <code>mdadm.conf</code> 配置文件来确保它的内容看起来是合理的。
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 为防止系统启动时 <code>mdmonitor.service</code> 启动失败（默认设为自动启动），你需要取消 <code>MAILADDR</code> 的注释，并且在 <code>mdadm.conf</code> 结尾留下可处理磁盘阵列出错通知的邮件地址和/或应用程序。参阅 <a href="#%E5%90%AF%E7%94%A8%E4%BA%8B%E4%BB%B6%E9%82%AE%E4%BB%B6%E9%80%9A%E7%9F%A5">#启用事件邮件通知</a>。</div>
<p>现在继续安装过程直到 <a href="../zh-CN/Installation_guide.html#Initramfs" title="Installation guide (简体中文)">Installation guide (简体中文)#Initramfs</a> 步骤之前为止，然后按照下一节的步骤做。
</p>
<h3>
<span id=".E9.85.8D.E7.BD.AE_mkinitcpio"></span><span class="mw-headline" id="配置_mkinitcpio">配置 mkinitcpio</span>
</h3>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 这些操作应该在 chroot 时完成。</div>
<p>向 <code>mkinitcpio.conf</code> 中的 <a href="../zh-CN/Mkinitcpio.html#%E9%92%A9%E5%AD%90(HOOKS)" title="Mkinitcpio (简体中文)">HOOKS</a> 部分添加 <code>mdadm_udev</code> 来为初始化内存盘添加 mdadm 支持：
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/mkinitcpio.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">...
 HOOKS=(base udev autodetect keyboard modconf block <b>mdadm_udev</b> filesystems fsck)
...</pre>
<p>如果在一个 FakeRAID 阵列上使用 <code>mdadm_udev</code> 钩子，建议在 <a href="../zh-CN/Mkinitcpio.html#%E9%99%84%E5%8A%A0%E6%96%87%E4%BB%B6%EF%BC%88BINARIES%E3%80%81FILES%EF%BC%89" title="Mkinitcpio (简体中文)">BINARIES</a> 列表中添加 <i>mdmon</i>：
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/mkinitcpio.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">...
BINARIES=(<b>mdmon</b>)
...</pre>
<p>然后 <a href="../zh-CN/Mkinitcpio.html#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E7%94%A8%E9%95%9C%E5%83%8F" title="Mkinitcpio (简体中文)">重新生成初始化内存盘</a>。
</p>
<p>参考 <a href="../zh-CN/Mkinitcpio.html#%E4%BD%BF%E7%94%A8_RAID_%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97" title="Mkinitcpio (简体中文)">mkinitcpio (简体中文)#使用 RAID 磁盘阵列</a>。
</p>
<h3>
<span id=".E9.85.8D.E7.BD.AE_boot_loader"></span><span class="mw-headline" id="配置_boot_loader">配置 boot loader</span>
</h3>
<p>将 <code>root</code> 参数指向映射的磁盘，例如：
</p>
<pre>root=/dev/md/<i>MyRAIDArray</i>
</pre>
<p>如果按上述用内核设备节点来指定映射磁盘的方法之后，从软件 RAID 分区启动失败了，那就用 <a href="../zh-CN/Persistent_block_device_naming.html" title="Persistent block device naming (简体中文)">持久化命名块设备</a> 中的某种方法来指定映射的磁盘，例如：
</p>
<pre>root=LABEL=Root_Label
</pre>
<p>参考 <a href="../en/GRUB.html#RAID" title="GRUB">GRUB#RAID</a>。
</p>
<h2>
<span id=".E7.BB.B4.E6.8A.A4_RAID"></span><span class="mw-headline" id="维护_RAID">维护 RAID</span>
</h2>
<h3>
<span id=".E6.95.B0.E6.8D.AE.E6.B8.85.E6.89.AB_.28Scrubbing.29"></span><span class="mw-headline" id="数据清扫_(Scrubbing)">数据清扫 (Scrubbing)</span>
</h3>
<p>定期运行数据 <a href="https://en.wikipedia.org/wiki/Data_scrubbing" class="extiw" title="wikipedia:Data scrubbing">清扫 (Scrubbing)</a> 来检查并修复错误是一种很好的做法。一次完整数据清扫可能会花费数个小时，具体取决于磁盘阵列的大小和配置。
</p>
<p>启动数据清扫：
</p>
<pre># echo check &gt; /sys/block/md0/md/sync_action
</pre>
<p>数据检查操作会扫描驱动器来检查坏扇区并自动修复它们。如果找到了包含损坏数据的好扇区（本扇区中的数据与另一块硬盘中记录本扇区应有的数据不符，例如奇偶校验块和另一块数据块相结合可以证明本数据块是错误的），那就不动作，但记录下这一事件（见下文）。这种“不动作”允许管理员自行检查坏扇区中原本的数据和从冗余数据中重建的数据，然后决定保留哪个。
</p>
<p>与许多 mdadm 相关的任务/事项一样，数据清扫的进度也可以通过查看 <code>/proc/mdstat</code> 文件来查询。
</p>
<p>例如：
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$ cat /proc/mdstat</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Personalities : [raid6] [raid5] [raid4] [raid1]
md0 : active raid1 sdb1[0] sdc1[1]
      3906778112 blocks super 1.2 [2/2] [UU]
      [&gt;....................]  check =  4.0% (158288320/3906778112) finish=386.5min speed=161604K/sec
      bitmap: 0/30 pages [0KB], 65536KB chunk
</pre>
<p>安全地停止当前的数据清扫操作：
</p>
<pre># echo idle &gt; /sys/block/md0/md/sync_action
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 如果在数据清扫暂停时重启了系统，将继续进行清扫。</div>
<p>数据清扫完成后，管理员可以检查有多少数据块（如果有的话）被标记为坏块：
</p>
<pre># cat /sys/block/md0/md/mismatch_cnt
</pre>
<h4>
<span id=".E5.85.B3.E4.BA.8E.E6.95.B0.E6.8D.AE.E6.B8.85.E6.89.AB.E7.9A.84.E4.B8.80.E8.88.AC.E8.AF.B4.E6.98.8E"></span><span class="mw-headline" id="关于数据清扫的一般说明">关于数据清扫的一般说明</span>
</h4>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 用户也可以 echo <b>repair</b> 到 <code>/sys/block/md0/md/sync_action</code> 里面，但是这是不明智的，因为一旦遇到数据不一致就被自动改写为一致。危险之处在于我们实际并不知道奇偶校验块和数据块哪个是对的（在 RAID1 中是不知道哪个数据块是对的）。因此自动清扫操作能不能用正确数据替换错误数据取决于运气。</div>
<p>以 root 身份设定一个 cron 任务来定期执行清扫是很好的。<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/raid-check/">raid-check</a></span><sup><small>AUR</small></sup> 会对此有所帮助。如果要用 systemd 定时器而不是 cron 来执行定期清扫，<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/raid-check-systemd/">raid-check-systemd</a></span><sup><small>AUR</small></sup> 中包含了相同的脚本和配套的 systemd 定时器单元文件。
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 对于常规的大容量驱动器，清扫工作耗时大约 <b>6 秒每 GB</b>（即每 TB 大约需要 1 小时 45 分钟），因此应合理确定 cron 任务或定时器的开始时间。</div>
<h4>
<span id=".E5.AF.B9.E6.B8.85.E6.89.AB_RAID1_.E5.92.8C_RAID10_.E7.9A.84.E8.AF.B4.E6.98.8E"></span><span class="mw-headline" id="对清扫_RAID1_和_RAID10_的说明">对清扫 RAID1 和 RAID10 的说明</span>
</h4>
<p>由于 RAID1 和 RAID10 本质上就是没有数据缓冲的，所以即使阵列工作正常，它的不匹配计数仍然可能是个非零值。这些不匹配计数只存在于正在写入数据的区域，且它们不反映任何问题。但是，我们无法区分非零的不匹配计数到底代表正在写入数据还是确实存在问题。这是造成 RAID1 和 RAID10 阵列误报错误的根源。即使如此，仍然建议定期清扫以发现并纠正驱动器上可能出现的坏扇区。
</p>
<h3>
<span id=".E4.BB.8E.E9.98.B5.E5.88.97.E4.B8.AD.E7.A7.BB.E9.99.A4.E8.AE.BE.E5.A4.87"></span><span class="mw-headline" id="从阵列中移除设备">从阵列中移除设备</span>
</h3>
<p>要从阵列中移除一个设备，先将这个设备标记为 faulty（故障）：
</p>
<pre># mdadm --fail /dev/md0 /dev/sdxx
</pre>
<p>现在从阵列中移除这个设备：
</p>
<pre># mdadm --remove /dev/md0 /dev/sdxx
</pre>
<p>永久移除设备（比如想把一个设备拿出来单独使用）：
先使用上述两个命令，然后：
</p>
<pre># mdadm --zero-superblock /dev/sdxx
</pre>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>警告：</strong> 
<ul>
<li>不要在 RAID0 阵列或者其他线性存放数据的阵列中进行这个操作！否则数据会丢失！</li>
<li>重新使用已经移除的硬盘却不清除它的超级块将会导致下次启动时丢失所有数据。（因为 mdadm 将会把它当做磁盘阵列的一部分来使用）。</li>
</ul>
</div>
<p>停止使用某个阵列：
</p>
<ol>
<li>卸载 (umount) 目标阵列</li>
<li>用这个命令停止磁盘阵列运行：<code>mdadm --stop /dev/md0</code>
</li>
<li>将本节开头的三个命令在每块硬盘上都运行一遍。</li>
<li>将 <code>/etc/mdadm.conf</code> 中的相关行移除。</li>
</ol>
<h3>
<span id=".E5.90.91.E9.98.B5.E5.88.97.E4.B8.AD.E6.B7.BB.E5.8A.A0.E8.AE.BE.E5.A4.87"></span><span class="mw-headline" id="向阵列中添加设备">向阵列中添加设备</span>
</h3>
<p>可以在系统正在运行且设备已经挂载的情况下使用 mdadm 添加新设备。
按照前文所述的方法，使用现有阵列中相同的布局对新设备进行分区。
</p>
<p>如果 RAID 阵列尚未组合，先组合它们：
</p>
<pre># mdadm --assemble /dev/md0 /dev/sda1 /dev/sdb1
</pre>
<p>向阵列中添加新设备：
</p>
<pre># mdadm --add /dev/md0 /dev/sdc1
</pre>
<p>这一步 mdadm 不会花费很长时间。
</p>
<p>根据不同的 RAID 类型（比如 RAID1），mdadm 可能会把部分设备添加为备用设备，而不在这些设备上存放数据。可以使用 <code>--grow</code> 加上 <code>--raid-devices</code> 选项来增加 RAID 利用的磁盘数量。例如，将一个阵列增加至四块硬盘：
</p>
<pre># mdadm --grow /dev/md0 --raid-devices=4
</pre>
<p>可以这样检查进度：
</p>
<pre># cat /proc/mdstat
</pre>
<p>用这个命令检查已经添加的设备：
</p>
<pre># mdadm --misc --detail /dev/md0
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 对于 RAID0 设备可能会收到以下错误信息：
<pre>mdadm: add new device failed for /dev/sdc1 as 2: Invalid argument
</pre>
<p>这是由于上述命令会将新磁盘添加为 "spare"（备用）盘，但是 RAID0 中不存在备用盘。如果想往 RAID0 阵列中添加磁盘，你需要同时使用 "grow" 和 "add" 参数。如下所示：
</p>
<pre># mdadm --grow /dev/md0 --raid-devices=3 --add /dev/sdc1
</pre>
</div>
<h3>
<span id=".E5.A2.9E.E5.A4.A7_RAID_.E5.8D.B7.E7.9A.84.E5.A4.A7.E5.B0.8F"></span><span class="mw-headline" id="增大_RAID_卷的大小">增大 RAID 卷的大小</span>
</h3>
<p>如果给阵列安装了更大的磁盘，或者增大了分区大小，可能就需要增大 RAID 卷的大小以适应更大的可用空间。这一过程可用首先按照上文中关于更换磁盘的步骤来做。当 RAID 卷在更大的磁盘上重建完成后，这个卷需要 "grow" 来填充多出来的空间。
</p>
<pre># mdadm --grow /dev/md0 --size=max
</pre>
<p>接着，在 RAID 卷 <code>/dev/md0</code> 上的现有分区可能需要调整大小。参阅 <a href="../zh-CN/Partitioning.html" title="Partitioning (简体中文)">Partitioning (简体中文)</a> 获取更多信息。最后，上述分区上的文件系统也需要重新调整大小。如果用 <code>gparted</code> 来完成分区操作，这些都会自动完成。如果用的是其他工具，请手动卸载 (unmount) 文件系统并调整其大小。
</p>
<pre># umount /storage
# fsck.ext4 -f /dev/md0p1
# resize2fs /dev/md0p1
</pre>
<h3>
<span id=".E4.BF.AE.E6.94.B9.E5.90.8C.E6.AD.A5.E9.80.9F.E5.BA.A6.E9.99.90.E5.88.B6"></span><span class="mw-headline" id="修改同步速度限制">修改同步速度限制</span>
</h3>
<p>同步工作需要一定的时间。如果本机不需要完成其他任务，可以提高速度限制值。
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cat /proc/mdstat</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;"> Personalities : [raid1]
 md0 : active raid1 sda3[2] sdb3[1]
       155042219 blocks super 1.2 [2/1] [_U]
       [&gt;....................]  recovery =  0.0% (77696/155042219) finish=265.8min speed=9712K/sec

 unused devices: &lt;none&gt;
</pre>
<p>查看当前速度限制：
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cat /proc/sys/dev/raid/speed_limit_min</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">1000
</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cat /proc/sys/dev/raid/speed_limit_max</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">200000
</pre>
<p>提高限制值：
</p>
<pre># echo 400000 &gt;/proc/sys/dev/raid/speed_limit_min
# echo 400000 &gt;/proc/sys/dev/raid/speed_limit_max
</pre>
<p>然后查看同步速度和预计完成时间：
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cat /proc/mdstat</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;"> Personalities : [raid1]
 md0 : active raid1 sda3[2] sdb3[1]
       155042219 blocks super 1.2 [2/1] [_U]
       [&gt;....................]  recovery =  1.3% (2136640/155042219) finish=158.2min speed=16102K/sec

 unused devices: &lt;none&gt;
</pre>
<p>更多信息可参阅 <a href="../en/Sysctl.html#MDADM" title="Sysctl">sysctl#MDADM</a>。
</p>
<h2>
<span id=".E7.9B.91.E8.A7.86.E8.BF.90.E8.A1.8C.E6.83.85.E5.86.B5"></span><span class="mw-headline" id="监视运行情况">监视运行情况</span>
</h2>
<p>可以显示当前 RAID 设备状态的一行简单命令：
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># awk '/^md/ {printf "%s: ", $1}; /blocks/ {print $NF}' &lt;/proc/mdstat
</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">md1: [UU]
md0: [UU]
</pre>
<h3>
<span id=".E7.94.A8_watch_.E7.9B.91.E8.A7.86_mdstat"></span><span class="mw-headline" id="用_watch_监视_mdstat">用 watch 监视 mdstat</span>
</h3>
<pre># watch -t 'cat /proc/mdstat'
</pre>
<p>或者最好用 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=tmux">tmux</a></span>
</p>
<pre># tmux split-window -l 12 "watch -t 'cat /proc/mdstat'"
</pre>
<h3>
<span id=".E7.94.A8_iotop_.E8.BF.BD.E8.B8.AA_IO"></span><span class="mw-headline" id="用_iotop_追踪_IO">用 iotop 追踪 IO</span>
</h3>
<p><span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=iotop">iotop</a></span> 可以显示各个进程的输入输出状态。请用这个命令来查看 RAID 线程的输入输出。
</p>
<pre># iotop -a -p $(sed 's, , -p ,g' &lt;&lt;&lt;`pgrep "_raid|_resync|jbd2"`)
</pre>
<h3>
<span id=".E7.94.A8_iostat_.E8.BF.BD.E8.B8.AA_IO"></span><span class="mw-headline" id="用_iostat_追踪_IO">用 iostat 追踪 IO</span>
</h3>
<p><span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=sysstat">sysstat</a></span> 包中的 <i>iostat</i> 实用程序可以显示各个设备和分区的输入输出统计。
</p>
<pre># iostat -dmy 1 /dev/md0
# iostat -dmy 1 # all
</pre>
<h3>
<span id=".E5.90.AF.E7.94.A8.E4.BA.8B.E4.BB.B6.E9.82.AE.E4.BB.B6.E9.80.9A.E7.9F.A5"></span><span class="mw-headline" id="启用事件邮件通知">启用事件邮件通知</span>
</h3>
<p>要完成发送邮件的任务需要一个 smtp 邮件服务器或至少需要一个 ssmtp/msmtp 邮件转发器。大概最简单的解决方案是使用 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/dma/">dma</a></span><sup><small>AUR</small></sup>，它非常小巧（安装完只占用 0.08 MiB）且不需要设置。
</p>
<p>编辑 <code>/etc/mdadm.conf</code> 来添加用于接收通知的邮件地址。
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 如果用的是上文提到的 dma，用户可以直接将邮件发送到本机 (localhost) 的某个用户名 (username) 中，不一定非要发到外部邮件地址。</div>
<p>测试配置是否正确：
</p>
<pre># mdadm --monitor --scan --oneshot --test
</pre>
<p>mdadm 使用 <code>mdmonitor.service</code> 来完成监控任务，所以现在你无需进行更多设置了。如果你没有在 <code>/etc/mdadm.conf</code> 设置邮件地址，那么这个 service 就会出错。如果你不想接收 mdadm 一般事件通知，可以忽略这个错误；如果不想接收一般事件通知但是需要接收故障信息，可以 <a href="../zh-CN/Systemd.html#%E4%BD%BF%E7%94%A8%E5%8D%95%E5%85%83" title="Systemd (简体中文)">mask（屏蔽）</a> 这个 unit。
</p>
<h4>
<span id=".E5.85.B6.E4.BB.96.E5.AE.9E.E7.8E.B0.E6.96.B9.E5.BC.8F"></span><span class="mw-headline" id="其他实现方式">其他实现方式</span>
</h4>
<p>为避免安装 smtp 邮件服务器或邮件转发器的麻烦，可以使用系统上已经安装的 <a href="../en/S-nail.html" title="S-nail">S-nail</a> 工具（不要忘了设置它）。
</p>
<p>创建 <code>/etc/mdadm_warning.sh</code> 文件：
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/mdadm_warning.sh</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">#!/bin/bash
event=$1
device=$2

echo " " | /usr/bin/mailx -s "$event on $device" '''destination@email.com'''
</pre>
<p>然后给它执行权限：<code>chmod +x /etc/mdadm_warning.sh</code>
</p>
<p>然后在 mdadm.conf 中添加这一行：
</p>
<pre>PROGRAM /etc/mdadm_warning.sh
</pre>
<p>用前述的方法测试并启用它。
</p>
<h2>
<span id=".E6.95.85.E9.9A.9C.E6.8E.92.E9.99.A4"></span><span class="mw-headline" id="故障排除">故障排除</span>
</h2>
<p>如果你在重启计算机时遇到类似 "invalid raid superblock magic" 的错误，并且除了已经配置好的硬盘外又接了其他硬盘，请检查硬盘顺序是不是正确的。在安装 RAID 时，硬盘编号可能是 hdd、hde 和 hdf，但是重启后它们的编号可能变成了 hda、hdb 和 hdc。请相应地调整你的内核参数。这种情况经常发生。
</p>
<h3>
<span id="Error:_.22kernel:_ataX.00:_revalidation_failed.22"></span><span class="mw-headline" id='Error:_"kernel:_ataX.00:_revalidation_failed"'>Error: "kernel: ataX.00: revalidation failed"</span>
</h3>
<p>如果你突然（在重启、修改 BIOS 设置后）遇到类似错误信息：
</p>
<pre>Feb  9 08:15:46 hostserver kernel: ata8.00: revalidation failed (errno=-5)
</pre>
<p>这并不意味着设备已经损坏。尽管你可能会在网上看到一些讲内核崩溃的链接指向最坏的结果，但总而言之，并不是内核崩溃。可能你不知怎么的在 BIOS 里或内核参数里修改了 APIC 或 ACPI 设置。把它改回来就好了。通常关闭 APIC 和/或 ACPI 就好了。
</p>
<h3>
<span id=".E7.A3.81.E7.9B.98.E9.98.B5.E5.88.97.E4.BB.A5.E5.8F.AA.E8.AF.BB.E6.A8.A1.E5.BC.8F.E5.90.AF.E5.8A.A8"></span><span class="mw-headline" id="磁盘阵列以只读模式启动">磁盘阵列以只读模式启动</span>
</h3>
<p>当由 md 启动磁盘阵列时，超级块将被改写，数据同步可能已经开始了。要以只读模式启动，可以向内核模块 <code>md_mod</code> 传递参数 <code>start_ro</code>。设置了这个参数以后，新的磁盘阵列进入 'auto-ro' 模式，该模式停止了所有内部读写操作（更新超级块、再同步、数据恢复），并且会在第一个写入请求到来时自动切换至 'rw' （读写）模式。
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 在第一个写入请求到来前使用 <code>mdadm --readonly</code> 命令可以将阵列设置为真正的 'ro' （只读）模式，还可以用 <code>mdadm --readwrite</code> 命令直接开始再同步而不用等待写入请求。</div>
<p>要在启动时设置该参数，在内核启动参数中添加 <code>md_mod.start_ro=1</code>。
</p>
<p>也可以在模块加载时传递该参数，可以从 <code>/etc/modprobe.d/</code> 下的文件中传递，也可以直接从 <code>/sys/</code> 传递：
</p>
<pre># echo 1 &gt; /sys/module/md_mod/parameters/start_ro
</pre>
<h3>
<span id=".E5.9C.A8.E6.8D.9F.E5.9D.8F.E6.88.96.E7.BC.BA.E5.A4.B1.E7.A3.81.E7.9B.98.E7.9A.84.E6.83.85.E5.86.B5.E4.B8.8B.E6.81.A2.E5.A4.8D_RAID"></span><span class="mw-headline" id="在损坏或缺失磁盘的情况下恢复_RAID">在损坏或缺失磁盘的情况下恢复 RAID</span>
</h3>
<p>当磁盘阵列中的一个驱动器由于任何原因损坏时，也可能会发生上述错误。如果在缺失一块硬盘的情况下你仍需要强制启动磁盘阵列，输入以下命令（根据实际修改）：
</p>
<pre># mdadm --manage /dev/md0 --run
</pre>
<p>现在你应该可以用类似下面的命令来挂载它（如果在 fstab 里有它的话）：
</p>
<pre># mount /dev/md0
</pre>
<p>现在磁盘阵列应该已经工作并且可以使用，但仍旧是缺一块盘的状态。因此需要按照上文 <a href="#%E5%87%86%E5%A4%87%E8%AE%BE%E5%A4%87">#准备设备</a> 所述再添加一个磁盘分区，然后就可以将新磁盘分区加入到磁盘阵列中：
</p>
<pre># mdadm --manage --add /dev/md0 /dev/sdd1
</pre>
<p>如果输入：
</p>
<pre># cat /proc/mdstat
</pre>
<p>你就能看到磁盘阵列已经激活并正在重建。
</p>
<p>你可能还需要更新你的配置文件（参阅：<a href="#%E6%9B%B4%E6%96%B0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">#更新配置文件</a>）。
</p>
<h2>
<span id=".E5.9F.BA.E5.87.86.E6.B5.8B.E8.AF.95"></span><span class="mw-headline" id="基准测试">基准测试</span>
</h2>
<p>用于 RAID 基准测试的工具有很多种。不同 RAID 最显著的不同是多个线程在读取 RAID 卷时的速度提升程度。
</p>
<p><span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/tiobench/">tiobench</a></span><sup><small>AUR</small></sup><sup>[<a href="../en/Help:Procedures.html#Fix_broken_package_links" title="Help:Procedures">断开的链接</a>：package not found]</sup> 通过测量磁盘的全线程读写 (fully-threaded I/O) 来专门测试多线程性能提升程度。
</p>
<p><span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=bonnie%2B%2B">bonnie++</a></span> 测试对一个或多个数据库类型文件的读写，以及对小文件的创建、读取、删除，这样可以模拟 Squid、INN 和 Maildir format e-mail 等程序的文件读写。其附带的 <a rel="nofollow" class="external text" href="http://www.coker.com.au/bonnie++/zcav/">ZCAV</a> 程序可以测试硬盘不同区域的性能，且不用向硬盘写入任何数据。
</p>
<p><b>不应该</b> 使用 <code>hdparm</code> 来对 RAID 进行基准测试，因为它多次返回的结果会非常不一致。
</p>
<h2>
<span id=".E5.8F.82.E8.80.83.E8.B5.84.E6.96.99"></span><span class="mw-headline" id="参考资料">参考资料</span>
</h2>
<div class="noprint archwiki-template-message">
<p><a href="../File:Tango-view-refresh-red.png" class="image"><img alt="Tango-view-refresh-red.png" src="../File:Tango-view-refresh-red.png" decoding="async" width="48" height="48"></a><b>This article or section is out of date.</b><a href="../File:Tango-view-refresh-red.png" class="image"><img alt="Tango-view-refresh-red.png" src="../File:Tango-view-refresh-red.png" decoding="async" width="48" height="48"></a></p>
<div>
<b>Reason:</b> 许多链接太旧且无效。 (Discuss in <a rel="nofollow" class="external text" href="https://wiki.archlinux.org/index.php/Talk:RAID_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Talk:RAID (简体中文)#</a>)</div>
</div>
<ul>
<li>
<a rel="nofollow" class="external text" href="http://www.gentoo.org/doc/en/articles/software-raid-p1.xml">Software RAID in the new Linux 2.4 kernel, Part 1</a><sup title="最后检查状态：410">[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">失效链接</a> 2020-08-04 ⓘ]</sup> and <a rel="nofollow" class="external text" href="http://www.gentoo.org/doc/en/articles/software-raid-p2.xml">Part 2</a><sup title="最后检查状态：410">[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">失效链接</a> 2020-08-04 ⓘ]</sup> in the Gentoo Linux Docs</li>
<li>
<a rel="nofollow" class="external text" href="https://raid.wiki.kernel.org/index.php/Linux_Raid">Linux RAID wiki entry</a> on The Linux Kernel Archives</li>
<li><a rel="nofollow" class="external text" href="https://raid.wiki.kernel.org/index.php/Write-intent_bitmap">How Bitmaps Work</a></li>
<li>
<a rel="nofollow" class="external text" href="http://docs.redhat.com/docs/en-US/Red_Hat_Enterprise_Linux/6/html/Storage_Administration_Guide/ch-raid.html">Chapter 15: Redundant Array of Independent Disks (RAID)</a> of Red Hat Enterprise Linux 6 Documentation</li>
<li>
<a rel="nofollow" class="external text" href="https://tldp.org/FAQ/Linux-RAID-FAQ/x37.html">Linux-RAID FAQ</a> on the Linux Documentation Project</li>
<li>
<a rel="nofollow" class="external text" href="http://support.dell.com/support/topics/global.aspx/support/entvideos/raid?c=us&amp;l=en&amp;s=gen">Dell.com Raid Tutorial</a><sup>[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">dead link</a> 2018-03-10]</sup> - Interactive Walkthrough of Raid</li>
<li>
<a rel="nofollow" class="external text" href="http://www.miracleas.com/BAARF/">BAARF</a><sup title="最后检查状态：404">[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">失效链接</a> 2020-08-04 ⓘ]</sup> including <i><a rel="nofollow" class="external text" href="http://www.miracleas.com/BAARF/RAID5_versus_RAID10.txt">Why should I not use RAID 5?</a><sup title="最后检查状态：404">[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">失效链接</a> 2020-08-04 ⓘ]</sup></i><sup>[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">dead link</a> 2018-03-10]</sup> by Art S. Kagel</li>
<li>
<a rel="nofollow" class="external text" href="http://www.linux-mag.com/id/7924/">Introduction to RAID</a>, <a rel="nofollow" class="external text" href="http://www.linux-mag.com/id/7931/">Nested-RAID: RAID-5 and RAID-6 Based Configurations</a>, <a rel="nofollow" class="external text" href="http://www.linux-mag.com/id/7928/">Intro to Nested-RAID: RAID-01 and RAID-10</a>, and <a rel="nofollow" class="external text" href="http://www.linux-mag.com/id/7932/">Nested-RAID: The Triple Lindy</a> in Linux Magazine</li>
<li><a rel="nofollow" class="external text" href="http://www.cyberciti.biz/tips/linux-raid-increase-resync-rebuild-speed.html">HowTo: Speed Up Linux Software Raid Building And Re-syncing</a></li>
<li><a rel="nofollow" class="external text" href="http://fomori.org/blog/?p=94">RAID5-Server to hold all your data</a></li>
<li><a href="https://en.wikipedia.org/wiki/Non-RAID_drive_architectures" class="extiw" title="wikipedia:Non-RAID drive architectures">Wikipedia:Non-RAID drive architectures</a></li>
</ul>
<p><b>mdadm</b>
</p>
<ul>
<li>
<a rel="nofollow" class="external text" href="http://anonscm.debian.org/gitweb/?p=pkg-mdadm/mdadm.git;a=blob_plain;f=debian/FAQ;hb=HEAD">Debian mdadm FAQ</a><sup title="最后检查状态：404">[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">失效链接</a> 2020-08-04 ⓘ]</sup>
</li>
<li><a rel="nofollow" class="external text" href="https://www.kernel.org/pub/linux/utils/raid/mdadm/">mdadm source code</a></li>
<li>
<a rel="nofollow" class="external text" href="http://www.linux-mag.com/id/7939/">Software RAID on Linux with mdadm</a> in Linux Magazine</li>
<li><a href="https://en.wikipedia.org/wiki/mdadm" class="extiw" title="wikipedia:mdadm">Wikipedia - mdadm</a></li>
</ul>
<p><b>Forum threads</b>
</p>
<ul>
<li><a rel="nofollow" class="external text" href="http://forums.overclockers.com.au/showthread.php?t=865333">Raid Performance Improvements with bitmaps</a></li>
<li><a rel="nofollow" class="external text" href="https://bbs.archlinux.org/viewtopic.php?id=125445">GRUB and GRUB2</a></li>
<li><a rel="nofollow" class="external text" href="https://bbs.archlinux.org/viewtopic.php?id=123698">Can't install grub2 on software RAID</a></li>
<li><a rel="nofollow" class="external text" href="http://forums.gentoo.org/viewtopic-t-888624-start-0.html">Use RAID metadata 1.2 in boot and root partition</a></li>
</ul>
<p><b>RAID with encryption</b>
</p>
<ul><li>
<a rel="nofollow" class="external text" href="http://www.shimari.com/dm-crypt-on-raid/">Linux/Fedora: Encrypt /home and swap over RAID with dm-crypt</a> by Justin Wells</li></ul>
</div>
</div>
<div id="catlinks" class="catlinks" data-mw="interface">
<div id="mw-normal-catlinks" class="mw-normal-catlinks">
<a href="../Special:Categories.html" title="Special:Categories">Category</a>: <ul><li><a href="../zh-CN/Category:Storage_virtualization.html" title="Category:Storage virtualization (简体中文)">Storage virtualization (简体中文)</a></li></ul>
</div>
<div id="mw-hidden-catlinks" class="mw-hidden-catlinks mw-hidden-cats-hidden">Hidden categories: <ul>
<li><a href="../en/Category:Pages_or_sections_flagged_with_Template:Style.html" title="Category:Pages or sections flagged with Template:Style">Pages or sections flagged with Template:Style</a></li>
<li><a href="../en/Category:Pages_with_broken_package_links.html" title="Category:Pages with broken package links">Pages with broken package links</a></li>
<li><a href="../en/Category:Pages_or_sections_flagged_with_Template:Out_of_date.html" title="Category:Pages or sections flagged with Template:Out of date">Pages or sections flagged with Template:Out of date</a></li>
<li><a href="../en/Category:Pages_with_dead_links.html" title="Category:Pages with dead links">Pages with dead links</a></li>
</ul>
</div>
</div>
	</div>
</div>

<footer id="footer" class="mw-footer" role="contentinfo" style="margin: 0">
	<ul id="footer-info">
		<li>Retrieved from "<a dir="ltr" href="https://wiki.archlinux.org/index.php?title=RAID_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)&amp;oldid=645778">https://wiki.archlinux.org/index.php?title=RAID_(简体中文)&amp;oldid=645778</a>"</li>
		<li id="footer-info-lastmod"> This page was last edited on 16 December 2020, at 20:25.</li>
		<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3 or later</a> unless otherwise noted.</li>
	<br>
</ul>
	<ul id="footer-places">
		<li id="footer-places-privacy"><a href="../en/ArchWiki:Privacy_policy.html" title="ArchWiki:Privacy policy">Privacy policy</a></li>
		<li id="footer-places-about"><a href="../en/ArchWiki:About.html" title="ArchWiki:About">About ArchWiki</a></li>
		<li id="footer-places-disclaimer"><a href="../en/ArchWiki:General_disclaimer.html" title="ArchWiki:General disclaimer">Disclaimers</a></li>
	</ul>
	<ul id="footer-icons" class="noprint">
		<li id="footer-copyrightico">
	</ul>
	<div style="clear: both;"></div>
</footer>



</body>
</html>
