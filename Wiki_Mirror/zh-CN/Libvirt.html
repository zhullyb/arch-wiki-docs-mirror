<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<title>libvirt (简体中文) - ArchWiki</title>
<link rel="stylesheet" href="../ArchWikiOffline.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<meta name="generator" content="MediaWiki 1.35.0">
<meta name="referrer" content="no-referrer-when-downgrade">
<meta name="robots" content="noindex,follow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="/opensearch_desc.php" title="ArchWiki (en)">
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.archlinux.org/api.php?action=rsd">
<link rel="license" href="http://www.gnu.org/copyleft/fdl.html">
<link rel="alternate" type="application/atom+xml" title="ArchWiki Atom feed" href="/index.php?title=Special:RecentChanges&amp;feed=atom">
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Libvirt_简体中文 rootpage-Libvirt_简体中文 skin-vector action-view skin-vector-legacy">
<div id="content" class="mw-body" role="main" style="margin: 0">
	<a id="top"></a>
	<div id="siteNotice" class="mw-body-content"></div>
	<div class="mw-indicators mw-body-content">
	</div>
	<h1 id="firstHeading" class="firstHeading" lang="en">libvirt (简体中文)</h1>
	<div id="bodyContent" class="mw-body-content">
		<div id="siteSub" class="noprint">From ArchWiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="#searchInput">Jump to search</a>
		<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<div class="warningbox">The printable version is no longer supported and may have rendering errors. Please update your browser bookmarks and please use the default browser print function instead.</div>
<div class="mw-parser-output">
<div class="archwiki-template-meta-related-articles-start">
<p>Related articles</p>
<ul>
<li><a href="/title/PCI_passthrough_via_OVMF" title="PCI passthrough via OVMF">PCI passthrough via OVMF</a></li>
<li><a href="/title/Category:Hypervisors" title="Category:Hypervisors">Category:Hypervisors</a></li>
</ul>
</div>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>翻译状态：</strong>本文是 <a href="/title/Libvirt" title="Libvirt">Libvirt</a> 的<a href="/title/ArchWiki:Translation_Team_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" title="ArchWiki:Translation Team (简体中文)">翻译</a>。上次翻译日期：2018-07-10。如果英文版本有所<a rel="nofollow" class="external text" href="https://wiki.archlinux.org/index.php?title=Libvirt&amp;diff=0&amp;oldid=528864">更改</a>，则您可以帮助同步翻译。</div>
<p>Libvirt 是一组软件的汇集，提供了管理虚拟机和其它虚拟化功能（如：存储和网络接口等）的便利途径。这些软件包括：一个长期稳定的 C 语言 API、一个守护进程（libvirtd）和一个命令行工具（virsh）。Libvirt 的主要目标是提供一个单一途径以管理多种不同虚拟化方案以及虚拟化主机，包括：<a href="/title/QEMU" title="QEMU">KVM/QEMU</a>，<a href="/title/Xen" title="Xen">Xen</a>，<a href="/title/LXC" class="mw-redirect" title="LXC">LXC</a>，<a rel="nofollow" class="external text" href="https://openvz.org">OpenVZ</a> 或 <a href="/title/VirtualBox" title="VirtualBox">VirtualBox</a> <a href="/title/Category:Hypervisors" title="Category:Hypervisors">hypervisors</a> （<a rel="nofollow" class="external text" href="https://libvirt.org/drivers.html">详见这里</a>）。
</p>
<p>Libvirt 的一些主要功能如下：
</p>
<ul>
<li>
<b>VM management（虚拟机管理）</b>：各种虚拟机生命周期的操作，如：启动、停止、暂停、保存、恢复和迁移等；多种不同类型设备的热插拔操作，包括磁盘、网络接口、内存、CPU等。</li>
<li>
<b>Remote machine support（支持远程连接）</b>：Libvirt 的所有功能都可以在运行着 libvirt 守护进程的机器上执行，包括远程机器。通过最简便且无需额外配置的 SSH 协议，远程连接可支持多种网络连接方式。</li>
<li>
<b>Storage management（存储管理）</b>：任何运行 libvirt 守护进程的主机都可以用于管理多种类型的存储：创建多种类型的文件镜像（qcow2，vmdk，raw，...），挂载 NFS 共享，枚举现有 LVM 卷组，创建新的 LVM 卷组和逻辑卷，对裸磁盘设备分区，挂载 iSCSI 共享，以及更多......</li>
<li>
<b>Network interface management（网络接口管理）</b>：任何运行 libvirt 守护进程的主机都可以用于管理物理的和逻辑的网络接口，枚举现有接口，配置（和创建）接口、桥接、VLAN、端口绑定。</li>
<li>
<b>Virtual NAT and Route based networking（虚拟 NAT 和基于路由的网络）</b>：任何运行 libvirt 守护进程的主机都可以管理和创建虚拟网络。Libvirt 虚拟网络使用防火墙规则实现一个路由器，为虚拟机提供到主机网络的透明访问。</li>
</ul>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading">
<input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none"><div class="toctitle" lang="en" dir="ltr">
<h2 id="mw-toc-heading">Contents</h2>
<span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span>
</div>
<ul>
<li class="toclevel-1 tocsection-1">
<a href="#%E5%AE%89%E8%A3%85"><span class="tocnumber">1</span> <span class="toctext">安装</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="tocnumber">1.1</span> <span class="toctext">服务端</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="tocnumber">1.2</span> <span class="toctext">客户端</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4">
<a href="#%E9%85%8D%E7%BD%AE"><span class="tocnumber">2</span> <span class="toctext">配置</span></a>
<ul>
<li class="toclevel-2 tocsection-5">
<a href="#%E8%AE%BE%E7%BD%AE%E6%8E%88%E6%9D%83"><span class="tocnumber">2.1</span> <span class="toctext">设置授权</span></a>
<ul>
<li class="toclevel-3 tocsection-6"><a href="#%E4%BD%BF%E7%94%A8_polkit"><span class="tocnumber">2.1.1</span> <span class="toctext">使用 polkit</span></a></li>
<li class="toclevel-3 tocsection-7"><a href="#%E5%9F%BA%E4%BA%8E%E6%96%87%E4%BB%B6%E7%9A%84%E6%9D%83%E9%99%90%E6%8E%88%E6%9D%83"><span class="tocnumber">2.1.2</span> <span class="toctext">基于文件的权限授权</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-8"><a href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="tocnumber">2.2</span> <span class="toctext">守护进程</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#%E9%9D%9E%E5%8A%A0%E5%AF%86%E7%9A%84_TCP/IP_sockets"><span class="tocnumber">2.3</span> <span class="toctext">非加密的 TCP/IP sockets</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#%E7%94%A8%E4%B8%BB%E6%9C%BA%E5%90%8D%E8%AE%BF%E9%97%AE%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="tocnumber">2.4</span> <span class="toctext">用主机名访问虚拟机</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-11"><a href="#%E6%B5%8B%E8%AF%95"><span class="tocnumber">3</span> <span class="toctext">测试</span></a></li>
<li class="toclevel-1 tocsection-12">
<a href="#%E7%AE%A1%E7%90%86"><span class="tocnumber">4</span> <span class="toctext">管理</span></a>
<ul>
<li class="toclevel-2 tocsection-13"><a href="#virsh"><span class="tocnumber">4.1</span> <span class="toctext">virsh</span></a></li>
<li class="toclevel-2 tocsection-14">
<a href="#%E5%AD%98%E5%82%A8%E6%B1%A0"><span class="tocnumber">4.2</span> <span class="toctext">存储池</span></a>
<ul>
<li class="toclevel-3 tocsection-15"><a href="#%E7%94%A8_virsh_%E6%96%B0%E5%BB%BA%E5%AD%98%E5%82%A8%E6%B1%A0"><span class="tocnumber">4.2.1</span> <span class="toctext">用 virsh 新建存储池</span></a></li>
<li class="toclevel-3 tocsection-16"><a href="#%E7%94%A8_virt-manager_%E6%96%B0%E5%BB%BA%E5%AD%98%E5%82%A8%E6%B1%A0"><span class="tocnumber">4.2.2</span> <span class="toctext">用 virt-manager 新建存储池</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-17">
<a href="#%E5%AD%98%E5%82%A8%E5%8D%B7"><span class="tocnumber">4.3</span> <span class="toctext">存储卷</span></a>
<ul>
<li class="toclevel-3 tocsection-18"><a href="#%E7%94%A8_virsh_%E6%96%B0%E5%BB%BA%E5%8D%B7"><span class="tocnumber">4.3.1</span> <span class="toctext">用 virsh 新建卷</span></a></li>
<li class="toclevel-3 tocsection-19"><a href="#virt-manager_%E5%90%8E%E5%A4%87%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B%E7%9A%84_bug"><span class="tocnumber">4.3.2</span> <span class="toctext">virt-manager 后备存储类型的 bug</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-20">
<a href="#%E5%9F%9F"><span class="tocnumber">4.4</span> <span class="toctext">域</span></a>
<ul>
<li class="toclevel-3 tocsection-21"><a href="#%E7%94%A8_virt-install_%E6%96%B0%E5%BB%BA%E5%9F%9F"><span class="tocnumber">4.4.1</span> <span class="toctext">用 virt-install 新建域</span></a></li>
<li class="toclevel-3 tocsection-22"><a href="#%E7%94%A8_virt-manager_%E6%96%B0%E5%BB%BA%E5%9F%9F"><span class="tocnumber">4.4.2</span> <span class="toctext">用 virt-manager 新建域</span></a></li>
<li class="toclevel-3 tocsection-23"><a href="#%E7%AE%A1%E7%90%86%E5%9F%9F"><span class="tocnumber">4.4.3</span> <span class="toctext">管理域</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-24">
<a href="#%E7%BD%91%E7%BB%9C"><span class="tocnumber">4.5</span> <span class="toctext">网络</span></a>
<ul>
<li class="toclevel-3 tocsection-25"><a href="#IPv6"><span class="tocnumber">4.5.1</span> <span class="toctext">IPv6</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-26">
<a href="#%E5%BF%AB%E7%85%A7"><span class="tocnumber">4.6</span> <span class="toctext">快照</span></a>
<ul>
<li class="toclevel-3 tocsection-27"><a href="#%E5%88%9B%E5%BB%BA%E5%BF%AB%E7%85%A7"><span class="tocnumber">4.6.1</span> <span class="toctext">创建快照</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-28"><a href="#%E5%85%B6%E4%BB%96%E7%AE%A1%E7%90%86%E6%93%8D%E4%BD%9C"><span class="tocnumber">4.7</span> <span class="toctext">其他管理操作</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-29"><a href="#Python_%E8%BF%9E%E6%8E%A5%E4%BB%A3%E7%A0%81"><span class="tocnumber">5</span> <span class="toctext">Python 连接代码</span></a></li>
<li class="toclevel-1 tocsection-30"><a href="#UEFI_%E6%94%AF%E6%8C%81"><span class="tocnumber">6</span> <span class="toctext">UEFI 支持</span></a></li>
<li class="toclevel-1 tocsection-31"><a href="#PulseAudio"><span class="tocnumber">7</span> <span class="toctext">PulseAudio</span></a></li>
<li class="toclevel-1 tocsection-32"><a href="#%E5%8F%82%E9%98%85"><span class="tocnumber">8</span> <span class="toctext">参阅</span></a></li>
</ul>
</div>

<h2>
<span id=".E5.AE.89.E8.A3.85"></span><span class="mw-headline" id="安装">安装</span>
</h2>
<p>基于守护进程/客户端的架构的 libvirt 只需要安装在需要要实现虚拟化的机器上。注意，服务器和客户端可以是相同的物理机器。
</p>
<h3>
<span id=".E6.9C.8D.E5.8A.A1.E7.AB.AF"></span><span class="mw-headline" id="服务端">服务端</span>
</h3>
<p><a href="/title/%E5%AE%89%E8%A3%85" class="mw-redirect" title="安装">安装</a> <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=libvirt">libvirt</a></span> 以及至少一个虚拟运行环境（hypervisor）：
</p>
<ul><li>
<a rel="nofollow" class="external text" href="https://libvirt.org/drvqemu.html">libvirt 的 KVM/QEMU 驱动</a> 是 <i>libvirt</i> 的首选驱动，如果 KVM 功能已 <a href="/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%90%AF%E7%94%A8_KVM" title="QEMU (简体中文)">启用</a>，则支持全虚拟化和硬件加速的客户机。详见 <a href="/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" title="QEMU (简体中文)">QEMU</a>。</li></ul>
<ul><li>其他<a rel="nofollow" class="external text" href="https://libvirt.org/drivers.html">受支持的虚拟运行环境</a>，包括 <a href="/title/LXC" class="mw-redirect" title="LXC">LXC</a>、<a href="/title/VirtualBox" title="VirtualBox">VirtualBox</a> 和 <a href="/title/Xen" title="Xen">Xen</a>。请参见它们各自的安装说明。
<ul>
<li>
<a rel="nofollow" class="external text" href="https://libvirt.org/drvlxc.html">Libvirt 的 LXC 驱动</a> 并不依赖 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=lxc">lxc</a></span> 提供的用户空间工具。因此，即便需要使用这个驱动也并不是必须安装该工具。</li>
<li>Libvirt 能支持 <a href="/title/Xen" title="Xen">Xen</a>，但默认未内建支持。需要用 <a href="/title/ABS" class="mw-redirect" title="ABS">ABS</a> 编辑 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=libvirt">libvirt</a></span> 的 <a href="/title/PKGBUILD" title="PKGBUILD">PKGBUILD</a> ，去掉 <code>--without-xen</code> 选项后重新构建（built）libvirt。由于 VirtualBox 尚未正式支持 Xen，所以应当用 <code>--without-vbox</code> 选项替换前述选项。</li>
</ul>
</li></ul>
<p>对于网络连接，安装这些包：
</p>
<ul>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/ebtables/">ebtables</a></span><sup><small>AUR</small></sup> <b>和</b> <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=dnsmasq">dnsmasq</a></span> 用于 <a rel="nofollow" class="external text" href="https://wiki.libvirt.org/page/VirtualNetworking#The_default_configuration">默认的</a> NAT/DHCP网络</li>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=bridge-utils">bridge-utils</a></span> 用于桥接网络</li>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=openbsd-netcat">openbsd-netcat</a></span> 通过 <a href="/title/SSH" class="mw-redirect" title="SSH">SSH</a> 远程管理</li>
</ul>
<h3>
<span id=".E5.AE.A2.E6.88.B7.E7.AB.AF"></span><span class="mw-headline" id="客户端">客户端</span>
</h3>
<p>客户端是用于管理和访问虚拟机的用户界面。
</p>
<ul><li>
<b>virsh</b> — <i>virsh</i> 是用于管理和配置域（虚拟机）的命令行程序。</li></ul>
<dl><dd>
<a rel="nofollow" class="external free" href="https://libvirt.org/">https://libvirt.org/</a> || <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=libvirt">libvirt</a></span>
</dd></dl>
<ul><li>
<b><a href="https://en.wikipedia.org/wiki/GNOME_Boxes" class="extiw" title="wikipedia:GNOME Boxes">GNOME Boxes</a></b> — 简单的 GNOME 3 程序，可以访问远程虚拟系统。</li></ul>
<dl><dd>
<a rel="nofollow" class="external free" href="https://wiki.gnome.org/Apps/Boxes">https://wiki.gnome.org/Apps/Boxes</a> || <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=gnome-boxes">gnome-boxes</a></span>
</dd></dl>
<ul><li>
<b>Libvirt Sandbox</b> — 应用程序沙箱工具包。</li></ul>
<dl><dd>
<a rel="nofollow" class="external free" href="https://sandbox.libvirt.org/">https://sandbox.libvirt.org/</a> || <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/libvirt-sandbox/">libvirt-sandbox</a></span><sup><small>AUR</small></sup>
</dd></dl>
<ul><li>
<b>Remote Viewer</b> — 简单的远程访问工具。</li></ul>
<dl><dd>
<a rel="nofollow" class="external free" href="https://virt-manager.org/">https://virt-manager.org/</a> || <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=virt-viewer">virt-viewer</a></span>
</dd></dl>
<ul><li>
<b>Qt VirtManager</b> — 管理虚拟机的Qt程序。</li></ul>
<dl><dd>
<a rel="nofollow" class="external free" href="https://github.com/F1ash/qt-virt-manager">https://github.com/F1ash/qt-virt-manager</a> || <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/qt-virt-manager/">qt-virt-manager</a></span><sup><small>AUR</small></sup>
</dd></dl>
<ul><li>
<b><a href="https://en.wikipedia.org/wiki/Virtual_Machine_Manager" class="extiw" title="wikipedia:Virtual Machine Manager">Virtual Machine Manager</a></b> — 使用libvirt对KVM，Xen，LXC进行管理的图形化工具。</li></ul>
<dl><dd>
<a rel="nofollow" class="external free" href="https://virt-manager.org/">https://virt-manager.org/</a> || <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=virt-manager">virt-manager</a></span>
</dd></dl>
<p>兼容 libvirt 的软件列表见 <a rel="nofollow" class="external text" href="https://libvirt.org/apps.html">这里</a>.
</p>
<h2>
<span id=".E9.85.8D.E7.BD.AE"></span><span class="mw-headline" id="配置">配置</span>
</h2>
<p>对于<i><b>系统</b></i> 级别的管理任务（如：全局配置和镜像<i>卷</i> 位置），libvirt 要求至少要<a href="#%E8%AE%BE%E7%BD%AE%E6%8E%88%E6%9D%83">设置授权</a>和<a href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B">启动守护进程</a>。
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 对于用户<i><b>会话</b></i> 级别的管理任务，守护进程的安装和设置<i>不是</i> 必须的。授权总是仅限本地，前台程序将启动一个 <b>libvirtd</b> 守护进程的本地实例。</div>
<h3>
<span id=".E8.AE.BE.E7.BD.AE.E6.8E.88.E6.9D.83"></span><span class="mw-headline" id="设置授权">设置授权</span>
</h3>
<p>来自 <a rel="nofollow" class="external text" href="https://libvirt.org/auth.html#ACL_server_config">libvirt：连接授权</a>：
</p>
<dl><dd>Libvirt 守护进程允许管理员分别为客户端连接的每个网络 socket 选择不同授权机制。这主要是通过 libvirt 守护进程的主配置文件 <code>/etc/libvirt/libvirtd.conf</code> 来实现的。每个 libvirt socket 可以有独立的授权机制配置。目前的可选项有 <code>none</code>、<code>polkit</code> 和 <code>sasl</code>。</dd></dl>
<p>由于  <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=libvirt">libvirt</a></span> 在安装时将把 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=polkit">polkit</a></span> 作为依赖一并安装，所以 <a href="#%E4%BD%BF%E7%94%A8_polkit">polkit</a> 通常是 <code>unix_sock_auth</code> 参数的默认值（<a rel="nofollow" class="external text" href="https://libvirt.org/auth.html#ACL_server_polkit">来源</a>）。但<a href="#%E5%9F%BA%E4%BA%8E%E6%96%87%E4%BB%B6%E7%9A%84%E6%9D%83%E9%99%90%E6%8E%88%E6%9D%83">基于文件的权限</a>仍然可用。
</p>
<h4>
<span id=".E4.BD.BF.E7.94.A8_polkit"></span><span class="mw-headline" id="使用_polkit">使用 polkit</span>
</h4>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 为使 <code>polkit</code> 认证工作正常，应该重启一次系统。</div>
<p><i>libvirt</i> 守护进程在 polkit 策略配置文件（<code>/usr/share/polkit-1/actions/org.libvirt.unix.policy</code>）中提供了两种<b>策略</b>（参阅：<a href="/title/Polkit_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E6%93%8D%E4%BD%9C" title="Polkit (简体中文)">Polkit (简体中文)#操作</a>）：
</p>
<ul>
<li>
<code>org.libvirt.unix.manage</code> 面向完全的管理访问（读写模式后台 socket），以及</li>
<li>
<code>org.libvirt.unix.monitor</code> 面向仅监视察看访问（只读 socket）。</li>
</ul>
<p>默认的面向读写模式后台 socket 的策略将请求认证为管理员。这点类似于 <a href="/title/Sudo_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" title="Sudo (简体中文)">sudo</a> 认证，但它并不要求客户应用最终以 root 身份运行。默认策略下也仍然允许任何应用连接到只读 socket。
</p>
<p>Arch Linux 默认 <code>wheel</code> 组的所有用户都是管理员身份：定义于 <code>/etc/polkit-1/rules.d/50-default.rules</code>（参阅：<a href="/title/Polkit_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E7%AE%A1%E7%90%86%E5%91%98%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81" title="Polkit (简体中文)">Polkit (简体中文)#管理员身份认证</a>）。这样就不必新建组和规则文件。 <b>如果用户是 <code>wheel</code> 组的成员</b>：只要连接到了读写模式 socket（例如通过 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=virt-manager">virt-manager</a></span>）就会被提示输入该用户的口令。
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 要求口令的提示由系统中的认证代理给出（参阅：<a href="/title/Polkit_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E7%BB%84%E4%BB%B6" title="Polkit (简体中文)">Polkit (简体中文)#身份认证组件</a>）。文本控制台默认的认证代理是 <code>pkttyagent</code> 它可能因工作不正常而导致各种问题。</div>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>提示：</strong> 如果要配置无口令认证，参阅 <a href="/title/Polkit_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E8%B7%B3%E8%BF%87%E5%8F%A3%E4%BB%A4%E6%8F%90%E7%A4%BA" title="Polkit (简体中文)">Polkit (简体中文)#跳过口令提示</a>。</div>
<p>从 libvirt 1.2.16 版开始（提案见：<a rel="nofollow" class="external autonumber" href="https://libvirt.org/git/?p=libvirt.git;a=commit;h=e94979e901517af9fdde358d7b7c92cc055dd50c">[1]</a>），<code>libvirt</code> 组的成员用户默认可以无口令访问读写模式 socket。最简单的判断方法就是看 libvirt 组是否存在并且用户是否该组成员。
你可能想要修改授权以读写模式访问socket的组，例如，你想授权<code>kvm</code>组，可创建下面的文件：
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/polkit-1/rules.d/50-libvirt.rules</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">/* Allow users in kvm group to manage the libvirt daemon without authentication（允许 kvm 组的用户管理 libvirt 而无需认证）
*/
polkit.addRule(function(action, subject) {
    if (action.id == "org.libvirt.unix.manage" &amp;&amp;
        subject.isInGroup("kvm")) {
            return polkit.Result.YES;
    }
});
</pre>
<p>然后<a href="/title/Users_and_groups_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%85%B6%E4%BB%96%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E7%A4%BA%E4%BE%8B" title="Users and groups (简体中文)">添加用户</a>到 <code>kvm</code> 组并重新登录。<i>kvm</i> 也可以是任何其它存在的组并且用户是该组成员（详阅<a href="/title/%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84" class="mw-redirect" title="用户和用户组">用户和用户组</a>）。
</p>
<p>修改组之后不要忘记重新登录才能生效。
</p>
<h4>
<span id=".E5.9F.BA.E4.BA.8E.E6.96.87.E4.BB.B6.E7.9A.84.E6.9D.83.E9.99.90.E6.8E.88.E6.9D.83"></span><span class="mw-headline" id="基于文件的权限授权">基于文件的权限授权</span>
</h4>
<p>为了给 <i>libvirt</i> 组用户定义基于文件的权限以管理虚拟机，取消下列行的注释：
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/libvirt/libvirtd.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">#unix_sock_group = "libvirt"
#unix_sock_ro_perms = "0777"  # set to 0770 to deny non-group libvirt users
#unix_sock_rw_perms = "0770"
#auth_unix_ro = "none"
#auth_unix_rw = "none"
</pre>
<p>有些资料提到可以通过改变某些特定 libvirt 目录的权限以简化管理。需要记住的是：包更新时，这些变更会丢失。如要修改这些系统目录的权限，需要 root 用户权限。
</p>
<h3>
<span id=".E5.AE.88.E6.8A.A4.E8.BF.9B.E7.A8.8B"></span><span class="mw-headline" id="守护进程">守护进程</span>
</h3>
<p><code>libvirtd.service</code> 和 <code>virtlogd.service</code>这两个服务单元都要<a href="/title/Systemd_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E4%BD%BF%E7%94%A8%E5%8D%95%E5%85%83" title="Systemd (简体中文)">启动</a>。可以把 <code>libvirtd.service</code> 设置为<a href="/title/Enable" class="mw-redirect" title="Enable">启用</a>，这时系统将同时启用 <code>virtlogd.service</code> 和 <code>virtlockd.socket</code> 两个服务<a href="/title/Systemd_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E4%BD%BF%E7%94%A8%E5%8D%95%E5%85%83" title="Systemd (简体中文)">单元</a>，因此后二者不必再设置为<b>启用</b>。
</p>
<h3>
<span id=".E9.9D.9E.E5.8A.A0.E5.AF.86.E7.9A.84_TCP.2FIP_sockets"></span><span class="mw-headline" id="非加密的_TCP/IP_sockets">非加密的 TCP/IP sockets</span>
</h3>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>警告：</strong> 这种方法常用于在可信网络中快速连接远程域做协助。这是<i><b>最不安全</b></i> 的连接方式，应当<i>仅仅</i> 用于测试或用于安全、私密和可信的网络环境。这时 SASL 没有启用，所以所有的 TCP 通讯都是明文传输。在正式的应用场合应当<i>始终</i> 启用 SASL。</div>
<p>编辑 <code>/etc/libvirt/libvirtd.conf</code>：
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/libvirt/libvirtd.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">listen_tls = 0
listen_tcp = 1
auth_tcp="none"
</pre>
<p>同时需要编辑<code>/etc/conf.d/libvirtd</code>以在监听模式下启动服务：
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/conf.d/libvirtd</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">LIBVIRTD_ARGS="--listen"</pre>
<h3>
<span id=".E7.94.A8.E4.B8.BB.E6.9C.BA.E5.90.8D.E8.AE.BF.E9.97.AE.E8.99.9A.E6.8B.9F.E6.9C.BA"></span><span class="mw-headline" id="用主机名访问虚拟机">用主机名访问虚拟机</span>
</h3>
<p>在非隔离的、桥接的网络中从宿主机访问客户机，可以通过启用 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=libvirt">libvirt</a></span> 提供的 <code>libvirt</code> NSS 模块实现。
</p>
<p>编辑 <code>/etc/nsswitch.conf</code>：
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/nsswitch.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">hosts: files libvirt dns myhostname
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong>  <code>ping</code> 和 <code>ssh</code> 这类命令用于虚拟机主机名可以正常工作，但 <code>host</code> 和 <code>nslookup</code> 这类命令可能会失败或产生非预期结果，因后者依赖 DNS 。应改用 <code>getent hosts &lt;vm-hostname&gt;</code> 命令。</div>
<h2>
<span id=".E6.B5.8B.E8.AF.95"></span><span class="mw-headline" id="测试">测试</span>
</h2>
<p>测试 libvirt 在<i>系统</i>级工作是否正常：
</p>
<pre>$ virsh -c qemu:///system
</pre>
<p>测试 libvirt 在用户<i>会话</i>级工作是否正常：
</p>
<pre>$ virsh -c qemu:///session
</pre>
<h2>
<span id=".E7.AE.A1.E7.90.86"></span><span class="mw-headline" id="管理">管理</span>
</h2>
<p>绝大部分的 libvirt 管理可以通过三个工具实现：<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=virt-manager">virt-manager</a></span>（图形界面）、<code>virsh</code> 和 <code>guestfish</code>（它是 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=libguestfs">libguestfs</a></span> 的一部分）。
</p>
<h3><span class="mw-headline" id="virsh">virsh</span></h3>
<p>Visrsh 用于管理客户<i>域</i>（虚拟机），在脚本式虚拟化管理环境中工作良好。由于需要通过通讯管道与虚拟运行环境通讯，绝大部分 virsh 命令需要管理员权限。尽管如此，一些典型的管理操作如域的创建、运行等也可以像VirtualBox 那样以普通用户身份执行。
</p>
<p>Virsh 允许带命令行选项执行。如果不带则进入其内置的交互式终端：<code>virsh</code>。交互式终端支持 tab 键命令补全。
</p>
<p>从命令行执行：
</p>
<pre>$ virsh [可选项] &lt;命令&gt; [参数]...
</pre>
<p>在交互式终端里运行：
</p>
<pre>virsh # &lt;命令&gt; [参数]...
</pre>
<p>帮助也是可用的：
</p>
<pre>$ virsh help [option*] or [group-keyword*]
</pre>
<h3>
<span id=".E5.AD.98.E5.82.A8.E6.B1.A0"></span><span class="mw-headline" id="存储池">存储池</span>
</h3>
<p>存储池是指保存<i>卷</i>的位置。Libvirt 中<i>卷</i>的定义相当于其他系统中<i>虚拟磁盘</i>或<i>虚拟机镜像</i>的概念。存储池应该是一个目录、一个网络文件系统或一个分区（此处包括 <a href="/title/LVM_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" title="LVM (简体中文)">LVM</a>）。存储池可以在活动与不活动之间切换，可以为其分配存储空间。
</p>
<p>在<i>系统</i>级别，默认被激活的存储池是 <code>/var/lib/libvirt/images/</code>；在用户<i>会话</i>级别，<code>virt-manager</code> 将存储池创建在 <code>$HOME/VirtualMachines</code> 目录。
</p>
<p>列出活动和不活动的存储池的命令：
</p>
<pre>$ virsh pool-list --all
</pre>
<h4>
<span id=".E7.94.A8_virsh_.E6.96.B0.E5.BB.BA.E5.AD.98.E5.82.A8.E6.B1.A0"></span><span class="mw-headline" id="用_virsh_新建存储池">用 virsh 新建存储池</span>
</h4>
<p>以下示例为<i>添加</i>存储池、目录和 LVM 卷的方法：
</p>
<pre>$ virsh pool-define-as name type [source-host] [source-path] [source-dev] [source-name] [&lt;target&gt;] [--source-format format]
$ virsh pool-define-as <i>poolname</i> dir - - - - /home/<i>username</i>/.local/libvirt/images
$ virsh pool-define-as <i>poolname</i> fs - -  <i>/dev/vg0/images</i> - <i>mntpoint</i>
</pre>
<p>上述示例仅仅定义了存储池的信息，下面创建它：
</p>
<pre>$ virsh pool-build     <i>poolname</i>
$ virsh pool-start     <i>poolname</i>
$ virsh pool-autostart <i>poolname</i>
</pre>
<p>删除它的命令：
</p>
<pre>$ virsh pool-undefine  <i>poolname</i>
</pre>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>提示：</strong> 对于 LVM 存储池而言：
<ul>
<li>最佳实践是仅把一个卷组分配给一个存储池。</li>
<li>请为存储池选择一个与 LVM 卷组不同的名字。否则当存储池被删除时，该卷组也将被删除。</li>
</ul>
</div>
<h4>
<span id=".E7.94.A8_virt-manager_.E6.96.B0.E5.BB.BA.E5.AD.98.E5.82.A8.E6.B1.A0"></span><span class="mw-headline" id="用_virt-manager_新建存储池">用 virt-manager 新建存储池</span>
</h4>
<p>首先，连接到虚拟运行环境（例如QEMU/KVM的系统/用户会话）。然后，右键点击一个<b>连接</b>（例如<b>QEMU/KVM</b>）选择<b>详情</b>，切换到<b>存储</b>选项卡，点击左下角的<b>+</b>，按照向导操作。
</p>
<h3>
<span id=".E5.AD.98.E5.82.A8.E5.8D.B7"></span><span class="mw-headline" id="存储卷">存储卷</span>
</h3>
<p>存储池被创建之后，就可以在存储池中创建存储卷。如果你想新建一个域（虚拟机），那么这一步可以跳过，因为这一步可以在创建域的过程中完成。
</p>
<h4>
<span id=".E7.94.A8_virsh_.E6.96.B0.E5.BB.BA.E5.8D.B7"></span><span class="mw-headline" id="用_virsh_新建卷">用 virsh 新建卷</span>
</h4>
<p>新建卷，列出卷，变更卷大小，删除卷：
</p>
<pre>$ virsh vol-create-as      <i>poolname</i> <i>volumename</i> 10GiB --format aw|bochs|raw|qcow|qcow2|vmdk
$ virsh vol-upload  --pool <i>poolname</i> <i>volumename</i> <i>volumepath</i>
$ virsh vol-list           <i>poolname</i>
$ virsh vol-resize  --pool <i>poolname</i> <i>volumename</i> 12GiB
$ virsh vol-delete  --pool <i>poolname</i> <i>volumename</i>
$ virsh vol-dumpxml --pool <i>poolname</i> <i>volumename</i>  # for details.
</pre>
<h4>
<span id="virt-manager_.E5.90.8E.E5.A4.87.E5.AD.98.E5.82.A8.E7.B1.BB.E5.9E.8B.E7.9A.84_bug"></span><span class="mw-headline" id="virt-manager_后备存储类型的_bug">virt-manager 后备存储类型的 bug</span>
</h4>
<p>在较新版本的<code>virt-manager</code>中，你可以在创建新磁盘的时候选择一个后备存储（backing store）。这个功能很实用，它可以在你创建新域的时候选择基础镜像，从而节省你的时间和磁盘空间。目前的<code>virt-manager</code>有一个bug(<a rel="nofollow" class="external free" href="https://bugzilla.redhat.com/show_bug.cgi?id=1235406)%EF%BC%8C%E5%AF%BC%E8%87%B4">https://bugzilla.redhat.com/show_bug.cgi?id=1235406)，导致</a><code>qcow2</code>格式的后备存储被错误的当做<code>raw</code>格式。这会让虚拟机无法读取后备存储，从而使这个功能完全失效。
这里有一个临时的解决办法。<code>qemu-img</code>长期以来都可以直接实现这个功能。如果你想在这个bug修复之前为新域创建一个后备存储，你可以使用下面的命令。
</p>
<pre>$ qemu-img create -f qcow2 -o backing_file=&lt;path to backing image&gt;,backing_fmt=qcow2 &lt;disk name&gt; &lt;disk size&gt;
</pre>
<p>之后你就可以以此镜像为基础创建新域，后备存储将被用作一个CoW（<b>C</b>opy <b>o</b>n <b>W</b>rite，写时复制）卷，节省你的时间和磁盘空间。
</p>
<h3>
<span id=".E5.9F.9F"></span><span class="mw-headline" id="域">域</span>
</h3>
<p>虚拟机被称作<b>“域”</b>。如果你想在命令行下操作，使用<code>virsh</code>列出，创建，暂停，关闭……域。<code>virt-viewer</code>可以用来查看使用<code>virsh</code>启动的域。域的创建通常以图形化的<code>virt-manager</code>或者命令行下的<code>virt-install</code>（一个命令行工具，是<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=virt-install">virt-install</a></span>包的一部分）完成。
创建新域通常需要安装媒介，例如存储池中的<code>iso</code>文件或是直接从光驱安装。
</p>
<p>列出活动的和不活动的域：
</p>
<pre># virsh list --all
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> <a href="/title/SELinux" title="SELinux">SELinux</a>有内置策略使在<code>/var/lib/libvirt/images/</code>中的卷可以被访问。如果你使用SELinux并且在卷方面有问题，确保卷位于该目录，其他存储池标记正常。</div>
<h4>
<span id=".E7.94.A8_virt-install_.E6.96.B0.E5.BB.BA.E5.9F.9F"></span><span class="mw-headline" id="用_virt-install_新建域">用 virt-install 新建域</span>
</h4>
<p>对于很详细的域（虚拟机）配置，可以<a href="#%E7%94%A8_virt-manager_%E6%96%B0%E5%BB%BA%E5%9F%9F">#用 virt-manager 新建域</a>更简单地完成。但是，基础配置同样可以用<code>virt-install</code>完成并且同样运行顺利。至少要配置<code>--name</code>, <code>--memory</code>, 存储(<code>--disk</code>, <code>--filesystem</code>,或<code>--nodisks</code>),和安装方法（通常来说是<code>.iso</code>文件或CD）。查看<span class="plainlinks archwiki-template-man" title="$ man 1 virt-install"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/virt-install.1">virt-install(1)</a></span>得到未列出的选项和更多的详情。
</p>
<p>Arch Linux（两个虚拟CPU，1 GiB内存，qcow2，用户网络）:
</p>
<pre>$ virt-install  \
  --name arch-linux_testing \
  --memory 1024             \ 
  --vcpus=2,maxvcpus=4      \
  --cpu host                \
  --cdrom $HOME/Downloads/arch-linux_install.iso \
  --disk size=2,format=raw  \
  --network user            \
  --virt-type kvm
</pre>
<p>Fedora testing (Xen, 非默认池,无默认控制台):
</p>
<pre>$ virt-install  \
  --connect xen:///     \
  --name fedora-testing \
  --memory 2048         \
  --vcpus=2             \
  --cpu=host            \
  --cdrom /tmp/fedora20_x84-64.iso      \
  --os-type=linux --os-variant=fedora20 \
  --disk pool=testing,size=4            \
  --network bridge=br0                  \
  --graphics=vnc                        \
  --noautoconsole
$ virt-viewer --connect xen:/// fedora-testing
</pre>
<p>Windows:
</p>
<pre>$ virt-install \
  --name=windows7           \
  --memory 2048             \
  --cdrom /dev/sr0          \
  --os-variant=win7         \
  --disk /mnt/storage/domains/windows7.qcow2,size=20GiB \
  --network network=vm-net  \
  --graphics spice
</pre>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>提示：</strong> 运行<code>osinfo-query --fields=name,short-id,version os</code>来获得<code>--os-variant</code>的参数，这可以帮助定制域的一些规格。然而<code>--memory</code>和<code>--disk</code>是必须被输入的。如果需要查看这些规格，可以看看<code>/usr/share/libosinfo/db/oses/<i>os</i>.xml</code>（译注：此处可能已过时）。在安装后，推荐安装<a rel="nofollow" class="external text" href="https://www.spice-space.org/download.html">Spice Guest Tools</a>，其中包括<a rel="nofollow" class="external text" href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Virtualization_Host_Configuration_and_Guest_Installation_Guide/form-Virtualization_Host_Configuration_and_Guest_Installation_Guide-Para_virtualized_drivers-Mounting_the_image_with_virt_manager.html">VirtIO驱动</a>。Windows的VirtIO网络驱动可以在<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/virtio-win/">virtio-win</a></span><sup><small>AUR</small></sup>得到。要使用VirtIO，需要在虚拟机<code>.xml</code>配置中使用<code>&lt;model type='virtio' /&gt;</code>更多的信息可以参考<a href="/title/QEMU#Preparing_a_Windows_guest" title="QEMU">QEMU</a>页面.</div>
<p>导入现有的卷：
</p>
<pre>$ virt-install  \
  --name demo  \
  --memory 512 \
  --disk /home/user/VMs/mydisk.img \
  --import
</pre>
<h4>
<span id=".E7.94.A8_virt-manager_.E6.96.B0.E5.BB.BA.E5.9F.9F"></span><span class="mw-headline" id="用_virt-manager_新建域">用 virt-manager 新建域</span>
</h4>
<p>首先，连接到虚拟运行环境（例如 QEMU/KVM <i>system</i> 或用户 <i>session</i>，在连接上右击并选择 <i>新建</i>，然后跟随向导完成。
</p>
<ul>
<li>在<b>第四步</b>中取消选中<b>立即分配全部虚拟磁盘空间</b>会加快创建过程并节省实际虚拟磁盘空间占用；<b>然而</b>，这将导致将来花费额外的磁盘整理时间。</li>
<li>在<b>第五步</b>中打开<b>高级选项</b>并确认<b>虚拟化类型</b>设为 <b>kvm</b>（这通常是首选模式）。如果要求附加的硬件配置，选中<b>安装前定制</b>选项。</li>
</ul>
<h4>
<span id=".E7.AE.A1.E7.90.86.E5.9F.9F"></span><span class="mw-headline" id="管理域">管理域</span>
</h4>
<p>启动域：
</p>
<pre>$ virsh start <i>domain</i>
$ virt-viewer --connect qemu:///session <i>domain</i>
</pre>
<p>正常关闭域；强制关闭域:
</p>
<pre>$ virsh shutdown <i>domain</i>
$ virsh destroy  <i>domain</i>
</pre>
<p>在libvirtd启动时自动启动域:
</p>
<pre>$ virsh autostart <i>domain</i>
$ virsh autostart <i>domain</i> --disable
</pre>
<p>在宿主机关闭时自动关闭域:
</p>
<dl><dd>使用<code>libvirt-guests.service</code>Systemd服务，运行中的域可以在宿主机关闭时自动挂起/关闭。同时这个服务还可以让挂起/休眠的域在宿主机启动的时候自动恢复。查看<code>/etc/conf.d/libvirt-guests</code>并设置相关选项。</dd></dl>
<p>编辑一个域的XML配置：
</p>
<pre>$ virsh edit <i>domain</i>
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 直接被QEMU启动的虚拟机不被libvirt管理。</div>
<h3>
<span id=".E7.BD.91.E7.BB.9C"></span><span class="mw-headline" id="网络">网络</span>
</h3>
<p><a rel="nofollow" class="external text" href="https://jamielinux.com/docs/libvirt-networking-handbook/">这里</a>是有关 libvirt 网络的一个正宗的概述。
</p>
<p>默认情况下，当 <code>libvirtd</code> 服务启动后，即创建了一个名为 <i>default</i> 的 NAT 网桥与外部网络联通（仅 IPv4）。对于其他的网络连接需求，可创建下列四种类型的网络以连接到虚拟机：
</p>
<ul>
<li>bridge — 这是一个虚拟设备，它通过一个物理接口直接共享数据。使用场景为：宿主机有 <i>静态</i> 网络、不需与其它域连接、要占用全部进出流量，并且域运行于 <i>系统</i> 层级。有关如何在现有默认网桥时增加另一个网桥的方法，请参阅 <a href="/title/%E7%BD%91%E6%A1%A5" class="mw-redirect" title="网桥">网桥</a>。网桥创建后，需要将它指定到相应客户机的 <code>.xml</code> 配置文件中。</li>
<li>network — 这是一个虚拟网络，它可以与其它虚拟机共用。使用场景为：宿主机有 <i>动态</i> 网络（例如：NetworkManager）或使用无线网络。</li>
<li>macvtap — 直接连接到宿主机的一个物理网络接口。</li>
<li>user — 本地网络，仅用于用户 <i>会话</i>。</li>
</ul>
<p>绝大多数用户都可以通过 <code>virsh</code> 的各种可选项创建具有各种功能的网络，一般来说比通过 GUI 程序（像 <code>virt-manager</code> 之类）更容易做到。也可以按 <a href="#%E7%94%A8_virt-install_%E6%96%B0%E5%BB%BA%E5%9F%9F">#用 virt-install 新建域</a> 所述实现。
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> libvirt 通过  <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=dnsmasq">dnsmasq</a></span> 处理 DHCP 和 DNS 请求，以启动每个虚拟网络的不同实例。也会为特定的路由添加 iptables 规则并启用 <code>ip_forward</code> 内核参数。这也意味着宿主机上已运行的dnsmasq并不是libvirt所必须的（并可能干扰到libvirt的dnsmasq实例）。</div>
<h4><span class="mw-headline" id="IPv6">IPv6</span></h4>
<p>当通过任何配置工具试图添加IPv6地址时，你可能会遇到这样的错误：
</p>
<pre>Check the host setup: enabling IPv6 forwarding with RA routes without accept_ra set to 2 is likely to cause routes loss. Interfaces to look at: <i>eth0</i>
</pre>
<p>要修复这个问题，创建如下的文件（将<code>eth0</code>改为你的物理接口的名称），并且重新启动系统。
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/sysctl.d/libvirt-bridge.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">net.ipv6.conf.eth0.accept_ra = 2</pre>
<h3>
<span id=".E5.BF.AB.E7.85.A7"></span><span class="mw-headline" id="快照">快照</span>
</h3>
<p>快照保存某一时刻域的磁盘、内存和设备状态以供将来使用。快照有很多用处，例如在进行可能的破坏性操作时保存一份干净的域状态。快照使用唯一名称进行标识。
</p>
<p>快照保存在卷之中，卷必须为qcow2或raw格式。快照使用增量存储，所以并不会占用很多空间。
</p>
<h4>
<span id=".E5.88.9B.E5.BB.BA.E5.BF.AB.E7.85.A7"></span><span class="mw-headline" id="创建快照">创建快照</span>
</h4>
<div class="noprint archwiki-template-message">
<p><a href="/title/File:Tango-view-refresh-red.png" class="image"><img alt="Tango-view-refresh-red.png" src="../File:Tango-view-refresh-red.png" decoding="async" width="48" height="48"></a><b>This article or section is out of date.</b><a href="/title/File:Tango-view-refresh-red.png" class="image"><img alt="Tango-view-refresh-red.png" src="../File:Tango-view-refresh-red.png" decoding="async" width="48" height="48"></a></p>
<div>
<b>Reason:</b> Some of this data appears to be dated. (Discuss in <a rel="nofollow" class="external text" href="https://wiki.archlinux.org/title/Talk:Libvirt_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Talk:Libvirt (简体中文)#</a>)</div>
</div>
<p>Once a snapshot is taken it is saved as a new block device and the original snapshot is taken offline.  Snapshots can be chosen from and also merged into another (even without shutting down the domain).
</p>
<p>Print a running domain's volumes (running domains can be printed with <code>virsh list</code>):
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># virsh domblklist <i>domain</i></pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;"> Target     Source
 ------------------------------------------------
 vda        /vms/domain.img
</pre>
<p>To see a volume's physical properties:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># qemu-img info /vms/domain.img</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;"> image: /vms/domain.img
 file format: qcow2
 virtual size: 50G (53687091200 bytes)
 disk size: 2.1G
 cluster_size: 65536
</pre>
<p>Create a disk-only snapshot (the option <code>--atomic</code> will prevent the volume from being modified if snapshot creation fails):
</p>
<pre># virsh snapshot-create-as <i>domain</i> snapshot1 --disk-only --atomic
</pre>
<p>List snapshots:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># virsh snapshot-list <i>domain</i></pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;"> Name                 Creation Time             State
 ------------------------------------------------------------
 snapshot1           2012-10-21 17:12:57 -0700 disk-snapshot
</pre>
<p>One can they copy the original image with <code>cp --sparse=true</code> or <code>rsync -S</code> and then merge the the original back into snapshot:
</p>
<pre># virsh blockpull --domain <i>domain</i> --path /vms/<i>domain</i>.snapshot1
</pre>
<p><code>domain.snapshot1</code> becomes a new volume.  After this is done the original volume (<code>domain.img</code> and snapshot metadata can be deleted.   The <code>virsh blockcommit</code> would work opposite to <code>blockpull</code> but it seems to be currently under development (including <code>snapshot-revert feature</code>, scheduled to be released sometime next year.
</p>
<h3>
<span id=".E5.85.B6.E4.BB.96.E7.AE.A1.E7.90.86.E6.93.8D.E4.BD.9C"></span><span class="mw-headline" id="其他管理操作">其他管理操作</span>
</h3>
<p>连接到非默认的虚拟运行环境：
</p>
<pre>$ virsh --connect xen:///
virsh # uri
xen:///
</pre>
<p>通过SSH连接到QEMU虚拟运行环境，并且以相同方式登录：
</p>
<pre>$ virsh --connect qemu+ssh://<i>username</i>@<i>host</i>/system
$ LIBVIRT_DEBUG=1 virsh --connect qemu+ssh://<i>username</i>@<i>host</i>/system
</pre>
<p>通过SSH连接到一个图形控制台：
</p>
<pre>$ virt-viewer  --connect qemu+ssh://<i>username</i>@<i>host</i>/system <i>domain</i>
$ virt-manager --connect qemu+ssh://<i>username</i>@<i>host</i>/system <i>domain</i>
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 如果你在连接RHEL服务器（或其他不是Arch的服务器）时出现问题，尝试这两个解决方案：<a rel="nofollow" class="external text" href="https://bugs.archlinux.org/task/30748">FS#30748</a><a rel="nofollow" class="external text" href="https://bugs.archlinux.org/task/22068">FS#22068</a>.</div>
<p>连接到VirtualBox（libvirt对VirtualBox的支持尚不稳定，可能会导致libvirtd崩溃）:
</p>
<pre>$ virsh --connect vbox:///system
</pre>
<p>网络配置:
</p>
<pre>$ virsh -c qemu:///system net-list --all
$ virsh -c qemu:///system net-dumpxml default
</pre>
<h2>
<span id="Python_.E8.BF.9E.E6.8E.A5.E4.BB.A3.E7.A0.81"></span><span class="mw-headline" id="Python_连接代码">Python 连接代码</span>
</h2>
<p><span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=libvirt-python">libvirt-python</a></span>软件包提供了一个<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=python2">python2</a></span>API，位于<code>/usr/lib/python2.7/site-packages/libvirt.py</code>。
</p>
<p>一般的例子在<code>/usr/share/doc/libvirt-python-<i>your_libvirt_version</i>/examples/</code>给出。
</p>
<p>一个<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu">qemu</a></span>和<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=openssh">openssh</a></span>的例子（非官方）:
</p>
<pre>#! /usr/bin/env python2
# -*- coding: utf-8 -*-
import socket
import sys
import libvirt
if (__name__ == "__main__"):
   conn = libvirt.open("qemu+ssh://xxx/system")
   print "Trying to find node on xxx"
   domains = conn.listDomainsID()
   for domainID in domains:
       domConnect = conn.lookupByID(domainID)
       if domConnect.name() == 'xxx-node':
           print "Found shared node on xxx with ID " + str(domainID)
           domServ = domConnect
           break
</pre>
<h2>
<span id="UEFI_.E6.94.AF.E6.8C.81"></span><span class="mw-headline" id="UEFI_支持">UEFI 支持</span>
</h2>
<p>Libvirt 可以通过 qemu 和 <a rel="nofollow" class="external text" href="https://github.com/tianocore/edk2">OVMF</a> 来支持 UEFI 虚拟机。
安装 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=edk2-ovmf">edk2-ovmf</a></span> 。
添加下面的内容到 <code>/etc/libvirt/qemu.conf</code> 。
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/libvirt/qemu.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">nvram = [
    "/usr/share/ovmf/x64/OVMF_CODE.fd:/usr/share/ovmf/x64/OVMF_VARS.fd"
]

</pre>
<ul><li>重启 <code>libvirtd</code>
</li></ul>
<p>现在你可以创建一个 UEFI 虚拟机了。 你可以通过 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=virt-manager">virt-manager</a></span> 来创建。当你进行到向导的最后一步时：
</p>
<ul>
<li>勾选<b>在安装前自定义配置</b>，之后点击<b>完成</b>。</li>
<li>在<b>概况</b>屏幕, 将固件改为'UEFI x86_64'。</li>
<li>点击<b>开始安装</b>
</li>
<li>在启动屏幕，你需要使用linuxefi命令来启动安装程序，并且你需要在系统中运行efibootmgr验证确实运行在UEFI模式下。</li>
</ul>
<p>参考<a rel="nofollow" class="external text" href="https://fedoraproject.org/wiki/Using_UEFI_with_QEMU">fedora wiki</a>获得更多信息。
</p>
<h2><span class="mw-headline" id="PulseAudio">PulseAudio</span></h2>
<p>PulseAudio守护进程通常在你的普通用户下运行，并且只接受来自相同用户的连接。然而libvirt默认使用root运行QEMU。为了让QEMU在普通用户下运行，编辑<code>/etc/libvirt/qemu.conf</code>并将<code>user</code>设置为你的用户名。
</p>
<pre>user = "dave"
</pre>
<p>你同样需要告诉QEMU使用PulseAudio后端并识别要连接的服务器，首先将QEMU命名空间添加到你的域。
编辑域的<code>.xml</code>文件（使用<code>virsh edit domain</code>），将<code>domain type</code>行改为：
</p>
<pre>&lt;domain type='kvm' xmlns:qemu='<a rel="nofollow" class="external free" href="http://libvirt.org/schemas/domain/qemu/1.0'">http://libvirt.org/schemas/domain/qemu/1.0'</a><sup title="最后检查状态：404">[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">失效链接</a> 2020-08-02 ⓘ]</sup>&gt;
</pre>
<p>并且加入如下的配置（在最后一个<code>&lt;/devices&gt;</code>之后，<code>&lt;/domain&gt;</code>之前）：
</p>
<pre> &lt;qemu:commandline&gt;
   &lt;qemu:env name='QEMU_AUDIO_DRV' value='pa'/&gt;
   &lt;qemu:env name='QEMU_PA_SERVER' value='/run/user/1000/pulse/native'/&gt;
 &lt;/qemu:commandline&gt;
</pre>
<p><code>1000</code>是你的用户ID，如果必要的话改为你的用户ID。
</p>
<h2>
<span id=".E5.8F.82.E9.98.85"></span><span class="mw-headline" id="参阅">参阅</span>
</h2>
<ul>
<li><a rel="nofollow" class="external text" href="https://libvirt.org/drvqemu.html">libvirt 网站</a></li>
<li><a rel="nofollow" class="external text" href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Virtualization_Deployment_and_Administration_Guide/index.html">Red Hat 虚拟化部署和管理指南</a></li>
<li><a rel="nofollow" class="external text" href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Virtualization_Tuning_and_Optimization_Guide/index.html">Red Hat 虚拟化调优指南</a></li>
<li><a rel="nofollow" class="external text" href="https://docs.slackware.com/howtos:general_admin:kvm_libvirt">Slackware KVM and libvirt</a></li>
<li><a rel="nofollow" class="external text" href="https://www-01.ibm.com/support/knowledgecenter/linuxonibm/liaat/liaatkvm.htm">IBM KVM</a></li>
<li><a rel="nofollow" class="external text" href="https://jamielinux.com/docs/libvirt-networking-handbook/">libvirt 网络手册</a></li>
</ul>
</div>
</div>
<div id="catlinks" class="catlinks" data-mw="interface">
<div id="mw-normal-catlinks" class="mw-normal-catlinks">
<a href="/title/Special:Categories" title="Special:Categories">Category</a>: <ul><li><a href="/title/Category:Virtualization_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" title="Category:Virtualization (简体中文)">Virtualization (简体中文)</a></li></ul>
</div>
<div id="mw-hidden-catlinks" class="mw-hidden-catlinks mw-hidden-cats-hidden">Hidden categories: <ul>
<li><a href="/title/Category:Pages_or_sections_flagged_with_Template:Out_of_date" title="Category:Pages or sections flagged with Template:Out of date">Pages or sections flagged with Template:Out of date</a></li>
<li><a href="/title/Category:Pages_with_dead_links" title="Category:Pages with dead links">Pages with dead links</a></li>
</ul>
</div>
</div>
	</div>
</div>

<footer id="footer" class="mw-footer" role="contentinfo" style="margin: 0">
	<ul id="footer-info">
		<li>Retrieved from "<a dir="ltr" href="https://wiki.archlinux.org/index.php?title=Libvirt_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)&amp;oldid=670299">https://wiki.archlinux.org/index.php?title=Libvirt_(简体中文)&amp;oldid=670299</a>"</li>
		<li id="footer-info-lastmod"> This page was last edited on 10 May 2021, at 19:13.</li>
		<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3 or later</a> unless otherwise noted.</li>
	<br>
</ul>
	<ul id="footer-places">
		<li id="footer-places-privacy"><a href="/title/ArchWiki:Privacy_policy" title="ArchWiki:Privacy policy">Privacy policy</a></li>
		<li id="footer-places-about"><a href="/title/ArchWiki:About" title="ArchWiki:About">About ArchWiki</a></li>
		<li id="footer-places-disclaimer"><a href="/title/ArchWiki:General_disclaimer" title="ArchWiki:General disclaimer">Disclaimers</a></li>
	</ul>
	<ul id="footer-icons" class="noprint">
		<li id="footer-copyrightico">
	</ul>
	<div style="clear: both;"></div>
</footer>



</body>
</html>
