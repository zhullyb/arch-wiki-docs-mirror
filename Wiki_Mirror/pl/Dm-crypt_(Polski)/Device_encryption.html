<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<title>Dm-crypt (Polski)/Device encryption (Polski) - ArchWiki</title>
<link rel="stylesheet" href="../../ArchWikiOffline.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<meta name="generator" content="MediaWiki 1.35.0">
<meta name="robots" content="noindex,follow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="/opensearch_desc.php" title="ArchWiki (en)">
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.archlinux.org/api.php?action=rsd">
<link rel="license" href="http://www.gnu.org/copyleft/fdl.html">
<link rel="alternate" type="application/atom+xml" title="ArchWiki Atom feed" href="/index.php?title=Special:RecentChanges&amp;feed=atom">
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Dm-crypt_Polski_Device_encryption_Polski rootpage-Dm-crypt_Polski skin-vector action-view skin-vector-legacy">
<div id="content" class="mw-body" role="main" style="margin: 0">
	<a id="top"></a>
	<div id="siteNotice" class="mw-body-content"></div>
	<div class="mw-indicators mw-body-content">
	</div>
	<h1 id="firstHeading" class="firstHeading" lang="en">Dm-crypt (Polski)/Device encryption (Polski)</h1>
	<div id="bodyContent" class="mw-body-content">
		<div id="siteSub" class="noprint">From ArchWiki</div>
		<div id="contentSub"><span class="subpages">&lt; <a href="../../pl/Dm-crypt.html" title="Dm-crypt (Polski)">Dm-crypt (Polski)</a></span></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="#searchInput">Jump to search</a>
		<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<div class="warningbox">The printable version is no longer supported and may have rendering errors. Please update your browser bookmarks and please use the default browser print function instead.</div>
<div class="mw-parser-output">
<p>W tej sekcji opisano sposób ręcznego wykorzystania <i>dm-crypt</i> z linii poleceń w celu zaszyfrowania systemu.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading">
<input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none"><div class="toctitle" lang="en" dir="ltr">
<h2 id="mw-toc-heading">Contents</h2>
<span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span>
</div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Przygotowanie"><span class="tocnumber">1</span> <span class="toctext">Przygotowanie</span></a></li>
<li class="toclevel-1 tocsection-2">
<a href="#Wykorzystanie_Cryptsetup"><span class="tocnumber">2</span> <span class="toctext">Wykorzystanie Cryptsetup</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Has%C5%82a_i_klucze_programu_Cryptsetup"><span class="tocnumber">2.1</span> <span class="toctext">Hasła i klucze programu Cryptsetup</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4">
<a href="#Opcje_szyfrowania_z_dm-crypt"><span class="tocnumber">3</span> <span class="toctext">Opcje szyfrowania z dm-crypt</span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="#Opcje_szyfrowania_dla_trybu_LUKS"><span class="tocnumber">3.1</span> <span class="toctext">Opcje szyfrowania dla trybu LUKS</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Opcje_szyfrowania_dla_trybu_zwyk%C5%82ego"><span class="tocnumber">3.2</span> <span class="toctext">Opcje szyfrowania dla trybu zwykłego</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-7">
<a href="#Szyfrowanie_urz%C4%85dze%C5%84_za_pomoc%C4%85_cryptsetup"><span class="tocnumber">4</span> <span class="toctext">Szyfrowanie urządzeń za pomocą cryptsetup</span></a>
<ul>
<li class="toclevel-2 tocsection-8">
<a href="#Szyfrowanie_urz%C4%85dze%C5%84_w_trybie_LUKS"><span class="tocnumber">4.1</span> <span class="toctext">Szyfrowanie urządzeń w trybie LUKS</span></a>
<ul>
<li class="toclevel-3 tocsection-9">
<a href="#Formatowanie_partycji_LUKS"><span class="tocnumber">4.1.1</span> <span class="toctext">Formatowanie partycji LUKS</span></a>
<ul>
<li class="toclevel-4 tocsection-10"><a href="#U%C5%BCywanie_LUKS_do_formatowania_partycji_za_pomoc%C4%85_pliku_kluczy"><span class="tocnumber">4.1.1.1</span> <span class="toctext">Używanie LUKS do formatowania partycji za pomocą pliku kluczy</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-11"><a href="#Odblokowywanie_/_mapowanie_partycji_LUKS_za_pomoc%C4%85_device_mapper"><span class="tocnumber">4.1.2</span> <span class="toctext">Odblokowywanie / mapowanie partycji LUKS za pomocą device mapper</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-12"><a href="#Szyfrowanie_urz%C4%85dze%C5%84_w_trybie_zwyk%C5%82ym"><span class="tocnumber">4.2</span> <span class="toctext">Szyfrowanie urządzeń w trybie zwykłym</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-13">
<a href="#Dzia%C5%82ania_Cryptsetup_specyficzne_dla_LUKS"><span class="tocnumber">5</span> <span class="toctext">Działania Cryptsetup specyficzne dla LUKS</span></a>
<ul>
<li class="toclevel-2 tocsection-14">
<a href="#Zarz%C4%85dzanie_kluczami"><span class="tocnumber">5.1</span> <span class="toctext">Zarządzanie kluczami</span></a>
<ul>
<li class="toclevel-3 tocsection-15"><a href="#Dodawanie_kluczy_LUKS"><span class="tocnumber">5.1.1</span> <span class="toctext">Dodawanie kluczy LUKS</span></a></li>
<li class="toclevel-3 tocsection-16"><a href="#Usuwanie_kluczy_LUKS"><span class="tocnumber">5.1.2</span> <span class="toctext">Usuwanie kluczy LUKS</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-17">
<a href="#Kopia_zapasowa_i_przywracanie"><span class="tocnumber">5.2</span> <span class="toctext">Kopia zapasowa i przywracanie</span></a>
<ul>
<li class="toclevel-3 tocsection-18"><a href="#Kopia_zapasowa_za_pomoc%C4%85_cryptsetup"><span class="tocnumber">5.2.1</span> <span class="toctext">Kopia zapasowa za pomocą cryptsetup</span></a></li>
<li class="toclevel-3 tocsection-19"><a href="#Przywracanie_za_pomoc%C4%85_cryptsetup"><span class="tocnumber">5.2.2</span> <span class="toctext">Przywracanie za pomocą cryptsetup</span></a></li>
<li class="toclevel-3 tocsection-20"><a href="#R%C4%99czne_tworzenie_kopii_zapasowych_i_przywracanie"><span class="tocnumber">5.2.3</span> <span class="toctext">Ręczne tworzenie kopii zapasowych i przywracanie</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-21">
<a href="#Ponowne_szyfrowanie_urz%C4%85dze%C5%84"><span class="tocnumber">5.3</span> <span class="toctext">Ponowne szyfrowanie urządzeń</span></a>
<ul>
<li class="toclevel-3 tocsection-22"><a href="#Zaszyfruj_niezaszyfrowany_system_plik%C3%B3w"><span class="tocnumber">5.3.1</span> <span class="toctext">Zaszyfruj niezaszyfrowany system plików</span></a></li>
<li class="toclevel-3 tocsection-23"><a href="#Ponowne_szyfrowanie_istniej%C4%85cej_partycji_LUKS"><span class="tocnumber">5.3.2</span> <span class="toctext">Ponowne szyfrowanie istniejącej partycji LUKS</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-24">
<a href="#Zmiana_rozmiaru_zaszyfrowanych_urz%C4%85dze%C5%84"><span class="tocnumber">6</span> <span class="toctext">Zmiana rozmiaru zaszyfrowanych urządzeń</span></a>
<ul>
<li class="toclevel-2 tocsection-25"><a href="#Loopback_filesystem"><span class="tocnumber">6.1</span> <span class="toctext">Loopback filesystem</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-26">
<a href="#Pliki_kluczy"><span class="tocnumber">7</span> <span class="toctext">Pliki kluczy</span></a>
<ul>
<li class="toclevel-2 tocsection-27">
<a href="#Rodzaje_plik%C3%B3w_kluczy"><span class="tocnumber">7.1</span> <span class="toctext">Rodzaje plików kluczy</span></a>
<ul>
<li class="toclevel-3 tocsection-28"><a href="#has%C5%82o"><span class="tocnumber">7.1.1</span> <span class="toctext">hasło</span></a></li>
<li class="toclevel-3 tocsection-29"><a href="#randomtext"><span class="tocnumber">7.1.2</span> <span class="toctext">randomtext</span></a></li>
<li class="toclevel-3 tocsection-30"><a href="#binary"><span class="tocnumber">7.1.3</span> <span class="toctext">binary</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-31">
<a href="#Tworzenie_pliku_kluczy_z_losowymi_znakami"><span class="tocnumber">7.2</span> <span class="toctext">Tworzenie pliku kluczy z losowymi znakami</span></a>
<ul>
<li class="toclevel-3 tocsection-32">
<a href="#Przechowywanie_pliku_klucza_w_systemie_plik%C3%B3w"><span class="tocnumber">7.2.1</span> <span class="toctext">Przechowywanie pliku klucza w systemie plików</span></a>
<ul>
<li class="toclevel-4 tocsection-33"><a href="#Bezpieczne_nadpisywanie_zapisanych_plik%C3%B3w_kluczy"><span class="tocnumber">7.2.1.1</span> <span class="toctext">Bezpieczne nadpisywanie zapisanych plików kluczy</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-34"><a href="#Przechowywanie_pliku_kluczy_w_ramfs"><span class="tocnumber">7.2.2</span> <span class="toctext">Przechowywanie pliku kluczy w ramfs</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-35"><a href="#Konfigurowanie_LUKS_do_korzystania_z_pliku_klucza"><span class="tocnumber">7.3</span> <span class="toctext">Konfigurowanie LUKS do korzystania z pliku klucza</span></a></li>
<li class="toclevel-2 tocsection-36"><a href="#R%C4%99czne_odblokowywanie_partycji_przy_u%C5%BCyciu_pliku_klucza"><span class="tocnumber">7.4</span> <span class="toctext">Ręczne odblokowywanie partycji przy użyciu pliku klucza</span></a></li>
<li class="toclevel-2 tocsection-37"><a href="#Odblokowywanie_dodatkowej_partycji_podczas_rozruchu"><span class="tocnumber">7.5</span> <span class="toctext">Odblokowywanie dodatkowej partycji podczas rozruchu</span></a></li>
<li class="toclevel-2 tocsection-38">
<a href="#Odblokowywanie_partycji_g%C5%82%C3%B3wnej_podczas_rozruchu"><span class="tocnumber">7.6</span> <span class="toctext">Odblokowywanie partycji głównej podczas rozruchu</span></a>
<ul>
<li class="toclevel-3 tocsection-39">
<a href="#Z_plikiem_kluczy_przechowywanym_na_zewn%C4%99trznym_no%C5%9Bniku"><span class="tocnumber">7.6.1</span> <span class="toctext">Z plikiem kluczy przechowywanym na zewnętrznym nośniku</span></a>
<ul>
<li class="toclevel-4 tocsection-40"><a href="#Konfigurowanie_mkinitcpio"><span class="tocnumber">7.6.1.1</span> <span class="toctext">Konfigurowanie mkinitcpio</span></a></li>
<li class="toclevel-4 tocsection-41"><a href="#Konfigurowanie_parametr%C3%B3w_j%C4%85dra"><span class="tocnumber">7.6.1.2</span> <span class="toctext">Konfigurowanie parametrów jądra</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-42"><a href="#Z_plikiem_kluczy_osadzonym_w_initramfs"><span class="tocnumber">7.6.2</span> <span class="toctext">Z plikiem kluczy osadzonym w initramfs</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>

<h2><span class="mw-headline" id="Przygotowanie">Przygotowanie</span></h2>
<p>Przed użyciem <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=cryptsetup">cryptsetup</a></span>, zawsze upewnij się, że <code>dm_crypt</code> <a href="../../en/Kernel_module.html" title="Kernel module">kernel module</a> jest załadowany.
</p>
<h2><span class="mw-headline" id="Wykorzystanie_Cryptsetup">Wykorzystanie Cryptsetup</span></h2>
<p>Cryptsetup to narzędzie linii poleceń służące do komunikacji z <i>dm-crypt</i> w celu tworzenia, uzyskiwania dostępu i zarządzania zaszyfrowanymi urządzeniami. Narzędzie zostało później rozszerzone, aby obsługiwać różne typy szyfrowania, które opierają się na narzędziu do mapowania jądra systemu Linux i modułach kryptograficznych. Najbardziej znaczącym rozszerzeniem było rozszerzenie Linux Unified Key Setup (LUKS), które przechowuje wszystkie potrzebne informacje dotyczące instalacji dla dm-crypt na samym dysku i streszcza zarządzanie partycjami i kluczami w celu poprawy łatwości użytkowania. Urządzenia dostępne za pośrednictwem urządzenia odwzorowującego urządzenia nazywane są urządzeniami blokowymi. W celu uzyskania dalszych informacji zobacz <a href="../../en/Data-at-rest_encryption.html#Block_device_encryption" class="mw-redirect" title="Disk encryption">Disk encryption#Block device encryption</a>. 
</p>
<p>Narzędzie jest używane w następujący sposób:
</p>
<pre># cryptsetup &lt;OPTIONS&gt; &lt;action&gt; &lt;action-specific-options&gt; &lt;device&gt; &lt;dmname&gt;
</pre>
<p>Ma skompilowane ustawienia domyślne dla opcji i trybu szyfrowania, które będą używane, jeśli w wierszu poleceń nie określono żadnych innych. Spójrz na
</p>
<pre>$ cryptsetup --help 
</pre>
<p>który wyświetla opcje, akcje i domyślne parametry trybów szyfrowania w tej kolejności. Pełną listę opcji można znaleźć na stronie podręcznika. Ponieważ różne parametry są wymagane lub opcjonalne, w zależności od trybu szyfrowania i działania, poniższe sekcje wskazują dalej różnice. Szyfrowanie Blockdevice jest szybkie, ale szybkość też ma duże znaczenie. Ponieważ zmiana szyfru urządzenia blokowego po konfiguracji jest trudna, ważne jest wcześniejsze sprawdzenie wydajności dm-crypt dla poszczególnych parametrów:
</p>
<pre>$ cryptsetup benchmark 
</pre>
<p>może podać wskazówki dotyczące wyboru algorytmu i klucza przed instalacją. Jeśli niektóre szyfry AES przodują ze znacznie większą przepustowością, to prawdopodobnie jest sprzętową obsługą CPU.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Tip:</strong> Podczas uczenia możesz chcieć ćwiczyć szyfrowanie wirtualnego dysku twardego na <a href="../../en/Category:Virtualization.html" class="mw-redirect" title="Virtual machine">maszynie wirtualnej</a>.</div>
<h3>
<span id="Has.C5.82a_i_klucze_programu_Cryptsetup"></span><span class="mw-headline" id="Hasła_i_klucze_programu_Cryptsetup">Hasła i klucze programu Cryptsetup</span>
</h3>
<p>Szyfrowane urządzenie blokowe jest chronione kluczem. Klucz jest albo:
</p>
<ul>
<li>hasło: patrz <a href="../../en/Security.html#Passwords" title="Security">Security#Passwords</a>.</li>
<li>plik klucza, patrz <a href="#Keyfiles">#Keyfiles</a><sup>[<a href="../../en/Help:Procedures.html#Fix_broken_section_links" title="Help:Procedures">broken link</a>: invalid section]</sup>.</li>
</ul>
<p>Oba typy kluczy mają domyślne maksymalne rozmiary: hasła mogą zawierać do 512 znaków, a pliki kluczy do 8192 kiB.
</p>
<p>Ważnym rozróżnieniem LUKS na uwagę w tym momencie jest to, że klucz jest używany do odblokowania klucza głównego urządzenia zaszyfrowanego LUKS i może być zmieniony przy dostępie root. Inne tryby szyfrowania nie obsługują zmiany klucza po konfiguracji, ponieważ nie używają klucza głównego do szyfrowania. Zobacz <a href="../../en/Data-at-rest_encryption.html#Block_device_encryption" class="mw-redirect" title="Disk encryption">Disk encryption#Block device encryption</a> po dalsze szczegóły.
</p>
<h2><span class="mw-headline" id="Opcje_szyfrowania_z_dm-crypt">Opcje szyfrowania z dm-crypt</span></h2>
<p><i>Cryptsetup</i> obsługuje różne tryby operacyjne szyfrowania do użycia z <i>dm-crypt</i>. Najczęstszym (i domyślnym) jest
</p>
<ul><li><code>--type luks</code></li></ul>
<p>Pozostałe są
</p>
<ul>
<li>
<code>--type plain</code> do używania w trybie zwykłym dm-crypt,</li>
<li>
<code>--type loopaes</code> dla loopaes tryb Legacy, i</li>
<li>
<code>--type tcrypt</code> dla <a href="../../en/TrueCrypt.html" title="TrueCrypt">TrueCrypt</a> tryb zgodności.</li>
</ul>
<p>Podstawowe opcje kryptograficzne dla szyfrów i skrótów są dostępne dla wszystkich trybów i polegają na kryptograficznych funkcjach jądra. Wszystkie ładowane w czasie wykonywania można wyświetlać za pomocą
</p>
<pre>$ less /proc/crypto 
</pre>
<p>i są dostępne do użycia jako opcje. Jeśli lista jest krótka, należy wykonać test porównawczy <code>cryptsetup benchmark</code>, który uruchomi ładowanie dostępnych modułów.
</p>
<p>Poniżej przedstawiono opcje szyfrowania dla dwóch pierwszych trybów. Zwróć uwagę, że tabele zawierają opcje używane w odpowiednich przykładach w tym artykule, a nie wszystkie dostępne.
</p>
<h3><span class="mw-headline" id="Opcje_szyfrowania_dla_trybu_LUKS">Opcje szyfrowania dla trybu LUKS</span></h3>
<p><i>cryptsetup</i> służąca do skonfigurowania nowego urządzenia dm-crypt w trybie szyfrowania LUKS to luksFormat. W przeciwieństwie do nazwy oznacza to, że nie formatuje urządzenia, ale ustawia nagłówek urządzenia LUKS i szyfruje klucz główny z żądanymi opcjami kryptograficznymi.
</p>
<p>Ponieważ LUKS jest domyślnym trybem szyfrowania,
</p>
<pre># cryptsetup -v luksFormat <i>device</i>
</pre>
<p>to wszystko, czego potrzeba, aby stworzyć nowe urządzenie LUKS z domyślnymi parametrami ((<code>-v</code> jest opcjonalne). Dla porównania możemy ręcznie określić domyślne opcje:
</p>
<pre># cryptsetup -v --cipher aes-xts-plain64 --key-size 256 --hash sha256 --iter-time 2000 --use-urandom --verify-passphrase luksFormat <i>device</i>
</pre>
<p>Wartości domyślne są porównywane z przykładem kryptograficznie wyższego opisu w poniższej tabeli wraz z towarzyszącymi komentarzami:
</p>
<table class="wikitable">
<tbody>
<tr>
<th>Opcje</th>
<th>Domyślne ustawienia Cryptsetup 1.7.0</th>
<th>Przykład</th>
<th>Komentarz
</th>
</tr>
<tr>
<th style="text-align:right;white-space:nowrap;">--cipher
<p>-c
</p>
</th>
<td>
<code>aes-xts-plain64</code>
</td>
<td>
<code>aes-xts-plain64</code>
</td>
<td>
<a rel="nofollow" class="external text" href="https://www.kernel.org/pub/linux/utils/cryptsetup/v1.6/v1.6.0-ReleaseNotes">Release 1.6.0</a> changed the defaults to an AES <a href="../../en/Data-at-rest_encryption.html#Ciphers_and_modes_of_operation" class="mw-redirect" title="Disk encryption">cipher</a> in <a href="https://en.wikipedia.org/wiki/Disk_encryption_theory#XEX-based_tweaked-codebook_mode_with_ciphertext_stealing_.28XTS.29" class="extiw" title="wikipedia:Disk encryption theory">XTS</a> mode (see item 5.16 <a rel="nofollow" class="external text" href="https://gitlab.com/cryptsetup/cryptsetup/wikis/FrequentlyAskedQuestions#5-security-aspects">of the FAQ</a>). It is advised against using the previous default <code>--cipher aes-cbc-essiv</code> because of its known <a href="https://en.wikipedia.org/wiki/Disk_encryption_theory#Cipher-block_chaining_.28CBC.29" class="extiw" title="wikipedia:Disk encryption theory">issues</a> and practical <a rel="nofollow" class="external text" href="http://www.jakoblell.com/blog/2013/12/22/practical-malleability-attack-against-cbc-encrypted-luks-partitions/">attacks</a> against them.
</td>
</tr>
<tr>
<th style="text-align:right;white-space:nowrap;">--key-size
<p>-s
</p>
</th>
<td>
<code>256</code>
</td>
<td>
<code>512</code>
</td>
<td>By default a 256 bit key-size is used. Note however that <a href="https://en.wikipedia.org/wiki/Disk_encryption_theory#XEX-based_tweaked-codebook_mode_with_ciphertext_stealing_.28XTS.29" class="extiw" title="wikipedia:Disk encryption theory">XTS splits the supplied key in half</a>, so to use AES-256 instead of AES-128 you have to set the XTS key-size to <code>512</code>.
</td>
</tr>
<tr>
<th style="text-align:right;white-space:nowrap;">--hash
<p>-h
</p>
</th>
<td>
<code>sha256</code>
</td>
<td>
<code>sha512</code>
</td>
<td>Hash algorithm used for <a href="../../en/Data-at-rest_encryption.html#Cryptographic_metadata" class="mw-redirect" title="Disk encryption">key derivation</a>. Release 1.7.0 changed defaults from <code>sha1</code> to <code>sha256</code> "<i>not for security reasons [but] mainly to prevent compatibility problems on hardened systems where SHA1 is already [being] phased out</i>"<a rel="nofollow" class="external autonumber" href="https://www.kernel.org/pub/linux/utils/cryptsetup/v1.7/v1.7.0-ReleaseNotes">[1]</a>. The former default of <code>sha1</code> can still be used for compatibility with older versions of <i>cryptsetup</i> since it is <a rel="nofollow" class="external text" href="https://gitlab.com/cryptsetup/cryptsetup/wikis/FrequentlyAskedQuestions#5-security-aspects">considered secure</a> (see item 5.20).
</td>
</tr>
<tr>
<th style="text-align:right;white-space:nowrap;">--iter-time
<p>-i
</p>
</th>
<td>
<code>2000</code>
</td>
<td>
<code>5000</code>
</td>
<td>Number of milliseconds to spend with PBKDF2 passphrase processing. Release 1.7.0 changed defaults from <code>1000</code> to <code>2000</code> to "<i>try to keep PBKDF2 iteration count still high enough and also still acceptable for users.</i>"<a rel="nofollow" class="external autonumber" href="https://www.kernel.org/pub/linux/utils/cryptsetup/v1.7/v1.7.0-ReleaseNotes">[2]</a>. This option is only relevant for LUKS operations that set or change passphrases, such as <i>luksFormat</i> or <i>luksAddKey</i>. Specifying 0 as parameter selects the compiled-in default..
</td>
</tr>
<tr>
<th style="text-align:right;white-space:nowrap;">--use-{u,}random
</th>
<td>
<code>--use-urandom</code>
</td>
<td>
<code>--use-random</code>
</td>
<td>Selects which <a href="../../en/Random_number_generation.html" class="mw-redirect" title="Random number generator">random number generator</a> to use. Quoting the cryptsetup manual page: "In a low-entropy situation (e.g. in an embedded system), both  selections are problematic. Using /dev/urandom can lead to weak keys. Using /dev/random can block a long time, potentially forever, if not enough entropy can be harvested  by the kernel."
</td>
</tr>
<tr>
<th style="text-align:right;white-space:nowrap;">--verify-passphrase
<p>-y
</p>
</th>
<td>Yes
</td>
<td>-
</td>
<td>Default only for luksFormat and luksAddKey. No need to type for Arch Linux with LUKS mode at the moment.
</td>
</tr>
</tbody>
</table>
<p>Jeśli chcesz zagłębić się w funkcje kryptograficzne LUKS, to <a rel="nofollow" class="external text" href="https://gitlab.com/cryptsetup/cryptsetup/wikis/Specification">LUKS specification</a> (na przykład jego dodatki) jest zasobem. 
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Tip:</strong> Przewiduje się, że nagłówek LUKS otrzyma kolejną ważną wersję w odpowiednim czasie. Jeśli jesteś zainteresowany planami, twórcy' <a rel="nofollow" class="external text" href="https://mbroz.fedorapeople.org/talks/DevConf2016/devconf2016-luks2.pdf">devconfcz2016</a> (pdf) prezentacja podsumowuje.</div>
<h3>
<span id="Opcje_szyfrowania_dla_trybu_zwyk.C5.82ego"></span><span class="mw-headline" id="Opcje_szyfrowania_dla_trybu_zwykłego">Opcje szyfrowania dla trybu zwykłego</span>
</h3>
<p>W trybie zwykłym dm-crypt na urządzeniu nie ma klucza głównego, dlatego nie ma potrzeby konfigurowania go. Zamiast tego opcje szyfrowania, które należy zastosować, są używane bezpośrednio do utworzenia odwzorowania między zaszyfrowanym dyskiem a nazwanym urządzeniem. Mapowanie można utworzyć na partycji lub na pełnym urządzeniu. W tym drugim przypadku nie jest wymagana nawet tablica partycji.
</p>
<p>Aby utworzyć mapowanie w trybie zwykłym z domyślnymi parametrami cryptsetup:
</p>
<pre># cryptsetup &lt;options&gt; open --type plain &lt;device&gt; &lt;dmname&gt;
</pre>
<p>Wykonanie go spowoduje podanie hasła, które powinno mieć bardzo wysoką entropię. 
Poniżej porównanie domyślnych parametrów z przykładem w <a href="../../pl/Dm-crypt_(Polski)/Encrypting_an_entire_system.html#Zwyk%C5%82y_dm-crypt" class="mw-redirect" title="Dm-crypt/Encrypting an entire system (Polski)">dm-crypt/Encrypting an entire system (Polski)#Zwykły dm-crypt</a>
</p>
<table class="wikitable">
<tbody>
<tr>
<th>Option</th>
<th>Cryptsetup 1.7.0 defaults</th>
<th>Example</th>
<th>Comment
</th>
</tr>
<tr>
<th style="text-align:right;white-space:nowrap;">--hash
<p>-h
</p>
</th>
<td>
<code>ripemd160</code>
</td>
<td>-
</td>
<td>The hash is used to create the key from the passphrase; it is not used on a keyfile.
</td>
</tr>
<tr>
<th style="text-align:right;white-space:nowrap;">--cipher
<p>-c
</p>
</th>
<td>
<code>aes-cbc-essiv:sha256</code>
</td>
<td>
<code>twofish-xts-plain64</code>
</td>
<td>The cipher consists of three parts: cipher-chainmode-IV generator. Please see <a href="../../en/Data-at-rest_encryption.html#Ciphers_and_modes_of_operation" class="mw-redirect" title="Disk encryption">Disk encryption#Ciphers and modes of operation</a> for an explanation of these settings, and the <a rel="nofollow" class="external text" href="https://gitlab.com/cryptsetup/cryptsetup/wikis/DMCrypt">DMCrypt documentation</a> for some of the options available.
</td>
</tr>
<tr>
<th style="text-align:right;white-space:nowrap;">--key-size
<p>-s
</p>
</th>
<td>
<code>256</code>
</td>
<td>
<code>512</code>
</td>
<td>The key size (in bits). The size will depend on the cipher being used and also the chainmode in use. Xts mode requires twice the key size of cbc.
</td>
</tr>
<tr>
<th style="text-align:right;white-space:nowrap;">--offset
<p>-o
</p>
</th>
<td>
<code>0</code>
</td>
<td>
<code>0</code>
</td>
<td>The offset from the beginning of the target disk (in bytes) from which to start the mapping
</td>
</tr>
<tr>
<th style="text-align:right;white-space:nowrap;">--key-file
<p>-d
</p>
</th>
<td>default uses a passphrase
</td>
<td>
<code>/dev/sd<i>Z</i></code> (or e.g. <code>/boot/keyfile.enc</code>)
</td>
<td>The device or file to be used as a key. See <a href="#Keyfiles">#Keyfiles</a><sup>[<a href="../../en/Help:Procedures.html#Fix_broken_section_links" title="Help:Procedures">broken link</a>: invalid section]</sup> for further details.
</td>
</tr>
<tr>
<th style="text-align:right;white-space:nowrap;">--keyfile-offset
</th>
<td>
<code>0</code>
</td>
<td>
<code>0</code>
</td>
<td>Offset from the beginning of the file where the key starts (in bytes). This option is supported from <i>cryptsetup</i> 1.6.7 onwards.
</td>
</tr>
<tr>
<th style="text-align:right;white-space:nowrap;">--keyfile-size
<p>-l
</p>
</th>
<td>
<code>8192kB</code>
</td>
<td>- (default applies)
</td>
<td>Limits the bytes read from the key file. This option is supported from <i>cryptsetup</i> 1.6.7 onwards.
</td>
</tr>
</tbody>
</table>
<p>Używając urządzenia <code>/dev/sd<i>X</i></code>, powyższy przykład z prawej kolumny daje:
</p>
<pre># cryptsetup --cipher=twofish-xts-plain64 --offset=0 --key-file=/dev/sd<i>Z</i> --key-size=512 open --type=plain /dev/sdX enc
</pre>
<p>W przeciwieństwie do szyfrowania za pomocą LUKS, powyższe polecenie musi być wykonane w pełni za każdym razem, gdy konieczne jest ponowne ustanowienie mapowania, dlatego ważne jest, aby pamiętać szczegóły szyfrowania, hasza i pliku klucza. Możemy teraz sprawdzić, czy mapowanie zostało wykonane:
</p>
<pre># fdisk -l
</pre>
<p>Wpis powinien już istnieć <code>/dev/mapper/enc</code>.
</p>
<h2>
<span id="Szyfrowanie_urz.C4.85dze.C5.84_za_pomoc.C4.85_cryptsetup"></span><span class="mw-headline" id="Szyfrowanie_urządzeń_za_pomocą_cryptsetup">Szyfrowanie urządzeń za pomocą cryptsetup</span>
</h2>
<p>W tej sekcji pokazano, jak wykorzystać opcje tworzenia nowych zaszyfrowanych urządzeń blokowych i uzyskiwania dostępu do nich ręcznie. 
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Warning:</strong> GRUB does not support LUKS2 headers. Therefore, if you plan to <a href="../../en/GRUB.html#Boot_partition" title="GRUB">unlock an encrypted boot partition with GRUB</a><sup>[<a href="../../en/Help:Procedures.html#Fix_broken_section_links" title="Help:Procedures">broken link</a>: invalid section]</sup>, do not specify <code>luks2</code> for the type parameter on encrypted boot partitions.</div>
<h3>
<span id="Szyfrowanie_urz.C4.85dze.C5.84_w_trybie_LUKS"></span><span class="mw-headline" id="Szyfrowanie_urządzeń_w_trybie_LUKS">Szyfrowanie urządzeń w trybie LUKS</span>
</h3>
<h4><span class="mw-headline" id="Formatowanie_partycji_LUKS">Formatowanie partycji LUKS</span></h4>
<p>Aby ustawić partycję jako zaszyfrowaną partycję LUKS wykonaj:
</p>
<pre># cryptsetup luksFormat --type luks2 <i>device</i>
</pre>
<p>Zostaniesz poproszony o podanie hasła i jego weryfikację.
</p>
<p>Zobacz <a href="#Encryption_options_for_LUKS_mode">#Encryption options for LUKS mode</a><sup>[<a href="../../en/Help:Procedures.html#Fix_broken_section_links" title="Help:Procedures">broken link</a>: invalid section]</sup> dla opcji wiersza poleceń.
</p>
<p>Możesz sprawdzić wyniki za pomocą:
</p>
<pre># cryptsetup luksDump <i>device</i>
</pre>
<p>Zauważysz, że stos nie tylko pokazuje informacje nagłówka szyfrowania, ale także miejsca na klucze używane na partycji LUKS.
</p>
<p>Poniższy przykład utworzy zaszyfrowaną partycję root na {{ic|/dev/sda1} przy użyciu domyślnego szyfrowania AES w trybie XTS z efektywnym 256-bitowym szyfrowaniem
</p>
<pre># cryptsetup -s 512 luksFormat --type luks2 /dev/sda1
</pre>
<h5>
<span id="U.C5.BCywanie_LUKS_do_formatowania_partycji_za_pomoc.C4.85_pliku_kluczy"></span><span class="mw-headline" id="Używanie_LUKS_do_formatowania_partycji_za_pomocą_pliku_kluczy">Używanie LUKS do formatowania partycji za pomocą pliku kluczy</span>
</h5>
<p>Podczas tworzenia nowej zaszyfrowanej partycji LUKS, plik klucza może być powiązany z partycją podczas jej tworzenia za pomocą:
</p>
<pre># cryptsetup luksFormat --type luks2 <i>device</i> <i>/path/to/mykeyfile</i>
</pre>
<p>Zobacz <a href="#Keyfiles">#Keyfiles</a><sup>[<a href="../../en/Help:Procedures.html#Fix_broken_section_links" title="Help:Procedures">broken link</a>: invalid section]</sup> aby uzyskać instrukcje dotyczące generowania plików kluczy i zarządzania nimi.
</p>
<h4>
<span id="Odblokowywanie_.2F_mapowanie_partycji_LUKS_za_pomoc.C4.85_device_mapper"></span><span class="mw-headline" id="Odblokowywanie_/_mapowanie_partycji_LUKS_za_pomocą_device_mapper">Odblokowywanie / mapowanie partycji LUKS za pomocą device mapper</span>
</h4>
<p>Po utworzeniu partycji LUKS można je odblokować.
</p>
<p>Proces odblokowania zmapuje partycje do nowej nazwy urządzenia za pomocą urządzenia odwzorowującego. To ostrzega o tym jądrze <code><i>device</i></code> jest faktycznie zaszyfrowanym urządzeniem i powinno być adresowane za pomocą LUKS przy użyciu <code>/dev/mapper/<i>dm_name</i></code> aby nie nadpisywać zaszyfrowanych danych. Aby chronić się przed przypadkowym nadpisaniem, przeczytaj o możliwościach <a href="#Backup_and_restore">backup the cryptheader</a><sup>[<a href="../../en/Help:Procedures.html#Fix_broken_section_links" title="Help:Procedures">broken link</a>: invalid section]</sup> po zakończeniu konfiguracji.
</p>
<p>Aby otworzyć zaszyfrowaną partycję LUKS:
</p>
<pre># cryptsetup open <i>device</i> <i>dm_name</i>
</pre>
<p>Zostaniesz poproszony o hasło, aby odblokować partycję. Zwykle nazwa odwzorowana przez urządzenie jest opisowa dla funkcji zamapowanej partycji. Na przykład poniższe odblokowuje partycję luks <code>/dev/sda1</code> i odwzorowuje go na urządzenie odwzorowujące urządzenie o nazwie <code>cryptroot</code>:
</p>
<pre># cryptsetup open /dev/sda1 cryptroot 
</pre>
<p>Po otwarciu adres urządzenia głównego partycji będzie <code>/dev/mapper/cryptroot</code> zamiast partycji (np. <code>/dev/sda1</code>). 
</p>
<p>Aby skonfigurować LVM na wierzchu warstwy szyfrowania, plik urządzenia dla zaszyfrowanej grupy woluminów może być podobny <code>/dev/mapper/cryptroot</code> zamiast <code>/dev/sda1</code>. LVM będzie następnie nadawać dodatkowe nazwy wszystkim utworzonym woluminom logicznym, np. <code>/dev/mapper/lvmpool-root</code> i <code>/dev/mapper/lvmpool-swap</code>.
</p>
<p>Aby zapisać zaszyfrowane dane w partycji, należy uzyskać do nich dostęp za pomocą nazwy zmapowanej urządzenia. Pierwszym etapem dostępu będzie zazwyczaj <a href="../../en/File_systems.html#Create_a_file_system" title="File systems">utworzenie systemu plików</a>. Na przykład:
</p>
<pre> # mkfs -t ext4 /dev/mapper/cryptroot
</pre>
<p>Urządzenie <code>/dev/mapper/cryptroot</code> może być <a href="../../en/File_systems.html#Mount_a_file_system" class="mw-redirect" title="Mount">zamontowany</a> jak każda inna partycja. 
</p>
<p>Aby zamknąć kontener luks, odmontuj partycję i wykonaj następujące czynności:
</p>
<pre># cryptsetup close cryptroot
</pre>
<h3>
<span id="Szyfrowanie_urz.C4.85dze.C5.84_w_trybie_zwyk.C5.82ym"></span><span class="mw-headline" id="Szyfrowanie_urządzeń_w_trybie_zwykłym">Szyfrowanie urządzeń w trybie zwykłym</span>
</h3>
<p>Stworzenie i późniejszy dostęp do <i>dm-crypt</i> Szyfrowania w trybie zwykłym wymaga nie więcej niż korzystania z <i>cryptsetup</i> <code>open</code> akcję z poprawnymi <a href="#Opcje_szyfrowania_dla_trybu_zwyk%C5%82ego">parametrami</a>. Poniżej pokazano, że z dwoma przykładami urządzeń innych niż root, ale dodaje dziwnie, układając je w stos (tj. Drugi jest tworzony wewnątrz pierwszego). Oczywiście układanie szyfrowania podwaja się narzutowo. Oto przykład użycia innego przykładu użycia opcji szyfrowania.
</p>
<p>Otwórz akcję z poprawnymi parametrami.
</p>
<p>Pierwszy program odwzorowujący jest tworzony z domyślnymi ustawieniami "cryptsetup", jak opisano w lewej kolumnie tabeli powyżej 
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup --type plain -v open /dev/sdaX plain1</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Enter passphrase: 
Command successful.
</pre>
<p>Teraz dodajemy do niego drugie urządzenie blokowe, używając różnych parametrów szyfrowania oraz z (opcjonalnym) offsetem, tworzymy system plików i montujemy go
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup --type plain --cipher=serpent-xts-plain64 --hash=sha256 --key-size=256 --offset=10  open /dev/mapper/plain1 plain2</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Enter passphrase:</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># lsblk -p</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;"> NAME                                                     
 /dev/sda                                     
 ├─/dev/sdaX          
 │ └─/dev/mapper/plain1     
 │   └─/dev/mapper/plain2              
 ...
</pre>
<pre># mkfs -t ext2 /dev/mapper/plain2
# mount -t ext2 /dev/mapper/plain2 /mnt
# echo "This is stacked. one passphrase per foot to shoot." &gt; /mnt/stacked.txt
</pre>
<p>Zamykamy stos, aby sprawdzić, czy dostęp działa
</p>
<pre># cryptsetup close plain2
# cryptsetup close plain1
</pre>
<p>Najpierw spróbujmy bezpośrednio otworzyć system plików:
</p>
<pre># cryptsetup --type plain --cipher=serpent-xts-plain64 --hash=sha256 --key-size=256 --offset=10 open /dev/sdaX plain2
</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># mount -t ext2 /dev/mapper/plain2 /mnt</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">mount: wrong fs type, bad option, bad superblock on /dev/mapper/plain2,
      missing codepage or helper program, or other error
</pre>
<p>Dlaczego to nie zadziałało? Ponieważ blok startowy "plain2" (<code>10</code>) is still encrypted with the cipher from "plain1". It can only be accessed via the stacked mapper. The error is arbitrary though, trying a wrong passphrase or wrong options will yield the same. dla <i>dm-crypt</i> tryb zwykły, <code>open</code> akcja nie spowoduje błędu.  
</p>
<p>Ponowna próba w prawidłowej kolejności: 
</p>
<pre># cryptsetup close plain2    # dysfunctional mapper from previous try
</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup --type plain open /dev/sdaX plain1</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Enter passphrase:
</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup --type plain --cipher=serpent-xts-plain64 --hash=sha256 --key-size=256 --offset=10 open /dev/mapper/plain1 plain2</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Enter passphrase:</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># mount /dev/mapper/plain2 /mnt &amp;&amp; cat /mnt/stacked.txt</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">This is stacked. one passphrase per foot to shoot.
</pre>
<p><i>dm-crypt</i> poradzi sobie ze skumulowanym szyfrowaniem w niektórych mieszanych trybach. Na przykład tryb LUKS może być ustawiony w stosie na maperze ""plain1". Nagłówek zostałby zaszyfrowany wewnątrz "plain1", gdy jest zamknięty.
</p>
<p>Available for plain mode only is the option <code>--shared</code>. With it a single device can be segmented into different non-overlapping mappers. We do that in the next example, using a <i>loopaes</i> compatible cipher mode for "plain2" this time: 
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup --type plain --offset 0 --size 1000 open /dev/sdaX plain1</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Enter passphrase:</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup --type plain --offset 1000 --size 1000 --shared --cipher=aes-cbc-lmk --hash=sha256 open /dev/sdaX plain2</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Enter passphrase:</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># lsblk -p</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">NAME                    
dev/sdaX                    
├─/dev/sdaX               
│ ├─/dev/mapper/plain1     
│ └─/dev/mapper/plain2     
...
</pre>
<p>Jak pokazuje devicetree, oba znajdują się na tym samym poziomie, tj. Nie są ułożone w stos, a "plain2" można otwierać indywidualnie.
</p>
<h2>
<span id="Dzia.C5.82ania_Cryptsetup_specyficzne_dla_LUKS"></span><span class="mw-headline" id="Działania_Cryptsetup_specyficzne_dla_LUKS">Działania Cryptsetup specyficzne dla LUKS</span>
</h2>
<h3>
<span id="Zarz.C4.85dzanie_kluczami"></span><span class="mw-headline" id="Zarządzanie_kluczami">Zarządzanie kluczami</span>
</h3>
<p>Możliwe jest zdefiniowanie do 8 różnych kluczy na partycję LUKS. Umożliwia to użytkownikowi tworzenie kluczy dostępu do składowania kopii zapasowej: W tak zwanym kluczowym zabezpieczeniu, jeden klucz jest używany do codziennego użytku, drugi jest przechowywany w depozycie, aby uzyskać dostęp do partycji w przypadku, gdy dzienne hasło zostało zapomniane lub plik klucza jest zagubiony / uszkodzony. Również inny klucz-gniazdo może być użyty do przyznania dostępu do partycji użytkownikowi poprzez wydanie drugiego klucza, a następnie ponowne jego unieważnienie.
</p>
<p>Po utworzeniu zaszyfrowanej partycji tworzona jest początkowa partia klawiszy 0 (jeśli żadna inna nie została określona ręcznie). Dodatkowe keyslots są ponumerowane od 1 do 7. Które keyslots są używane można zobaczyć poprzez wydanie
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup luksDump /dev/&lt;device&gt; | grep BLED</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Key Slot 0: ENABLED
Key Slot 1: ENABLED
Key Slot 2: ENABLED
Key Slot 3: DISABLED
Key Slot 4: DISABLED
Key Slot 5: DISABLED
Key Slot 6: DISABLED
Key Slot 7: DISABLED
</pre>
<p>Gdzie &lt;urządzenie&gt; jest woluminem zawierającym nagłówek LUKS. To i wszystkie poniższe polecenia w tej sekcji również działają na pliki kopii zapasowej nagłówka.
</p>
<h4><span class="mw-headline" id="Dodawanie_kluczy_LUKS">Dodawanie kluczy LUKS</span></h4>
<p>Dodanie nowych keyslots odbywa się za pomocą cryptsetup z akcją <code>luksAddKey</code>. Dla bezpieczeństwa zawsze, to jest również dla już odblokowanych urządzeń, należy poprosić o ważny istniejący klucz ("dowolne hasło") przed wprowadzeniem nowego:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup luksAddKey /dev/&lt;device&gt; (/path/to/&lt;additionalkeyfile&gt;)</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Enter any passphrase:
Enter new passphrase for key slot:
Verify passphrase: 
</pre>
<p>Jeżeli <code>/path/to/&lt;additionalkeyfile&gt;</code> jest podana, cryptsetup doda nowy klucz dla  &lt;additionalkeyfile&gt;. W przeciwnym razie nowe hasło zostanie wyświetlone dwukrotnie. Aby użyć istniejącego "pliku klucza" do autoryzacji akcji, należy <code>--key-file</code> or <code>-d</code> opcja, po której następuje "stary" plik &lt;keyfile&gt;, spróbuje odblokować wszystkie dostępne klucze keysfile:
</p>
<pre># cryptsetup luksAddKey /dev/&lt;device&gt; (/path/to/&lt;additionalkeyfile&gt;) -d /path/to/&lt;keyfile&gt;
</pre>
<p>Jeśli zamierza się używać wielu kluczy i zmieniać lub odwoływać je, to <code>--key-slot</code> lub <code>-S</code> Opcja ta może być użyta do określenia gniazda:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup luksAddKey /dev/&lt;device&gt; -S 6</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Enter any passphrase: 
Enter new passphrase for key slot: 
Verify passphrase:
</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup luksDump /dev/sda8 | grep 'Slot 6'</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Key Slot 6: ENABLED
</pre>
<p>Aby pokazać powiązaną akcję w tym przykładzie, od razu decydujemy się zmienić klucz:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup luksChangeKey /dev/&lt;device&gt; -S 6</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Enter LUKS passphrase to be changed: 
Enter new LUKS passphrase:
</pre>
<p>przed dalszym usuwaniem.
</p>
<h4><span class="mw-headline" id="Usuwanie_kluczy_LUKS">Usuwanie kluczy LUKS</span></h4>
<p>Istnieją trzy różne działania mające na celu usuwanie kluczy z nagłówka:
</p>
<ul>
<li>
<code>luksRemoveKey</code> służy do usunięcia klucza, określając jego hasło/plik-klucza.</li>
<li>
<code>luksKillSlot</code> można użyć do usunięcia klucza z określonego gniazda klucza (przy użyciu innego klucza). Oczywiście jest to niezwykle przydatne, jeśli zapomniałeś hasła, zgubiłeś plik klucza lub nie masz do niego dostępu.</li>
<li>
<code>luksErase</code> służy do szybkiego usuwania "aktywnych" kluczy.</li>
</ul>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Warning:</strong> 
<ul>
<li>Wszystkie powyższe czynności można wykorzystać do nieodwracalnego usunięcia ostatniego aktywnego klucza do zaszyfrowanego urządzenia!</li>
<li>Polecenie <code>luksErase</code> zostało dodane w wersji 1.6.4, aby szybko uzyskać dostęp do urządzenia Nuke. Ta czynność nie spowoduje wyświetlenia prawidłowego hasła! Nie spowoduje to <a href="../../en/Dm-crypt/Drive_preparation.html#Wipe_LUKS_header" title="Dm-crypt/Drive preparation">wyczyszczenia nagłówka LUKS</a>, ale wszystkich kluczy jednocześnie, a zatem nie będzie można odzyskać dostępu, chyba że masz poprawną kopię zapasową nagłówka LUKS.</li>
</ul>
</div>
<p>Dla powyższego ostrzeżenia dobrze jest wiedzieć, że klucz, który chcemy zachować, jest ważny. Łatwym sprawdzeniem jest odblokowanie urządzenia za pomocą opcji <code>-v</code>, która określa, który slot zajmuje:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup -v open /dev/&lt;device&gt; testcrypt</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Enter passphrase for /dev/&lt;device&gt;: 
Key slot 1 unlocked.
Command successful.
</pre>
<p>Teraz możemy usunąć klucz dodany w poprzednim podsekcji za pomocą jego hasła: 
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup luksRemoveKey /dev/&lt;device&gt;</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Enter LUKS passphrase to be deleted:
</pre>
<p>Gdybyśmy użyli tego samego hasła dla dwóch klawiszy, pierwszy slot zostałby teraz wyczyszczony. Ponowne wykonanie go spowoduje usunięcie drugiego.
</p>
<p>Alternatywnie możemy określić kluczowy slot:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup luksKillSlot /dev/&lt;device&gt; 6</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Enter any remaining LUKS passphrase:
</pre>
<p>Należy pamiętać, że w obu przypadkach potwierdzenie nie było wymagane.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup luksDump /dev/sda8 | grep 'Slot 6'</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Key Slot 6: DISABLED
</pre>
<p>Aby powtórzyć powyższe ostrzeżenie: jeśli to samo hasło zostało użyte w kluczowym gnieździe 1 i 6, obie karty zniknęłyby teraz.
</p>
<h3><span class="mw-headline" id="Kopia_zapasowa_i_przywracanie">Kopia zapasowa i przywracanie</span></h3>
<p>Jeśli nagłówek zaszyfrowanej partycji LUKS zostanie zniszczony, nie będzie można odszyfrować danych. Jest to tak samo dylemat, jak zapomnienie hasła lub uszkodzenie pliku klucza używanego do odblokowania partycji. Uszkodzenia mogą pojawić się z własnej winy podczas ponownej partycjonowania dysku w późniejszym czasie lub przez programy innych producentów błędnie interpretujące tabelę partycji. Dlatego posiadanie kopii zapasowej nagłówka i przechowywanie go na innym dysku może być dobrym pomysłem.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> Jeśli zostanie naruszone hasło główne zaszyfrowanych partycji LUKS, musisz odwołać je na "każdej" kopii kryptografu, nawet kopii zapasowej. W przeciwnym razie do odtępienia powiązanej partycji można użyć kopii kopii zapasowej kryptografu wykorzystującego przejęte hasło. Zobacz <a rel="nofollow" class="external text" href="https://gitlab.com/cryptsetup/cryptsetup/wikis/FrequentlyAskedQuestions#6-backup-and-data-recovery">LUKS FAQ</a> for further details.</div>
<h4>
<span id="Kopia_zapasowa_za_pomoc.C4.85_cryptsetup"></span><span class="mw-headline" id="Kopia_zapasowa_za_pomocą_cryptsetup">Kopia zapasowa za pomocą cryptsetup</span>
</h4>
<p>Cryptsetup' <code>luksHeaderBackup</code> Działanie przechowuje binarną kopię zapasową nagłówku LUKS i obszaru keyslot:
</p>
<pre># cryptsetup luksHeaderBackup /dev/&lt;device&gt; --header-backup-file /mnt/&lt;backup&gt;/&lt;file&gt;.img
</pre>
<p>gdzie &lt;device&gt; to partycja zawierająca wolumin LUKS.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Tip:</strong> Możesz także utworzyć kopię zapasową nagłówka zwykłego tekstu w ramfs i zaszyfrować go w przykładzie za pomocą gpg przed zapisaniem do trwałej kopii zapasowej, wykonując następujące polecenia.</div>
<pre># mkdir /root/&lt;tmp&gt;/
# mount ramfs /root/&lt;tmp&gt;/ -t ramfs
# cryptsetup luksHeaderBackup /dev/&lt;device&gt; --header-backup-file /root/&lt;tmp&gt;/&lt;file&gt;.img
# gpg2 --recipient &lt;User ID&gt; --encrypt /root/&lt;tmp&gt;/&lt;file&gt;.img 
# cp /root/&lt;tmp&gt;/&lt;file&gt;.img.gpg /mnt/&lt;backup&gt;/
# umount /root/&lt;tmp&gt;
</pre>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Warning:</strong> Tmpfs można zamienić na twardy dysk, jeśli brakuje pamięci, więc nie jest to zalecane tutaj.</div>
<h4>
<span id="Przywracanie_za_pomoc.C4.85_cryptsetup"></span><span class="mw-headline" id="Przywracanie_za_pomocą_cryptsetup">Przywracanie za pomocą cryptsetup</span>
</h4>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Warning:</strong> Przywrócenie niewłaściwego nagłówka lub przywrócenie go do niezaszyfrowanej partycji spowoduje utratę danych! Akcja nie może sprawdzić, czy nagłówek jest rzeczywiście "poprawny" dla tego konkretnego urządzenia.</div> 
<p>Aby uniknąć przywrócenia złego nagłówka, możesz upewnić się, że działa, używając go zdalnie <code>--header</code> pierwszy: 
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup -v --header /mnt/&lt;backup&gt;/&lt;file&gt;.img open /dev/&lt;device&gt; test</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Key slot 0 unlocked.
Command successful.
</pre>
<pre># mount /dev/mapper/test /mnt/test &amp;&amp; ls /mnt/test 
# umount /mnt/test 
# cryptsetup close test 
</pre>
<p>Po pomyślnym sprawdzeniu można wykonać przywracanie:
</p>
<pre># cryptsetup luksHeaderRestore /dev/&lt;device&gt; --header-backup-file ./mnt/&lt;backup&gt;/&lt;file&gt;.img
</pre>
<p>Teraz wszystkie obszary keyslot są nadpisywane; tylko aktywne keyslots z pliku kopii zapasowej są dostępne po wydaniu polecenia.
</p>
<h4>
<span id="R.C4.99czne_tworzenie_kopii_zapasowych_i_przywracanie"></span><span class="mw-headline" id="Ręczne_tworzenie_kopii_zapasowych_i_przywracanie">Ręczne tworzenie kopii zapasowych i przywracanie</span>
</h4>
<p>Nagłówek zawsze znajduje się na początku urządzenia, a kopia zapasowa może być również wykonywana bez dostępu do "cryptsetup". Najpierw musisz znaleźć offset dla zaszyfrowanej partycji:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup luksDump /dev/&lt;device&gt; | grep "Payload offset"</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Payload offset:	4040
</pre>
<p>Po drugie sprawdź rozmiar sektora dysku
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># fdisk -l /dev/&lt;device&gt; | grep "Sector size"</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Sector size (logical/physical): 512 bytes / 512 bytes
</pre>
<p>Teraz, gdy znasz wartości, możesz wykonać kopię zapasową nagłówka za pomocą prostej komendy dd:
</p>
<pre># dd if=/dev/&lt;device&gt; of=/path/to/&lt;file&gt;.img bs=512 count=4040
</pre>
<p>i przechowuj go bezpiecznie.
</p>
<p>Przywracanie można następnie wykonać przy użyciu tych samych wartości, co podczas tworzenia kopii zapasowej:
</p>
<pre># dd if=./&lt;file&gt;.img of=/dev/&lt;device&gt; bs=512 count=4040
</pre>
<h3>
<span id="Ponowne_szyfrowanie_urz.C4.85dze.C5.84"></span><span class="mw-headline" id="Ponowne_szyfrowanie_urządzeń">Ponowne szyfrowanie urządzeń</span>
</h3>
<p>The <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=cryptsetup">cryptsetup</a></span> ppakiet zawiera narzędzie "cryptsetup-reencrypt". Może być użyty do konwersji istniejącego niezaszyfrowanego systemu plików na zaszyfrowany LUKS (opcja <code>--new</code>) i trwale usunąć szyfrowanie LUKS (<code>--decrypt</code>) z urządzenia. Jak sama nazwa wskazuje, może być również użyty do ponownego zaszyfrowania istniejącego zaszyfrowanego urządzenia LUKS, jednak ponowne szyfrowanie nie jest możliwe w przypadku odłączonego nagłówka LUKS lub innych trybów szyfrowania (na przykład w trybie zwykłym). W celu ponownego szyfrowania można zmienić <a href="#Opcje_szyfrowania_dla_trybu_LUKS">#Opcje szyfrowania dla trybu LUKS</a>. <i>cryptsetup-reencrypt</i>Działania można wykonywać tylko dla niezamontowanych urządzeń. Zobacz <span class="plainlinks archwiki-template-man" title="$ man 8 cryptsetup-reencrypt"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/cryptsetup-reencrypt.8">cryptsetup-reencrypt(8)</a></span> po więcej informacji.
</p>
<p>Jednym z zastosowań ponownego szyfrowania może być ponowne zabezpieczenie danych po złamaniu hasła lub <a href="#Keyfiles">pliku klucza</a><sup>[<a href="../../en/Help:Procedures.html#Fix_broken_section_links" title="Help:Procedures">broken link</a>: invalid section]</sup> i nie można mieć pewności, że nie otrzymano żadnej kopii nagłówka LUKS. Na przykład, jeśli tylko hasło zostało naruszone, ale nie nastąpił fizyczny dostęp do urządzenia, wystarczy zmienić odpowiednie hasło / klucz tylko (<a href="#Zarz%C4%85dzanie_kluczami">#Zarządzanie kluczami</a>). 
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Warning:</strong> Zawsze upewnij się, że "kopia zapasowa" jest dostępna i sprawdź dokładnie opcje, które określisz przed użyciem narzędzia!</div>
<p>Poniżej przedstawiono przykład szyfrowania niezaszyfrowanej partycji systemu plików i ponownego szyfrowania istniejącego urządzenia LUKS.
</p>
<h4>
<span id="Zaszyfruj_niezaszyfrowany_system_plik.C3.B3w"></span><span class="mw-headline" id="Zaszyfruj_niezaszyfrowany_system_plików">Zaszyfruj niezaszyfrowany system plików</span>
</h4>
<p>Nagłówek szyfrowania LUKS jest zawsze przechowywany na początku dysku. Ponieważ istniejącemu systemowi plików zwykle przydzielane są wszystkie sektory partycji, pierwszym krokiem jest zmniejszenie go, aby zrobić miejsce dla nagłówka LUKS.
</p>
<p><a href="#Opcje_szyfrowania_dla_trybu_LUKS">Domyślny</a> szyfr LUKS nagłówka wymaga <code>4096</code> 512-bajtowych sektorów. Sprawdziliśmy już miejsce i utrzymujemy prostotę, zmniejszając istniejący system plików <code>ext4</code> na <code>/dev/sdaX</code> do jego obecnego możliwego minimum:
</p>
<pre># umount /mnt
</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># e2fsck -f /dev/sdaX</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">e2fsck 1.43-WIP (18-May-2015)
Pass 1: Checking inodes, blocks, and sizes
...
/dev/sda6: 12/166320 files (0.0% non-contiguous), 28783/665062 blocks
</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># resize2fs -M /dev/sdaX</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">resize2fs 1.43-WIP (18-May-2015)
Resizing the filesystem on /dev/sdaX to 26347 (4k) blocks.
The filesystem on /dev/sdaX is now 26347 (4k) blocks long.
</pre>
<p>Teraz zaszyfrujemy go, używając domyślnego szyfru, którego nie musimy jawnie określać. Uwaga: nie ma jeszcze opcji (jeszcze) do podwójnego sprawdzenia hasła przed rozpoczęciem szyfrowania, należy uważać, aby nie pomylić:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup-reencrypt /dev/sdaX --new  --reduce-device-size 4096S</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">WARNING: this is experimental code, it can completely break your data.
Enter new passphrase: 
Progress: 100,0%, ETA 00:00, 2596 MiB written, speed  37,6 MiB/s
</pre>
<p>Po zakończeniu szyfrowanie zostało wykonane na pełną partycję, tj. Nie tylko przestrzeń, do której skrócił się system plików (<code>sdaX</code> ma <code>2.6GiB</code> a procesor użyty w tym przykładzie nie ma instrukcji sprzętowych AES). Ostatnim krokiem jest ponowne rozszerzenie systemu plików zaszyfrowanego urządzenia, aby zajęło dostępne miejsce:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup open /dev/sdaX recrypt</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Enter passphrase for /dev/sdaX: 
...
</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># resize2fs /dev/mapper/recrypt</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">resize2fs 1.43-WIP (18-May-2015)
Resizing the filesystem on /dev/mapper/recrypt to 664807 (4k) blocks.
The filesystem on /dev/mapper/recrypt is now 664807 (4k) blocks long.
</pre>
<pre># mount /dev/mapper/recrypt /mnt
</pre>
<p>i gotowe.
</p>
<h4>
<span id="Ponowne_szyfrowanie_istniej.C4.85cej_partycji_LUKS"></span><span class="mw-headline" id="Ponowne_szyfrowanie_istniejącej_partycji_LUKS">Ponowne szyfrowanie istniejącej partycji LUKS</span>
</h4>
<p>W tym przykładzie istniejące urządzenie LUKS jest ponownie szyfrowane.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Warning:</strong> Dokładnie sprawdź, czy poprawnie określasz opcje szyfrowania dla funkcji <i>cryptsetup-reencrypt</i> i <i>nigdy</i> nie re-szyfruj bez <b>niezawodnej kopii zapasowej</b>! Od września 2015 narzędzie <b>akceptuje</b> nieprawidłowe opcje i uszkadza nagłówek LUKS, jeśli nie jest używane poprawnie!</div>
<p>Aby ponownie zaszyfrować urządzenie za pomocą istniejących opcji szyfrowania, nie trzeba ich określać. Prosty:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup-reencrypt /dev/sdaX</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;"> 
WARNING: this is experimental code, it can completely break your data.
Enter passphrase for key slot 0: 
Progress: 100,0%, ETA 00:00, 2596 MiB written, speed  36,5 MiB/s
</pre>
<p>wykonuje to.
</p>
<p>Możliwym przypadkiem jest ponowne szyfrowanie urządzeń LUKS, które mają nieaktualne opcje szyfrowania. Oprócz powyższego ostrzeżenia o prawidłowym określeniu opcji, możliwość zmiany nagłówka LUKS może być również ograniczona przez jego rozmiar. Na przykład, jeśli urządzenie zostało początkowo zaszyfrowane przy użyciu szyfrowania w trybie CBC i klucza 128-bitowego, nagłówek LUKS będzie o połowę mniejszy od wspomnianych {{ic|4096} sektorów:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup luksDump /dev/sdaX |grep -e "mode" -e "Payload" -e "MK bits"</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Cipher mode:   	cbc-essiv:sha256
Payload offset:	<b>2048</b>
MK bits:       	128
</pre>
<p>O ile możliwe jest uaktualnienie szyfrowania takiego urządzenia, jest to obecnie możliwe tylko w dwóch etapach. Najpierw ponownie zaszyfruj z tymi samymi opcjami szyfrowania, ale używając  <code>--reduce-device-size</code> opcja utworzenia dodatkowej przestrzeni dla większego nagłówka LUKS. Po drugie, ponownie sprowadź całe urządzenie z żądanym szyfrem. Z tego powodu i faktu, że kopia zapasowa powinna być tworzona w każdym przypadku, tworzenie nowego, świeżego urządzenia zaszyfrowanego do przywrócenia jest zawsze szybszą opcją.
</p>
<h2>
<span id="Zmiana_rozmiaru_zaszyfrowanych_urz.C4.85dze.C5.84"></span><span class="mw-headline" id="Zmiana_rozmiaru_zaszyfrowanych_urządzeń">Zmiana rozmiaru zaszyfrowanych urządzeń</span>
</h2>
<div class="noprint archwiki-template-message">
<p><a href="../../File:Tango-view-fullscreen.png" class="image"><img alt="Tango-view-fullscreen.png" src="../../File:Tango-view-fullscreen.png" decoding="async" width="48" height="48"></a><b>This article or section needs expansion.</b><a href="../../File:Tango-view-fullscreen.png" class="image"><img alt="Tango-view-fullscreen.png" src="../../File:Tango-view-fullscreen.png" decoding="async" width="48" height="48"></a></p>
<div>
<b>Reason:</b> This section should be rewritten to introduce resizing more generically. Perhaps work on it together with <a href="../../en/Resizing_LVM-on-LUKS.html" title="Resizing LVM-on-LUKS">Resizing LVM-on-LUKS</a>. (Discuss in <a rel="nofollow" class="external text" href="https://wiki.archlinux.org/index.php/Talk:Dm-crypt_(Polski)/Device_encryption_(Polski)">Talk:Dm-crypt (Polski)/Device encryption (Polski)#</a>)</div>
</div>
<p>Jeśli urządzenie pamięciowe zaszyfrowane za pomocą dm-crypt jest klonowane (za pomocą narzędzia takiego jak dd) do innego większego urządzenia, podstawowe urządzenie dm-crypt musi zostać powiększone, aby wykorzystać całą przestrzeń.
</p>
<p>W tym przykładzie urządzeniem docelowym jest /dev/sdX2, zostanie użyta cała dostępna przestrzeń obok partycji:
</p>
<pre># cryptsetup luksOpen /dev/sdX2 sdX2
# cryptsetup resize sdX2
</pre>
<p>Następnie należy zmienić rozmiar podstawowego systemu plików.
</p>
<h3><span class="mw-headline" id="Loopback_filesystem">Loopback filesystem</span></h3>
<p>Zakładając, że zaszyfrowany system plików loopback jest zamontowany w <code>/mnt/secret</code>, na przykład następujący <a href="../../pl/Dm-crypt_(Polski)/Encrypting_a_non-root_file_system.html#Loop_device" class="mw-redirect" title="Dm-crypt/Encrypting a non-root file system (Polski)">dm-crypt/Encrypting a non-root file system (Polski)#Loop device</a>, najpierw odmontuj zaszyfrowany kontener:
</p>
<pre># umount /mnt/secret
# cryptsetup close secret
# losetup -d /dev/loop0
</pre>
<p>Następnie rozwiń plik kontenera o rozmiar danych, które chcesz dodać:
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Warning:</strong> Be careful to really use <b>two</b> <code>&gt;</code>, or you will override your current container.</div>
<pre># dd if=/dev/urandom bs=1M count=1024 | cat - &gt;&gt; /bigsecret
</pre>
<p>Teraz zmapuj kontener na loop device: 
</p>
<pre># losetup /dev/loop0 /bigsecret
# cryptsetup open /dev/loop0 secret
</pre>
<p>Następnie zmień rozmiar zaszyfrowanej części kontenera na maksymalny rozmiar pliku kontenera:
</p>
<pre># cryptsetup resize secret
</pre>
<p>Na koniec przeprowadź test systemu plików i, jeśli jest w porządku, zmień jego rozmiar (przykład dla ext2/3/4):
</p>
<pre># e2fsck -f /dev/mapper/secret
# resize2fs /dev/mapper/secret
</pre>
<p>Możesz teraz ponownie zamontować kontener:
</p>
<pre># mount /dev/mapper/secret /mnt/secret
</pre>
<h2><span class="mw-headline" id="Pliki_kluczy">Pliki kluczy</span></h2>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> TW tej sekcji opisano użycie pliku klucza tekstowego w postaci zwykłego tekstu. Jeśli chcesz zaszyfrować plik klucza, co daje dwuetapowe uwierzytelnianie, Zobacz <a href="../../en/Dm-crypt/Specialties.html#Using_GPG,_LUKS,_or_OpenSSL_Encrypted_Keyfiles" title="Dm-crypt/Specialties">Using GPG or OpenSSL Encrypted Keyfiles</a> po szczegóły, ale proszę, przeczytaj ten rozdział.</div>
<p><b>Co to jest plik klucza?</b>
</p>
<p>Plik klucza to plik, którego dane są używane jako hasło do odblokowania zaszyfrowanego woluminu.
Oznacza to, że jeśli taki plik zostanie utracony lub zmieniony, odszyfrowanie woluminu może być niemożliwe.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Tip:</strong> Zdefiniuj hasło oprócz pliku klucza, aby uzyskać kopię zapasową dostępu do zaszyfrowanych woluminów w przypadku utraty lub zmiany zdefiniowanego pliku klucza.</div>
<p><b>Dlaczego warto użyć pliku klucza?</b>
</p>
<p>Istnieje wiele rodzajów plików kluczy. Każdy rodzaj użytego pliku klucza ma zalety i wady:
</p>
<h3>
<span id="Rodzaje_plik.C3.B3w_kluczy"></span><span class="mw-headline" id="Rodzaje_plików_kluczy">Rodzaje plików kluczy</span>
</h3>
<h4>
<span id="has.C5.82o"></span><span class="mw-headline" id="hasło">hasło</span>
</h4>
<p>Jest to plik klucza zawierający proste hasło. Zaletą tego typu pliku kluczy jest to, że jeśli plik zostanie utracony, zawarte w nim dane są znane i, miejmy nadzieję, łatwo zapamiętane przez właściciela zaszyfrowanego woluminu. Jednak wadą jest to, że nie dodaje żadnego zabezpieczenia przed wprowadzeniem hasła podczas początkowego uruchomienia systemu.
</p>
<p>Przykład: <code>1234</code>
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> Plik klucza zawierający frazę hasła nie może zawierać znaku nowej linii. Jedną z opcji jest utworzenie go za pomocą
<pre># echo -n 'your_passphrase' &gt; /path/to/&lt;keyfile&gt;
# chown root:root /path/to/&lt;keyfile&gt;; chmod 400 /path/to/&lt;keyfile&gt;
</pre>
</div>
<h4><span class="mw-headline" id="randomtext">randomtext</span></h4>
<p>Jest to plik klucza zawierający blok losowych znaków. Zaletą tego typu pliku kluczy jest to, że jest on znacznie bardziej odporny na ataki słownikowe niż proste hasło. W tej sytuacji można wykorzystać dodatkową moc plików kluczy, która jest długością używanych danych. Ponieważ nie jest to ciąg przeznaczony do zapamiętania przez osobę do wpisu, trywialne jest tworzenie plików zawierających tysiące losowych znaków jako klucz. Wadą jest to, że jeśli ten plik zostanie utracony lub zmieniony, najprawdopodobniej dostęp do zaszyfrowanego woluminu bez kopii zapasowej hasła będzie niemożliwy.
</p>
<p>Przykład: <code>fjqweifj830149-57 819y4my1-38t1934yt8-91m 34co3;t8y;9p3y-</code>
</p>
<h4><span class="mw-headline" id="binary">binary</span></h4>
<p>Jest to plik binarny, który został zdefiniowany jako plik klucza. Podczas identyfikowania plików jako kandydatów do pliku klucza zaleca się wybrać pliki, które są stosunkowo statyczne, takie jak zdjęcia, muzyka, klipy wideo. Zaletą tych plików jest to, że pełnią podwójną funkcję, co może utrudnić identyfikację ich jako plików kluczy. Zamiast pliku tekstowego z dużą ilością losowego tekstu, plik klucza będzie wyglądać jak zwykły plik obrazu lub klip muzyczny przypadkowego obserwatora. Wadą jest to, że jeśli ten plik zostanie utracony lub zmieniony, najprawdopodobniej dostęp do zaszyfrowanego woluminu bez kopii zapasowej hasła będzie niemożliwy. Dodatkowo istnieje teoretyczna utrata losowości w porównaniu z losowo wygenerowanym plikiem tekstowym. Wynika to z faktu, że obrazy, filmy i muzyka mają pewien nierozerwalny związek między sąsiednimi bitami danych, które nie istnieją dla pliku tekstowego. Jest to jednak kontrowersyjne i nigdy nie zostało publicznie wykorzystane.
</p>
<p>Przykład: obrazy, tekst, wideo ...
</p>
<h3><span class="mw-headline" id="Tworzenie_pliku_kluczy_z_losowymi_znakami">Tworzenie pliku kluczy z losowymi znakami</span></h3>
<h4>
<span id="Przechowywanie_pliku_klucza_w_systemie_plik.C3.B3w"></span><span class="mw-headline" id="Przechowywanie_pliku_klucza_w_systemie_plików">Przechowywanie pliku klucza w systemie plików</span>
</h4>
<p>Plik klucza może mieć dowolną treść i rozmiar.
</p>
<p>Tutaj <code>dd</code> służy do generowania pliku kluczy o 2048 losowych bajtach, przechowując go w pliku <code>/etc/mykeyfile</code>
</p>
<pre># dd bs=512 count=4 if=/dev/urandom of=/etc/mykeyfile
</pre>
<p>Jeśli planujesz przechowywać plik klucza na urządzeniu zewnętrznym, możesz po prostu zmienić plik wyjściowy na odpowiedni katalog:
</p>
<pre># dd bs=512 count=4 if=/dev/urandom of=/media/usbstick/mykeyfile
</pre>
<p>Aby odmówić dostępu innym użytkownikom <code>root</code>:
</p>
<pre># chmod 600 /etc/mykeyfile
</pre>
<h5>
<span id="Bezpieczne_nadpisywanie_zapisanych_plik.C3.B3w_kluczy"></span><span class="mw-headline" id="Bezpieczne_nadpisywanie_zapisanych_plików_kluczy">Bezpieczne nadpisywanie zapisanych plików kluczy</span>
</h5>
<p>Jeśli przechowujesz tymczasowy plik kluczy na fizycznym urządzeniu magazynującym i chcesz go usunąć, pamiętaj, aby nie tylko usunąć plik klucza później, ale użyj czegoś podobnego
</p>
<pre># shred --remove --zero mykeyfile
</pre>
<p>aby go bezpiecznie zastąpić. W przypadku nadmiernie obciążonych systemów plików, takich jak FAT lub ext2, będzie to wystarczające, natomiast w przypadku kronikowania systemów plików, sprzętu pamięci flash i innych przypadków zdecydowanie zaleca się <a href="../../en/Securely_wipe_disk.html" title="Securely wipe disk">wyczyszczenie całego dysku</a>.
</p>
<h4><span class="mw-headline" id="Przechowywanie_pliku_kluczy_w_ramfs">Przechowywanie pliku kluczy w ramfs</span></h4>
<p>Alternatywnie możesz zamontować ramfs do tymczasowego przechowywania pliku klucza:
</p>
<pre># mkdir /root/myramfs
# mount ramfs /root/myramfs/ -t ramfs
# cd /root/myramfs
</pre>
<p>Zaletą jest to, że znajduje się on w pamięci RAM, a nie na dysku fizycznym, dlatego nie można go odzyskać po odmontowaniu ramfów. Po skopiowaniu pliku klucza do innego bezpiecznego i trwałego systemu plików, odmontuj pliki ramfs ponownie
</p>
<pre># umount /root/myramfs
</pre>
<h3><span class="mw-headline" id="Konfigurowanie_LUKS_do_korzystania_z_pliku_klucza">Konfigurowanie LUKS do korzystania z pliku klucza</span></h3>
<p>Dodaj keylot dla pliku klucza do nagłówka LUKS:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># cryptsetup luksAddKey /dev/sda2 /etc/mykeyfile</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Enter any LUKS passphrase:
key slot 0 unlocked.
Command successful.
</pre>
<h3>
<span id="R.C4.99czne_odblokowywanie_partycji_przy_u.C5.BCyciu_pliku_klucza"></span><span class="mw-headline" id="Ręczne_odblokowywanie_partycji_przy_użyciu_pliku_klucza">Ręczne odblokowywanie partycji przy użyciu pliku klucza</span>
</h3>
<p>Użyj opcji <code>--key-file</code> podczas otwierania urządzenia LUKS:
</p>
<pre># cryptsetup open /dev/sda2 <i>dm_name</i> --key-file /etc/mykeyfile
</pre>
<h3><span class="mw-headline" id="Odblokowywanie_dodatkowej_partycji_podczas_rozruchu">Odblokowywanie dodatkowej partycji podczas rozruchu</span></h3>
<p>Jeśli plik klucza dla dodatkowego systemu plików jest przechowywany w zaszyfrowanym katalogu głównym, jest bezpieczny, gdy system jest wyłączony, ale można go pobrać, aby automatycznie odblokować gniazdo podczas rozruchu za pośrednictwem <a href="../../en/Dm-crypt/System_configuration.html#crypttab" class="mw-redirect" title="Crypttab">crypttab</a>. Od pierwszego przykładu powyżej przy użyciu <a href="../../en/Persistent_block_device_naming.html#by-uuid" class="mw-redirect" title="UUID">UUID</a>:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/crypttab</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">home    UUID=&lt;UUID identifier&gt;    /etc/mykeyfile
</pre>
<p>jest wszystko potrzebne do odblokowania, i
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/fstab</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">/dev/mapper/home        /home   ext4        defaults        0       2
</pre>
<p>do montowania urządzenia blokowego LUKS z wygenerowanym plikiem klucza.
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Tip:</strong> Jeśli wolisz używać trybu blokowego <code>--plain</code> mode, opcje szyfrowania niezbędne do jego odblokowania są określone w <code>/etc/crypttab</code>. W takim przypadku należy zastosować systemowe obejście, o którym mowa w <a href="../../en/Dm-crypt/System_configuration.html#crypttab" class="mw-redirect" title="Crypttab">crypttab</a>.</div>
<h3>
<span id="Odblokowywanie_partycji_g.C5.82.C3.B3wnej_podczas_rozruchu"></span><span class="mw-headline" id="Odblokowywanie_partycji_głównej_podczas_rozruchu">Odblokowywanie partycji głównej podczas rozruchu</span>
</h3>
<p>Jest to po prostu kwestia skonfigurowania <a href="../../en/Mkinitcpio.html" title="Mkinitcpio">mkinitcpio</a> w celu włączenia niezbędnych modułów lub plików i skonfigurowania parametru jądra <a href="../../en/Dm-crypt/System_configuration.html#cryptkey" title="Dm-crypt/System configuration">cryptkey</a>, aby wiedział, gdzie znaleźć plik klucza.
</p>
<p>Poniżej przedstawiono dwa przypadki:
</p>
<ol>
<li>Używanie pliku kluczy przechowywanego na nośniku zewnętrznym (tutaj pamięć USB)</li>
<li>Używanie pliku klucza osadzonego w initramfs</li>
</ol>
<h4>
<span id="Z_plikiem_kluczy_przechowywanym_na_zewn.C4.99trznym_no.C5.9Bniku"></span><span class="mw-headline" id="Z_plikiem_kluczy_przechowywanym_na_zewnętrznym_nośniku">Z plikiem kluczy przechowywanym na zewnętrznym nośniku</span>
</h4>
<h5><span class="mw-headline" id="Konfigurowanie_mkinitcpio">Konfigurowanie mkinitcpio</span></h5>
<p>Musisz dodać moduł do swojego <code>/etc/mkinitcpio.conf</code>dla systemu plików napędu (<code>vfat</code> moduł w poniższym przykładzie):
</p>
<pre>MODULES=(vfat)
</pre>
<p>W tym przykładzie zakłada się, że używasz dysku USB sformatowanego w systemie FAT (<code>vfat</code> moduł). Zastąp te nazwy modułów, jeśli używasz innego systemu plików na dysku USB (np. <code>ext2</code>) lub inną codepage. Jeśli skarga dotyczy złej superbloku i złej strony kodowej przy starcie, potrzebny jest dodatkowy moduł codepage do załadowania. Na przykład możesz potrzebować <code>nls_iso8859-1</code>moduł dla <code>iso8859-1</code> codepage.
</p>
<p>Jeśli masz klawiaturę inną niż amerykańska, może okazać się użyteczne załadowanie układu klawiatury przed monitem o wprowadzenie hasła w celu odblokowania partycji głównej podczas rozruchu. Do tego będziesz potrzebował <code>keymap</code> hak przed <code>encrypt</code>.
</p>
<p><a href="../../en/Mkinitcpio.html#Image_creation_and_activation" class="mw-redirect" title="Regenerate the initramfs">Regenerate the initramfs</a>.
</p>
<h5>
<span id="Konfigurowanie_parametr.C3.B3w_j.C4.85dra"></span><span class="mw-headline" id="Konfigurowanie_parametrów_jądra">Konfigurowanie parametrów jądra</span>
</h5>
<p>Dodaj następujące opcje do <a href="../../en/Kernel_parameters.html" title="Kernel parameters">kernel parameters</a> jeśli używasz <code>encrypt</code> hak. Jeśli używasz <code>sd-encrypt</code> Zobacz <a href="../../en/Dm-crypt/System_configuration.html#Using_sd-encrypt_hook" title="Dm-crypt/System configuration">dm-crypt/System configuration#Using sd-encrypt hook</a>.
</p>
<pre>cryptdevice=/dev/<i>&lt;partition1&gt;</i>:root cryptkey=/dev/<i>&lt;partition2&gt;</i>:&lt;fstype&gt;:&lt;path&gt;
</pre>
<p>Na przykład:
</p>
<pre>cryptdevice=/dev/sda3:root cryptkey=/dev/sdb1:vfat:/keys/secretkey
</pre>
<p>Choosing a plain filename for your key provides a bit of 'security through obscurity', but be aware the kernel command line is recorded in the kernel's log (<i>dmesg</i>). The keyfile can not be a hidden file, that means the filename must not start with a dot, or the <code>encrypt</code> hook will fail to find the keyfile during the boot process. Alternatively, one could hide the keyfile between the partitions and use:
</p>
<pre>cryptkey=/dev/sdb1:offset:size
</pre>
<p>Zaletą jest to, że trudniej jest przypadkowo usunąć klucz.
</p>
<p>Nazwa węzłów urządzeń, takich jak <code>/dev/sdb1</code>, nie ma gwarancji, że pozostanie takie samo podczas restartu. Bardziej niezawodny jest dostęp do urządzenia z <a href="../../en/Persistent_block_device_naming.html" title="Persistent block device naming">trwałym nazwaniem urządzeń blokowych</a> udev. Aby upewnić się, że szyfrowany klucz znajdzie plik klucza podczas odczytu go z zewnętrznego urządzenia pamięci masowej, należy użyć nazw stałych urządzeń blokowych. Zobacz artykuł na temat <a href="../../en/Persistent_block_device_naming.html" title="Persistent block device naming">trwałych nazw urządzeń blokowych</a>.
</p>
<h4><span class="mw-headline" id="Z_plikiem_kluczy_osadzonym_w_initramfs">Z plikiem kluczy osadzonym w initramfs</span></h4>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Warning:</strong> Użyj wbudowanego pliku klucza tylko <b>wtedy</b>, gdy wcześniej dysponujesz jakąś formą mechanizmu uwierzytelniania, który wystarczająco zabezpiecza plik klucza. W przeciwnym razie nastąpi automatyczne odszyfrowanie, całkowicie eliminując cel szyfrowania urządzenia blokowego.</div>
<p><br>
</p>
<p>Ta metoda pozwala na użycie specjalnie nazwanego pliku klucza, który zostanie osadzony w pliku <a href="../../en/Arch_boot_process.html#initramfs" class="mw-redirect" title="Initramfs">initramfs</a> i odbierane przez <code>encrypt</code> <a href="../../en/Mkinitcpio.html#HOOKS" title="Mkinitcpio">hookaby</a> odblokować główny system plików (<code>cryptdevice</code>) automatycznie. Może być przydatne zastosowanie podczas korzystania z <a href="../../en/GRUB.html#Boot_partition" title="GRUB">GRUB early cryptodisk</a><sup>[<a href="../../en/Help:Procedures.html#Fix_broken_section_links" title="Help:Procedures">broken link</a>: invalid section]</sup> w celu uniknięcia wprowadzania dwóch haseł podczas rozruchu.
</p>
<p>Zaszyfrowanie pozwala użytkownikowi określić plik klucza za pomocą parametru jądra <code>cryptkey</code>: w przypadku initramfs, składnia to rootfs: <code>rootfs:<i>path</i></code> Zobacz <a href="../../en/Dm-crypt/System_configuration.html#cryptkey" title="Dm-crypt/System configuration">dm-crypt/System configuration#cryptkey</a>. Poza tym ten parametr jądra jest domyślnie używany <code>/crypto_keyfile.bin</code>, a jeśli initramfs zawiera poprawny klucz o tej nazwie, deszyfrowanie nastąpi automatycznie bez potrzeby konfiguracji <code>cryptkey</code> parametr.
</p>
<p>Jeśli korzystasz z <code>sd-encrypt</code> zamiast <code>encrypt</code>, określ lokalizację pliku klucza za pomocą parametru jądra <code>rd.luks.key</code>. Zobacz <a href="../../en/Dm-crypt/System_configuration.html#rd.luks.key" title="Dm-crypt/System configuration">dm-crypt/System configuration#rd.luks.key</a>.
</p>
<p><a href="#Tworzenie_pliku_kluczy_z_losowymi_znakami">Wygeneruj plik klucza</a>, nadaj mu odpowiednie uprawnienia i <a href="#Dodawanie_kluczy_LUKS">dodaj go jako klucz LUKS</a>:
</p>
<pre># dd bs=512 count=4 if=/dev/urandom of=/crypto_keyfile.bin
# chmod 000 /crypto_keyfile.bin
# chmod 600 /boot/initramfs-linux*
# cryptsetup luksAddKey /dev/sdX# /crypto_keyfile.bin
</pre>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Warning:</strong> Kiedy uprawnienia initramfs są ustawione na 644 (domyślnie), wszyscy użytkownicy będą mogli zrzucić plik klucza. Upewnij się, że uprawnienia są nadal 600, jeśli zainstalujesz nowe jądro.</div>
<p>Dołącz klucz do <a href="../../en/Mkinitcpio.html#BINARIES_and_FILES" title="Mkinitcpio">mkinitcpio's FILES array</a>:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/mkinitcpio.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">FILES=(/crypto_keyfile.bin)</pre>
<p>Wreszcie <a href="../../en/Mkinitcpio.html#Image_creation_and_activation" class="mw-redirect" title="Regenerate the initramfs">zregeneruj initramfs</a>.
</p>
<p>Przy następnym ponownym uruchomieniu należy tylko raz wpisać hasło do odszyfrowania kontenera.
</p>
<p>(<a rel="nofollow" class="external text" href="http://www.pavelkogan.com/2014/05/23/luks-full-disk-encryption/#bonus-login-once">source</a>)
</p>
</div>
</div>
<div id="catlinks" class="catlinks" data-mw="interface">
<div id="mw-normal-catlinks" class="mw-normal-catlinks">
<a href="../../Special:Categories.html" title="Special:Categories">Categories</a>: <ul>
<li><a href="../../pl/Category:Data-at-rest_encryption.html" title="Category:Data-at-rest encryption (Polski)">Data-at-rest encryption (Polski)</a></li>
<li><a href="../../pl/Category:File_systems.html" title="Category:File systems (Polski)">File systems (Polski)</a></li>
</ul>
</div>
<div id="mw-hidden-catlinks" class="mw-hidden-catlinks mw-hidden-cats-hidden">Hidden categories: <ul>
<li><a href="../../en/Category:Pages_with_broken_section_links.html" title="Category:Pages with broken section links">Pages with broken section links</a></li>
<li><a href="../../en/Category:Pages_or_sections_flagged_with_Template:Expansion.html" title="Category:Pages or sections flagged with Template:Expansion">Pages or sections flagged with Template:Expansion</a></li>
</ul>
</div>
</div>
	</div>
</div>

<footer id="footer" class="mw-footer" role="contentinfo" style="margin: 0">
	<ul id="footer-info">
		<li>Retrieved from "<a dir="ltr" href="https://wiki.archlinux.org/index.php?title=Dm-crypt_(Polski)/Device_encryption_(Polski)&amp;oldid=615536">https://wiki.archlinux.org/index.php?title=Dm-crypt_(Polski)/Device_encryption_(Polski)&amp;oldid=615536</a>"</li>
		<li id="footer-info-lastmod"> This page was last edited on 24 May 2020, at 15:31.</li>
		<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3 or later</a> unless otherwise noted.</li>
	<br>
</ul>
	<ul id="footer-places">
		<li id="footer-places-privacy"><a href="../../en/ArchWiki:Privacy_policy.html" title="ArchWiki:Privacy policy">Privacy policy</a></li>
		<li id="footer-places-about"><a href="../../en/ArchWiki:About.html" title="ArchWiki:About">About ArchWiki</a></li>
		<li id="footer-places-disclaimer"><a href="../../en/ArchWiki:General_disclaimer.html" title="ArchWiki:General disclaimer">Disclaimers</a></li>
	</ul>
	<ul id="footer-icons" class="noprint">
		<li id="footer-copyrightico">
	</ul>
	<div style="clear: both;"></div>
</footer>



</body>
</html>
