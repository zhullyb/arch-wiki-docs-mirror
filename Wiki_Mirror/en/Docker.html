<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<title>Docker - ArchWiki</title>
<link rel="stylesheet" href="../ArchWikiOffline.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<meta name="generator" content="MediaWiki 1.35.0">
<meta name="referrer" content="no-referrer-when-downgrade">
<meta name="robots" content="noindex,follow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="/opensearch_desc.php" title="ArchWiki (en)">
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.archlinux.org/api.php?action=rsd">
<link rel="license" href="http://www.gnu.org/copyleft/fdl.html">
<link rel="alternate" type="application/atom+xml" title="ArchWiki Atom feed" href="/index.php?title=Special:RecentChanges&amp;feed=atom">
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Docker rootpage-Docker skin-vector action-view skin-vector-legacy">
<div id="content" class="mw-body" role="main" style="margin: 0">
	<a id="top"></a>
	<div id="siteNotice" class="mw-body-content"></div>
	<div class="mw-indicators mw-body-content">
	</div>
	<h1 id="firstHeading" class="firstHeading" lang="en">Docker</h1>
	<div id="bodyContent" class="mw-body-content">
		<div id="siteSub" class="noprint">From ArchWiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="#searchInput">Jump to search</a>
		<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<div class="warningbox">The printable version is no longer supported and may have rendering errors. Please update your browser bookmarks and please use the default browser print function instead.</div>
<div class="mw-parser-output">
<div class="archwiki-template-meta-related-articles-start">
<p>Related articles</p>
<ul>
<li><a href="../en/Systemd-nspawn.html" title="Systemd-nspawn">systemd-nspawn</a></li>
<li><a href="../en/Linux_Containers.html" title="Linux Containers">Linux Containers</a></li>
<li><a href="../en/Vagrant.html" title="Vagrant">Vagrant</a></li>
<li><a href="../en/Podman.html" title="Podman">Podman</a></li>
</ul>
</div>
<p><a href="https://en.wikipedia.org/wiki/Docker_(software)" class="extiw" title="wikipedia:Docker (software)">Docker</a> is a utility to pack, ship and run any application as a lightweight container.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading">
<input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none"><div class="toctitle" lang="en" dir="ltr">
<h2 id="mw-toc-heading">Contents</h2>
<span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span>
</div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Installation"><span class="tocnumber">1</span> <span class="toctext">Installation</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Usage"><span class="tocnumber">2</span> <span class="toctext">Usage</span></a></li>
<li class="toclevel-1 tocsection-3">
<a href="#Configuration"><span class="tocnumber">3</span> <span class="toctext">Configuration</span></a>
<ul>
<li class="toclevel-2 tocsection-4"><a href="#Storage_driver"><span class="tocnumber">3.1</span> <span class="toctext">Storage driver</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Daemon_socket"><span class="tocnumber">3.2</span> <span class="toctext">Daemon socket</span></a></li>
<li class="toclevel-2 tocsection-6">
<a href="#HTTP_Proxies"><span class="tocnumber">3.3</span> <span class="toctext">HTTP Proxies</span></a>
<ul>
<li class="toclevel-3 tocsection-7"><a href="#Docker_daemon_proxy_configuration"><span class="tocnumber">3.3.1</span> <span class="toctext">Docker daemon proxy configuration</span></a></li>
<li class="toclevel-3 tocsection-8"><a href="#Docker_container_proxy_configuration"><span class="tocnumber">3.3.2</span> <span class="toctext">Docker container proxy configuration</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-9"><a href="#Configuring_DNS"><span class="tocnumber">3.4</span> <span class="toctext">Configuring DNS</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#Images_location"><span class="tocnumber">3.5</span> <span class="toctext">Images location</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#Insecure_registries"><span class="tocnumber">3.6</span> <span class="toctext">Insecure registries</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#IPv6"><span class="tocnumber">3.7</span> <span class="toctext">IPv6</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#User_namespace_isolation"><span class="tocnumber">3.8</span> <span class="toctext">User namespace isolation</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="#Docker_rootless"><span class="tocnumber">3.9</span> <span class="toctext">Docker rootless</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-15">
<a href="#Images"><span class="tocnumber">4</span> <span class="toctext">Images</span></a>
<ul>
<li class="toclevel-2 tocsection-16"><a href="#Arch_Linux"><span class="tocnumber">4.1</span> <span class="toctext">Arch Linux</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Alpine_Linux"><span class="tocnumber">4.2</span> <span class="toctext">Alpine Linux</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#CentOS"><span class="tocnumber">4.3</span> <span class="toctext">CentOS</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="#Debian"><span class="tocnumber">4.4</span> <span class="toctext">Debian</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="#Distroless"><span class="tocnumber">4.5</span> <span class="toctext">Distroless</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-21">
<a href="#Run_GPU_accelerated_Docker_containers_with_NVIDIA_GPUs"><span class="tocnumber">5</span> <span class="toctext">Run GPU accelerated Docker containers with NVIDIA GPUs</span></a>
<ul>
<li class="toclevel-2 tocsection-22"><a href="#With_NVIDIA_Container_Toolkit_(recommended)"><span class="tocnumber">5.1</span> <span class="toctext">With NVIDIA Container Toolkit (recommended)</span></a></li>
<li class="toclevel-2 tocsection-23"><a href="#With_NVIDIA_Container_Runtime"><span class="tocnumber">5.2</span> <span class="toctext">With NVIDIA Container Runtime</span></a></li>
<li class="toclevel-2 tocsection-24"><a href="#With_nvidia-docker_(deprecated)"><span class="tocnumber">5.3</span> <span class="toctext">With nvidia-docker (deprecated)</span></a></li>
<li class="toclevel-2 tocsection-25"><a href="#Arch_Linux_image_with_CUDA"><span class="tocnumber">5.4</span> <span class="toctext">Arch Linux image with CUDA</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-26"><a href="#Useful_tips"><span class="tocnumber">6</span> <span class="toctext">Useful tips</span></a></li>
<li class="toclevel-1 tocsection-27"><a href="#Remove_Docker_and_images"><span class="tocnumber">7</span> <span class="toctext">Remove Docker and images</span></a></li>
<li class="toclevel-1 tocsection-28">
<a href="#Troubleshooting"><span class="tocnumber">8</span> <span class="toctext">Troubleshooting</span></a>
<ul>
<li class="toclevel-2 tocsection-29"><a href="#docker0_Bridge_gets_no_IP_/_no_internet_access_in_containers_when_using_systemd-networkd"><span class="tocnumber">8.1</span> <span class="toctext">docker0 Bridge gets no IP / no internet access in containers when using systemd-networkd</span></a></li>
<li class="toclevel-2 tocsection-30"><a href="#Default_number_of_allowed_processes/threads_too_low"><span class="tocnumber">8.2</span> <span class="toctext">Default number of allowed processes/threads too low</span></a></li>
<li class="toclevel-2 tocsection-31"><a href="#Error_initializing_graphdriver:_devmapper"><span class="tocnumber">8.3</span> <span class="toctext">Error initializing graphdriver: devmapper</span></a></li>
<li class="toclevel-2 tocsection-32"><a href="#Failed_to_create_some/path/to/file:_No_space_left_on_device"><span class="tocnumber">8.4</span> <span class="toctext">Failed to create some/path/to/file: No space left on device</span></a></li>
<li class="toclevel-2 tocsection-33"><a href="#Docker-machine_fails_to_create_virtual_machines_using_the_virtualbox_driver"><span class="tocnumber">8.5</span> <span class="toctext">Docker-machine fails to create virtual machines using the virtualbox driver</span></a></li>
<li class="toclevel-2 tocsection-34"><a href="#Starting_Docker_breaks_KVM_bridged_networking"><span class="tocnumber">8.6</span> <span class="toctext">Starting Docker breaks KVM bridged networking</span></a></li>
<li class="toclevel-2 tocsection-35"><a href="#Image_pulls_from_Docker_Hub_are_rate_limited"><span class="tocnumber">8.7</span> <span class="toctext">Image pulls from Docker Hub are rate limited</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-36"><a href="#See_also"><span class="tocnumber">9</span> <span class="toctext">See also</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="Installation">Installation</span></h2>
<p><a href="../en/Help:Reading.html#Installation_of_packages" class="mw-redirect" title="Install">Install</a> the <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=docker">docker</a></span> package or, for the development version, the <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/docker-git/">docker-git</a></span><sup><small>AUR</small></sup> package. Next <a href="../en/Systemd.html#Using_units" class="mw-redirect" title="Start">start</a> and enable <code>docker.service</code> and verify operation:
</p>
<pre># docker info
</pre>
<p>Note that starting the docker service may fail if you have an active VPN connection due to IP conflicts between the VPN and Docker's bridge and overlay networks. If this is the case, try disconnecting the VPN before starting the docker service. You may reconnect the VPN immediately afterwards. You can also try to deconflict the networks (see solutions <a rel="nofollow" class="external autonumber" href="https://stackoverflow.com/questions/45692255/how-make-openvpn-work-with-docker">[1]</a> or <a rel="nofollow" class="external autonumber" href="https://github.com/docker/compose/issues/4336#issuecomment-457326123">[2]</a>).
</p>
<p>Next, verify that you can run containers. The following command downloads the latest <a href="#Arch_Linux">Arch Linux image</a> and uses it to run a Hello World program within a container:
</p>
<pre># docker run -it --rm archlinux bash -c "echo hello world"
</pre>
<p>If you want to be able to run the <code>docker</code> CLI command as a non-root user, add your user to the <code>docker</code> <a href="../en/Users_and_groups.html#Group_management" class="mw-redirect" title="User group">user group</a>, re-login, and restart <code>docker.service</code>.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Warning:</strong> Anyone added to the <code>docker</code> group is root equivalent because they can use the <code>docker run --privileged</code> command to start containers with root privileges. For more information see <a rel="nofollow" class="external autonumber" href="https://github.com/docker/docker/issues/9976">[3]</a> and <a rel="nofollow" class="external autonumber" href="https://docs.docker.com/engine/security/security/">[4]</a>.</div>
<h2><span class="mw-headline" id="Usage">Usage</span></h2>
<p>Docker consists of multiple parts:
</p>
<ul>
<li>The Docker daemon (sometimes also called the Docker Engine), which is a process which runs as <code>docker.service</code>. It serves the Docker API and manages Docker containers.</li>
<li>The <code>docker</code> CLI command, which allows users to interact with the Docker API via the command line and control the Docker daemon.</li>
<li>Docker containers, which are namespaced processes that are started and managed by the Docker daemon as requested through the Docker API.</li>
</ul>
<p>Typically, users use Docker by running <code>docker</code> CLI commands, which in turn request the Docker daemon to perform actions which in turn result in management of Docker containers. Understanding the relationship between the client (<code>docker</code>), server (<code>docker.service</code>) and containers is important to successfully administering Docker.
</p>
<p>Note that if the Docker daemon stops or restarts, all currently running Docker containers are also stopped or restarted.
</p>
<p>Also note that it is possible to send requests to the Docker API and control the Docker daemon without the use of the <code>docker</code> CLI command. See <a rel="nofollow" class="external text" href="https://docs.docker.com/engine/api/">the Docker API developer documentation</a> for more information.
</p>
<p>See <a rel="nofollow" class="external text" href="https://docs.docker.com/get-started/">the Docker Getting Started guide</a> for more usage documentation.
</p>
<h2><span class="mw-headline" id="Configuration">Configuration</span></h2>
<p>The Docker daemon can be configured either through a configuration file at <code>/etc/docker/daemon.json</code> or by adding command line flags to the <code>docker.service</code> systemd unit. According to the <a rel="nofollow" class="external text" href="https://docs.docker.com/config/daemon/#configure-the-docker-daemon">Docker official documentation</a>, the configuration file approach is preferred. If you wish to use the command line flags instead, use <a href="../en/Systemd.html#Drop-in_files" title="Systemd">systemd drop-in files</a> to override the <code>ExecStart</code> directive in <code>docker.service</code>.
</p>
<p>For more information about options in <code>daemon.json</code> see <a rel="nofollow" class="external text" href="https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file">dockerd documentation</a>.
</p>
<h3><span class="mw-headline" id="Storage_driver">Storage driver</span></h3>
<p>The <a rel="nofollow" class="external text" href="https://docs.docker.com/storage/storagedriver/select-storage-driver/">storage driver</a> controls how images and containers are stored and managed on your Docker host. The default <code>overlay2</code> driver has good performance and is a good choice for all modern Linux kernels and filesystems. There are a few legacy drivers such as <code>devicemapper</code> and <code>aufs</code> which were intended for compatibility with older Linux kernels, but these have no advantages over <code>overlay2</code> on Arch Linux.
</p>
<p>Users of <a href="../en/Btrfs.html" title="Btrfs">btrfs</a> or <a href="../en/ZFS.html" title="ZFS">ZFS</a> may use the <code>btrfs</code> or <code>zfs</code> drivers, each of which take advantage of the unique features of these filesystems. See the <a rel="nofollow" class="external text" href="https://docs.docker.com/storage/storagedriver/btrfs-driver/">btrfs driver</a> and <a rel="nofollow" class="external text" href="https://docs.docker.com/storage/storagedriver/zfs-driver/">zfs driver</a> documentation for more information and step-by-step instructions.
</p>
<h3><span class="mw-headline" id="Daemon_socket">Daemon socket</span></h3>
<p>By default, the Docker daemon serves the Docker API using a <a href="https://en.wikipedia.org/wiki/Unix_domain_socket" class="extiw" title="wikipedia:Unix domain socket">Unix socket</a> at <code>/var/run/docker.sock</code>. This is an appropriate option for most use cases.
</p>
<p>It is possible to configure the Daemon to additionally listen on a TCP socket, which can allow remote Docker API access from other computers. This can be useful for allowing <code>docker</code> commands on a host machine to access the Docker daemon on a Linux virtual machine, such as an Arch virtual machine on a Windows or macOS system.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Warning:</strong> The Docker API is unencrypted and unauthenticated by default. Remote TCP access to the Docker daemon is equivalent to unsecured remote root access unless TLS encryption and authorization is also enabled, either with an authenticating HTTP reverse proxy or with the appropriate <a rel="nofollow" class="external text" href="https://docs.docker.com/engine/security/https/">additional Docker configuration</a>. In general, enabling Docker API TCP sockets should be considered a high security risk.</div>
<p>Note that the default <code>docker.service</code> file sets the <code>-H</code> flag by default, and Docker will not start if an option is present in both the flags and <code>/etc/docker/daemon.json</code> file. Therefore, the simplest way to change the socket settings is with a drop-in file, such as the following which adds a TCP socket on port 4243:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/systemd/system/docker.service.d/execstart.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[Service]
ExecStart=
ExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:4243</pre>
<p><a href="../en/Systemd.html#Using_units" class="mw-redirect" title="Reload">Reload</a> the systemd daemon and <a href="../en/Systemd.html#Using_units" class="mw-redirect" title="Restart">restart</a> <code>docker.service</code> to apply changes.
</p>
<h3><span class="mw-headline" id="HTTP_Proxies">HTTP Proxies</span></h3>
<p>There are two parts to configuring Docker to use an HTTP proxy: Configuring the Docker daemon and configuring Docker containers.
</p>
<h4><span class="mw-headline" id="Docker_daemon_proxy_configuration">Docker daemon proxy configuration</span></h4>
<p>See <a rel="nofollow" class="external text" href="https://docs.docker.com/config/daemon/systemd/#httphttps-proxy">Docker documentation on configuring a systemd drop-in unit to configure HTTP proxies</a>.
</p>
<h4><span class="mw-headline" id="Docker_container_proxy_configuration">Docker container proxy configuration</span></h4>
<p>See <a rel="nofollow" class="external text" href="https://docs.docker.com/network/proxy/#configure-the-docker-client">Docker documentation on configuring proxies</a> for information on how to automatically configure proxies for all containers created using the <code>docker</code> CLI.
</p>
<h3><span class="mw-headline" id="Configuring_DNS">Configuring DNS</span></h3>
<p>See <a rel="nofollow" class="external text" href="https://docs.docker.com/config/containers/container-networking/#dns-services">Docker's DNS documentation</a> for the documented behavior of DNS within Docker containers and information on customizing DNS configuration. In most cases, the resolvers configured on the host are also configured in the container.
</p>
<p>Most DNS resolvers hosted on <code>127.0.0.0/8</code> are <a rel="nofollow" class="external text" href="https://github.com/moby/moby/issues/6388#issuecomment-76124221">not supported</a> due to conflicts between the container and host network namespaces. Such resolvers are <a rel="nofollow" class="external text" href="https://github.com/moby/libnetwork/blob/master/resolvconf/resolvconf.go">removed from the container's /etc/resolv.conf</a>. If this would result in an empty <code>/etc/resolv.conf</code>, Google DNS is used instead.
</p>
<p>Additionally, a special case is handled if <code>127.0.0.53</code> is the only configured nameserver. In this case, Docker assumes the resolver is <a href="../en/Systemd-resolved.html" title="Systemd-resolved">systemd-resolved</a> and uses the upstream DNS resolvers from <code>/run/systemd/resolve/resolv.conf</code>.
</p>
<p>If you are using a service such as <a href="../en/Dnsmasq.html" title="Dnsmasq">dnsmasq</a> to provide a local resolver, consider adding a virtual interface with a link local IP address in the <code>169.254.0.0/16</code> block for dnsmasq to bind to instead of <code>127.0.0.1</code> to avoid the network namespace conflict.
</p>
<h3><span class="mw-headline" id="Images_location">Images location</span></h3>
<p>By default, docker images are located at <code>/var/lib/docker</code>. They can be moved to other partitions, e.g. if you wish to use a dedicated partition or disk for your images. In this example, we will move the images to <code>/mnt/docker</code>.
</p>
<p>First, <a href="../en/Systemd.html#Using_units" class="mw-redirect" title="Stop">stop</a> <code>docker.service</code>, which will also stop all currently running containers and unmount any running images. You may then move the images from <code>/var/lib/docker</code> to the target destination, e.g. <code>cp -r /var/lib/docker /mnt/docker</code>.
</p>
<p>Configure <code>data-root</code> in <code>/etc/docker/daemon.json</code>:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/docker/daemon.json</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">{
  "data-root": "/mnt/docker"
}</pre>
<p>Restart <code>docker.service</code> to apply changes.
</p>
<h3><span class="mw-headline" id="Insecure_registries">Insecure registries</span></h3>
<p>If you decide to use a self signed certificate for your private registries, Docker will refuse to use it until you declare that you trust it. For example, to allow images from a registry hosted at <code>myregistry.example.com:8443</code>, configure <code>insecure-registries</code> in the <code>/etc/docker/daemon.json</code> file:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/docker/daemon.json</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">{
  "insecure-registries": [
    "my.registry.example.com:8443"
  ]
}</pre>
<p>Restart <code>docker.service</code> to apply changes.
</p>
<h3><span class="mw-headline" id="IPv6">IPv6</span></h3>
<p>In order to enable IPv6 support in Docker, you will need to do a few things. See <a rel="nofollow" class="external autonumber" href="https://github.com/docker/docker.github.io/blob/c0eb65aabe4de94d56bbc20249179f626df5e8c3/engine/userguide/networking/default_network/ipv6.md">[5]</a> and <a rel="nofollow" class="external autonumber" href="https://github.com/moby/moby/issues/36954">[6]</a> for details.
</p>
<p>Firstly, enable the <code>ipv6</code> setting in <code>/etc/docker/daemon.json</code> and set a specific IPv6 subnet. In this case, we will use the private <code>fd00::/80</code> subnet. Make sure to use a subnet at least 80 bits as this allows a container's IPv6 to end with the container's MAC address which allows you to mitigate NDP neighbor cache invalidation issues.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/docker/daemon.json</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">{
  "ipv6": true,
  "fixed-cidr-v6": "fd00::/80"
}
</pre>
<p><a href="../en/Systemd.html#Using_units" class="mw-redirect" title="Restart">Restart</a> <code>docker.service</code> to apply changes. 
</p>
<p>Finally, to let containers access the host network, you need to resolve routing issues arising from the usage of a private IPv6 subnet. Add the IPv6 NAT in order to actually get some traffic:
</p>
<pre># ip6tables -t nat -A POSTROUTING -s fd00::/80 ! -o docker0 -j MASQUERADE
</pre>
<p>Now Docker should be properly IPv6 enabled. To test it, you can run:
</p>
<pre># docker run curlimages/curl curl -v -6 archlinux.org
</pre>
<p>If you use <a href="../en/Firewalld.html" title="Firewalld">firewalld</a>, you can add the rule like this:
</p>
<pre># firewall-cmd --zone=public --add-rich-rule='rule family="ipv6" destination not address="fd00::1/80" source address="fd00::/80" masquerade'
</pre>
<p>If you use <a href="../en/Uncomplicated_Firewall.html" class="mw-redirect" title="Ufw">ufw</a>, you need to first enable ipv6 forwarding following <a href="../en/Uncomplicated_Firewall.html#Forward_policy" title="Uncomplicated Firewall">Uncomplicated Firewall#Forward policy</a>. Next you need to edit <code>/etc/default/ufw</code> and uncomment the following lines
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/ufw/sysctl.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">net/ipv6/conf/default/forwarding=1
net/ipv6/conf/all/forwarding=1</pre>
<p>Then you can add the iptables rule:
</p>
<pre># ip6tables -t nat -A POSTROUTING -s fd00::/80 ! -o docker0 -j MASQUERADE
</pre>
<p>It should be noted that, for docker containers created with <i>docker-compose</i>, you may need to set <code>enable_ipv6: true</code> in the <code>networks</code> part for the corresponding network. Besides, you may need to configure the IPv6 subnet. See <a rel="nofollow" class="external autonumber" href="https://docs.docker.com/compose/compose-file/compose-file-v2/#ipv4_address-ipv6_address">[7]</a> for details.
</p>
<h3><span class="mw-headline" id="User_namespace_isolation">User namespace isolation</span></h3>
<p>By default, processes in Docker containers run within the same user namespace as the main <code>dockerd</code> daemon, i.e. containers are not isolated by the <span class="plainlinks archwiki-template-man" title="$ man 7 user_namespaces"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/user_namespaces.7">user_namespaces(7)</a></span> feature. This allows the process within the container to access configured resources on the host according to <a href="../en/Users_and_groups.html#Permissions_and_ownership" title="Users and groups">Users and groups#Permissions and ownership</a>. This maximizes compatibility, but poses a security risk if a container privilege escalation or breakout vulnerability is discovered that allows the container to access unintended resources on the host. (One such vulnerability was <a rel="nofollow" class="external text" href="https://seclists.org/oss-sec/2019/q1/119">published and patched in February 2019</a>.)
</p>
<p>The impact of such a vulnerability can be reduced by enabling <a rel="nofollow" class="external text" href="https://docs.docker.com/engine/security/userns-remap/">user namespace isolation</a>. This runs each container in a separate user namespace and maps the UIDs and GIDs inside that user namespace to a different (typically unprivileged) UID/GID range on the host. Note that in the Docker implementation, user namespaces for all containers are mapped to the same UID/GID range on the host, otherwise sharing volumes between multiple containers would not be possible.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> 
<ul>
<li>The main <code>dockerd</code> daemon still runs as <code>root</code> on the host. Running Docker in <a rel="nofollow" class="external text" href="https://docs.docker.com/engine/security/rootless/">rootless mode</a> is a different feature.</li>
<li>Processes in the container are started as the user defined in the <a rel="nofollow" class="external text" href="https://docs.docker.com/engine/reference/builder/#user">USER</a> directive in the Dockerfile used to build the image of the container.</li>
<li>Enabling user namespace isolation has <a rel="nofollow" class="external text" href="https://docs.docker.com/engine/security/userns-remap/#user-namespace-known-limitations">several limitations</a>. Also, <a rel="nofollow" class="external text" href="https://github.com/kubernetes/enhancements/issues/127">Kubernetes currently does not work with this feature</a>.</li>
<li>Enabling user namespace isolation effectively masks existing image and container layers, as well as other Docker objects in <code>/var/lib/docker/</code>, because Docker needs to adjust the ownership of these resources. The upstream documentation recommends to enable this feature on a new Docker installation rather than an existing one.</li>
</ul>
</div>
<p>Configure <code>userns-remap</code> in <code>/etc/docker/daemon.json</code>. <code>default</code> is a special value that will automatically create a user and group named <code>dockremap</code> for use with remapping.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/docker/daemon.json</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">{
  "userns-remap": "default"
}</pre>
<p>Configure <code>/etc/subuid</code> and <code>/etc/subgid</code> with a username/group name, starting UID/GID and UID/GID range size to allocate  to the remap user and group. This example allocates a range of 65536 UIDs and GIDs starting at 165536 to the <code>dockremap</code> user and group. 
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/subuid</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">dockremap:165536:65536</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/subgid</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">dockremap:165536:65536</pre>
<p>Restart <code>docker.service</code> to apply changes.
</p>
<p>After applying this change, all containers will run in an isolated user namespace by default. The remapping may be partially disabled on specific containers passing the <code>--userns=host</code> flag to the <code>docker</code> command. See <a rel="nofollow" class="external autonumber" href="https://docs.docker.com/engine/security/userns-remap/#disable-namespace-remapping-for-a-container">[8]</a> for details.
</p>
<h3><span class="mw-headline" id="Docker_rootless">Docker rootless</span></h3>
<p>Install the <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/docker-rootless-extras-bin/">docker-rootless-extras-bin</a></span><sup><small>AUR</small></sup> package to run docker in rootless mode (that is, as a regular user instead of as root).
</p>
<p>Configure <code>/etc/subuid</code> and <code>/etc/subgid</code> with a username/group name, starting UID/GID and UID/GID range size to allocate  to the remap user and group.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/subuid</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">your_username:165536:65536</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/subgid</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">your_username:165536:65536</pre>
<p>Enable the socket (this will result in docker being started using systemd's socket activation):
</p>
<pre>$ systemctl --user enable --now docker.socket
</pre>
<p>Finally set docker socket environment variable:
</p>
<pre>$ export DOCKER_HOST=unix://$XDG_RUNTIME_DIR/docker.sock
</pre>
<h2><span class="mw-headline" id="Images">Images</span></h2>
<h3><span class="mw-headline" id="Arch_Linux">Arch Linux</span></h3>
<p>The following command pulls the <a rel="nofollow" class="external text" href="https://hub.docker.com/_/archlinux/">archlinux</a> x86_64 image. This is a stripped down version of Arch core without network, etc.
</p>
<pre># docker pull archlinux
</pre>
<p>See also <a rel="nofollow" class="external text" href="https://github.com/archlinux/archlinux-docker/blob/master/README.md">README.md</a>.
</p>
<p>For a full Arch base, clone the repo from above and build your own image.
</p>
<pre>$ git clone <a rel="nofollow" class="external free" href="https://github.com/archlinux/archlinux-docker.git">https://github.com/archlinux/archlinux-docker.git</a>
</pre>
<p>Make sure that the <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=devtools">devtools</a></span>, <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=fakechroot">fakechroot</a></span> and <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=fakeroot">fakeroot</a></span> packages are installed.
</p>
<p>To build the base image: 
</p>
<pre>$ make image-base
</pre>
<h3><span class="mw-headline" id="Alpine_Linux">Alpine Linux</span></h3>
<p><a rel="nofollow" class="external text" href="https://www.alpinelinux.org/">Alpine Linux</a> is a popular choice for small container images, especially for software compiled as static binaries. The following command pulls the latest Alpine Linux image:
</p>
<pre># docker pull alpine
</pre>
<p>Alpine Linux uses the <a rel="nofollow" class="external text" href="https://musl.libc.org/">musl</a> libc implementation instead of the <a rel="nofollow" class="external text" href="https://www.gnu.org/software/libc/">glibc</a> libc implementation used by most Linux distributions. Because Arch Linux uses glibc, there are a number of functional differences between an Arch Linux host and an Alpine Linux container that can impact the performance and correctness of software. A list of these differences is documented <a rel="nofollow" class="external text" href="https://wiki.musl-libc.org/functional-differences-from-glibc.html">here</a>.
</p>
<p>Note that dynamically linked software built on Arch Linux (or any other system using glibc) may have bugs and performance problems when run on Alpine Linux (or any other system using a different libc). See <a rel="nofollow" class="external autonumber" href="https://bugs.python.org/issue32307">[9]</a>, <a rel="nofollow" class="external autonumber" href="https://superuser.com/questions/1219609/why-is-the-alpine-docker-image-over-50-slower-than-the-ubuntu-image">[10]</a> and <a rel="nofollow" class="external autonumber" href="https://pythonspeed.com/articles/alpine-docker-python">[11]</a> for examples.
</p>
<h3><span class="mw-headline" id="CentOS">CentOS</span></h3>
<p>The following command pulls the latest <a rel="nofollow" class="external text" href="https://hub.docker.com/_/centos">centos</a> image:
</p>
<pre># docker pull centos
</pre>
<p>See the Docker Hub page for a full list of available tags for each CentOS release.
</p>
<h3><span class="mw-headline" id="Debian">Debian</span></h3>
<p>The following command pulls the latest <a rel="nofollow" class="external text" href="https://hub.docker.com/_/debian">debian</a> image:
</p>
<pre># docker pull debian
</pre>
<p>See the Docker Hub page for a full list of available tags, including both standard and slim versions for each Debian release.
</p>
<h3><span class="mw-headline" id="Distroless">Distroless</span></h3>
<p>Google maintains <a rel="nofollow" class="external text" href="https://github.com/GoogleContainerTools/distroless">distroless images</a> for several popular programming languages such as <a href="../en/Java.html" title="Java">Java</a>, <a href="../en/Python.html" title="Python">Python</a>, <a href="../en/Go.html" title="Go">Go</a>, <a href="../en/Node.js.html" title="Node.js">Node.js</a>, <a href="../en/.NET_Core.html" title=".NET Core">.NET Core</a> and <a href="../en/Rust.html" title="Rust">Rust</a>. These images contain only the programming language runtime without any OS related files, resulting in very small images for packaging software.
</p>
<p>See the GitHub README for a list of images and instructions on their use.
</p>
<h2><span class="mw-headline" id="Run_GPU_accelerated_Docker_containers_with_NVIDIA_GPUs">Run GPU accelerated Docker containers with NVIDIA GPUs</span></h2>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/libnvidia-container/">libnvidia-container</a></span><sup><small>AUR</small></sup> has no support for <a href="../en/Cgroups.html" title="Cgroups">cgroups</a> v2 <a rel="nofollow" class="external autonumber" href="https://github.com/NVIDIA/libnvidia-container/issues/111">[12]</a>. You need to set the <code>systemd.unified_cgroup_hierarchy=false</code> <a href="../en/Kernel_parameters.html" class="mw-redirect" title="Kernel parameter">kernel parameter</a> if you are using <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=systemd">systemd</a></span> v248 or higher.</div>
<h3>
<span id="With_NVIDIA_Container_Toolkit_.28recommended.29"></span><span class="mw-headline" id="With_NVIDIA_Container_Toolkit_(recommended)">With NVIDIA Container Toolkit (recommended)</span>
</h3>
<p>Starting from Docker version 19.03, NVIDIA GPUs are natively supported as Docker devices. <a rel="nofollow" class="external text" href="https://github.com/NVIDIA/nvidia-docker">NVIDIA Container Toolkit</a> is the recommended way of running containers that leverage NVIDIA GPUs.
</p>
<p>Install the <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/nvidia-container-toolkit/">nvidia-container-toolkit</a></span><sup><small>AUR</small></sup> package. Next, <a href="../en/Systemd.html#Using_units" class="mw-redirect" title="Restart">restart</a> docker. You can now run containers that make use of NVIDIA GPUs using the <code>--gpus</code> option:
</p>
<pre># docker run --gpus all nvidia/cuda:9.0-base nvidia-smi
</pre>
<p>Specify how many GPUs are enabled inside a container:
</p>
<pre># docker run --gpus 2 nvidia/cuda:9.0-base nvidia-smi
</pre>
<p>Specify which GPUs to use:
</p>
<pre># docker run --gpus '"device=1,2"' nvidia/cuda:9.0-base nvidia-smi
</pre>
<p>or
</p>
<pre># docker run --gpus '"device=UUID-ABCDEF,1"' nvidia/cuda:9.0-base nvidia-smi
</pre>
<p>Specify a capability (graphics, compute, ...) for the container (though this is rarely if ever used this way):
</p>
<pre># docker run --gpus all,capabilities=utility nvidia/cuda:9.0-base nvidia-smi
</pre>
<p>For more information see <a rel="nofollow" class="external text" href="https://github.com/NVIDIA/nvidia-docker/blob/master/README.md">README.md</a> and <a rel="nofollow" class="external text" href="https://github.com/NVIDIA/nvidia-docker/wiki">Wiki</a>.
</p>
<h3><span class="mw-headline" id="With_NVIDIA_Container_Runtime">With NVIDIA Container Runtime</span></h3>
<p>Install the <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/nvidia-container-runtime/">nvidia-container-runtime</a></span><sup><small>AUR</small></sup> package. Next, register the NVIDIA runtime by editing <code>/etc/docker/daemon.json</code>
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/docker/daemon.json</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">{
  "runtimes": {
    "nvidia": {
      "path": "/usr/bin/nvidia-container-runtime",
      "runtimeArgs": []
    }
  }
}</pre>
<p>and then <a href="../en/Systemd.html#Using_units" class="mw-redirect" title="Restart">restart</a> docker.
</p>
<p>The runtime can also be registered via a command line option to <i>dockerd</i>:
</p>
<pre># /usr/bin/dockerd --add-runtime=nvidia=/usr/bin/nvidia-container-runtime
</pre>
<p>Afterwards GPU accelerated containers can be started with
</p>
<pre># docker run --runtime=nvidia nvidia/cuda:9.0-base nvidia-smi
</pre>
<p>or (required Docker version 19.03 or higher)
</p>
<pre># docker run --gpus all nvidia/cuda:9.0-base nvidia-smi
</pre>
<p>See also <a rel="nofollow" class="external text" href="https://github.com/NVIDIA/nvidia-container-runtime/blob/master/README.md">README.md</a>.
</p>
<h3>
<span id="With_nvidia-docker_.28deprecated.29"></span><span class="mw-headline" id="With_nvidia-docker_(deprecated)">With nvidia-docker (deprecated)</span>
</h3>
<p><a rel="nofollow" class="external text" href="https://nvidia.github.io/nvidia-docker/">nvidia-docker</a> is a wrapper around NVIDIA Container Runtime which registers the NVIDIA runtime by default and provides the <i>nvidia-docker</i> command.
</p>
<p>To use nvidia-docker, install the <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/nvidia-docker/">nvidia-docker</a></span><sup><small>AUR</small></sup> package and then <a href="../en/Systemd.html#Using_units" class="mw-redirect" title="Restart">restart</a> docker. Containers with NVIDIA GPU support can then be run using any of the following methods:
</p>
<pre># docker run --runtime=nvidia nvidia/cuda:9.0-base nvidia-smi
</pre>
<pre># nvidia-docker run nvidia/cuda:9.0-base nvidia-smi
</pre>
<p>or (required Docker version 19.03 or higher)
</p>
<pre># docker run --gpus all nvidia/cuda:9.0-base nvidia-smi
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> nvidia-docker is a legacy method for running NVIDIA GPU accelerated containers used prior to Docker 19.03 and has been deprecated. If you are using Docker version 19.03 or higher, it is recommended to use <a href="#With_NVIDIA_Container_Toolkit_(recommended)">NVIDIA Container Toolkit</a> instead.</div>
<h3><span class="mw-headline" id="Arch_Linux_image_with_CUDA">Arch Linux image with CUDA</span></h3>
<p>You can use the following <code>Dockerfile</code> to build a custom Arch Linux image with CUDA. It uses the <a rel="nofollow" class="external text" href="https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/syntax.md">Dockerfile frontend syntax 1.2</a> to cache pacman packages on the host. The <code>DOCKER_BUILDKIT=1</code> <a href="../en/Environment_variables.html" class="mw-redirect" title="Environment variable">environment variable</a> must be set on the client before building the Docker image.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">Dockerfile</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;"># syntax = docker/dockerfile:1.2

FROM archlinux

# use faster mirror to speed up the image build
RUN echo 'Server = https://mirror.pkgbuild.com/$repo/os/$arch' &gt; /etc/pacman.d/mirrorlist

# install packages
RUN --mount=type=cache,sharing=locked,target=/var/cache/pacman \
    pacman -Suy --noconfirm --needed base base-devel cuda

# configure nvidia container runtime
# https://github.com/NVIDIA/nvidia-container-runtime#environment-variables-oci-spec
ENV NVIDIA_VISIBLE_DEVICES all
ENV NVIDIA_DRIVER_CAPABILITIES compute,utility
</pre>
<h2><span class="mw-headline" id="Useful_tips">Useful tips</span></h2>
<p>To grab the IP address of a running container:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$ docker inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' &lt;container-name OR id&gt; </pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">172.17.0.37</pre>
<p>For each running container, the name and corresponding IP address can be listed for use in <code>/etc/hosts</code>:
</p>
<pre>#!/usr/bin/env sh
for ID in $(docker ps -q | awk '{print $1}'); do
    IP=$(docker inspect --format="{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}" "$ID")
    NAME=$(docker ps | grep "$ID" | awk '{print $NF}')
    printf "%s %s\n" "$IP" "$NAME"
done</pre>
<h2><span class="mw-headline" id="Remove_Docker_and_images">Remove Docker and images</span></h2>
<p>In case you want to remove Docker entirely you can do this by following  the steps below:
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> Do not just copy paste those commands without making sure you know what you are doing.</div>
<p>Check for running containers:
</p>
<pre># docker ps
</pre>
<p>List all containers running on the host for deletion:
</p>
<pre># docker ps -a
</pre>
<p>Stop a running container:
</p>
<pre># docker stop &lt;CONTAINER ID&gt;
</pre>
<p>Killing still running containers:
</p>
<pre># docker kill &lt;CONTAINER ID&gt;
</pre>
<p>Delete containers listed by ID:
</p>
<pre># docker rm &lt;CONTAINER ID&gt;
</pre>
<p>List all Docker images:
</p>
<pre># docker images
</pre>
<p>Delete images by ID:
</p>
<pre># docker rmi &lt;IMAGE ID&gt;
</pre>
<p>Delete all images, containers, volumes, and networks that are not associated with a container (dangling):
</p>
<pre># docker system prune
</pre>
<p>To additionally remove any stopped containers and all unused images (not just dangling ones), add the -a flag to the command:
</p>
<pre># docker system prune -a
</pre>
<p>Delete all Docker data (purge directory):
</p>
<pre># rm -R /var/lib/docker
</pre>
<h2><span class="mw-headline" id="Troubleshooting">Troubleshooting</span></h2>
<h3>
<span id="docker0_Bridge_gets_no_IP_.2F_no_internet_access_in_containers_when_using_systemd-networkd"></span><span class="mw-headline" id="docker0_Bridge_gets_no_IP_/_no_internet_access_in_containers_when_using_systemd-networkd">docker0 Bridge gets no IP / no internet access in containers when using systemd-networkd</span>
</h3>
<p>Docker attempts to enable IP forwarding globally, but by default <a href="../en/Systemd-networkd.html" title="Systemd-networkd">systemd-networkd</a> overrides the global sysctl setting for each defined network profile. Set <code>IPForward=yes</code> in the network profile. See <a href="../en/Internet_sharing.html#Enable_packet_forwarding" title="Internet sharing">Internet sharing#Enable packet forwarding</a> for details.
</p>
<p>When <a href="../en/Systemd-networkd.html" title="Systemd-networkd">systemd-networkd</a> tries to manage the network interfaces created by Docker, this can lead to connectivity issues. Try disabling management of those interfaces. I.e. <code>networkctl list</code> should report <code>unmanaged</code> in the SETUP column for all networks created by Docker.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> 
<ul>
<li>You may need to <a href="../en/Systemd.html#Using_units" class="mw-redirect" title="Restart">restart</a> <code>docker.service</code> each time you <a href="../en/Systemd.html#Using_units" class="mw-redirect" title="Restart">restart</a> <code>systemd-networkd.service</code> or <code>iptables.service</code>.</li>
<li>Also be aware that <a href="../en/Nftables.html" title="Nftables">nftables</a> may block docker connections by default. Use <code>nft list ruleset</code> to check for blocking rules. <code>nft flush chain inet filter forward</code> removes all forwarding rules temporarily. Edit <code>/etc/nftables.conf</code> to make changes permanent. Remember to <a href="../en/Systemd.html#Using_units" class="mw-redirect" title="Restart">restart</a> <code>nftables.service</code> to reload rules from the config file. See <a rel="nofollow" class="external autonumber" href="https://github.com/moby/moby/issues/26824">[13]</a> for details about nftables support in Docker.</li>
</ul>
</div>
<h3>
<span id="Default_number_of_allowed_processes.2Fthreads_too_low"></span><span class="mw-headline" id="Default_number_of_allowed_processes/threads_too_low">Default number of allowed processes/threads too low</span>
</h3>
<p>If you run into error messages like
</p>
<pre># e.g. Java
java.lang.OutOfMemoryError: unable to create new native thread
# e.g. C, bash, ...
fork failed: Resource temporarily unavailable
</pre>
<p>then you might need to adjust the number of processes allowed by systemd. The default is 500 (see <code>system.conf</code>), which is pretty small for running several docker containers. <a href="../en/Systemd.html#Editing_provided_units" class="mw-redirect" title="Edit">Edit</a> the <code>docker.service</code> with the following snippet:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># systemctl edit docker.service</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[Service]
TasksMax=infinity</pre>
<h3><span class="mw-headline" id="Error_initializing_graphdriver:_devmapper">Error initializing graphdriver: devmapper</span></h3>
<p>If <i>systemctl</i> fails to start docker and provides an error:
</p>
<pre>Error starting daemon: error initializing graphdriver: devmapper: Device docker-8:2-915035-pool is not a thin pool
</pre>
<p>Then, try the following steps to resolve the error. Stop the service, back up <code>/var/lib/docker/</code> (if desired), remove the contents of <code>/var/lib/docker/</code>, and try to start the service. See the open <a rel="nofollow" class="external text" href="https://github.com/docker/docker/issues/21304">GitHub issue</a> for details.
</p>
<h3>
<span id="Failed_to_create_some.2Fpath.2Fto.2Ffile:_No_space_left_on_device"></span><span class="mw-headline" id="Failed_to_create_some/path/to/file:_No_space_left_on_device">Failed to create some/path/to/file: No space left on device</span>
</h3>
<p>If you are getting an error message like this:
</p>
<pre>ERROR: Failed to create some/path/to/file: No space left on device
</pre>
<p>when building or running a Docker image, even though you do have enough disk space available, make sure:
</p>
<ul>
<li>
<a href="../en/Tmpfs.html" title="Tmpfs">Tmpfs</a> is disabled or has enough memory allocation. Docker might be trying to write files into <code>/tmp</code> but fails due to restrictions in memory usage and not disk space.</li>
<li>If you are using <a href="../en/XFS.html" title="XFS">XFS</a>, you might want to remove the <code>noquota</code> mount option from the relevant entries in <code>/etc/fstab</code> (usually where <code>/tmp</code> and/or <code>/var/lib/docker</code> reside). Refer to <a href="../en/Disk_quota.html" title="Disk quota">Disk quota</a> for more information, especially if you plan on using and resizing <code>overlay2</code> Docker storage driver.</li>
<li>XFS quota mount options (<code>uquota</code>, <code>gquota</code>, <code>prjquota</code>, etc.) fail during re-mount of the file system. To enable quota for root file system, the mount option must be passed to initramfs as a <a href="../en/Kernel_parameters.html" class="mw-redirect" title="Kernel parameter">kernel parameter</a> <code>rootflags=</code>. Subsequently, it should not be listed among mount options in <code>/etc/fstab</code> for the root (<code>/</code>) filesystem.</li>
</ul>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> There are some differences of XFS Quota compared to standard Linux <a href="../en/Disk_quota.html" title="Disk quota">Disk quota</a>, <a rel="nofollow" class="external autonumber" href="http://inai.de/linux/adm_quota">[14]</a> may be worth reading.</div>
<h3><span class="mw-headline" id="Docker-machine_fails_to_create_virtual_machines_using_the_virtualbox_driver">Docker-machine fails to create virtual machines using the virtualbox driver</span></h3>
<p>In case docker-machine fails to create the VM's using the virtualbox driver, with the following:
</p>
<pre>VBoxManage: error: VBoxNetAdpCtl: Error while adding new interface: failed to open /dev/vboxnetctl: No such file or directory
</pre>
<p>Simply reload the virtualbox via CLI with <code>vboxreload</code>.
</p>
<h3><span class="mw-headline" id="Starting_Docker_breaks_KVM_bridged_networking">Starting Docker breaks KVM bridged networking</span></h3>
<p>This is a <a rel="nofollow" class="external text" href="https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=865975">known issue</a>. You can use the following workaround:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/docker/daemon.json</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">{
  "iptables": false
}</pre>
<p>If there is already a network bridge configured for KVM, this may be fixable by telling docker about it.  See <a rel="nofollow" class="external autonumber" href="https://muthii.com/blog/?p=540">[15]</a> where docker configuration is modified as:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/docker/daemon.json</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">{
  "bridge": "<i>existing_bridge_name</i>"
}</pre>
<p>Be sure to replace <code><i>existing_bridge_name</i></code> with the actual name of your network bridge.
</p>
<h3><span class="mw-headline" id="Image_pulls_from_Docker_Hub_are_rate_limited">Image pulls from Docker Hub are rate limited</span></h3>
<p>Beginning on November 1st 2020, rate limiting is enabled for downloads from Docker Hub from anonymous and free accounts. See the <a rel="nofollow" class="external text" href="https://docs.docker.com/docker-hub/download-rate-limit/">rate limit documentation</a> for more information.
</p>
<p>Unauthenticated rate limits are tracked by source IP. Authenticated rate limits are tracked by account.
</p>
<p>If you need to exceed the rate limits, you can either <a rel="nofollow" class="external text" href="https://www.docker.com/pricing">sign up for a paid plan</a> or mirror the images you need to a different image registry. You can <a rel="nofollow" class="external text" href="https://docs.docker.com/registry/">host your own registry</a> or use a cloud hosted registry such as <a rel="nofollow" class="external text" href="https://aws.amazon.com/ecr/">Amazon ECR</a>, <a rel="nofollow" class="external text" href="https://cloud.google.com/container-registry/">Google Container Registry</a>, <a rel="nofollow" class="external text" href="https://azure.microsoft.com/en-us/services/container-registry/">Azure Container Registry</a> or <a rel="nofollow" class="external text" href="https://quay.io/">Quay Container Registry</a>.
</p>
<p>To mirror an image, use the <code>pull</code>, <code>tag</code> and <code>push</code> subcommands of the Docker CLI. For example, to mirror the <code>1.19.3</code> tag of the <a href="../en/Nginx.html" title="Nginx">Nginx</a> image to a registry hosted at <code>cr.example.com</code>:
</p>
<pre>$ docker pull nginx:1.19.3
$ docker tag nginx:1.19.3 cr.example.com/nginx:1.19.3
$ docker push cr.example.com/nginx:1.19.3
</pre>
<p>You can then pull or run the image from the mirror:
</p>
<pre>$ docker pull cr.example.com/nginx:1.19.3
$ docker run cr.example.com/nginx:1.19.3
</pre>
<h2><span class="mw-headline" id="See_also">See also</span></h2>
<ul>
<li><a rel="nofollow" class="external text" href="https://www.docker.com">Official website</a></li>
<li><a rel="nofollow" class="external text" href="https://docs.docker.com/engine/installation/linux/archlinux/">Arch Linux on docs.docker.com</a></li>
<li>
<a rel="nofollow" class="external text" href="https://opensource.com/business/14/7/docker-security-selinux">Are Docker containers really secure?</a> — opensource.com</li>
<li><a rel="nofollow" class="external text" href="https://awesome-docker.netlify.com/">Awesome Docker</a></li>
<li><a rel="nofollow" class="external text" href="https://www.trendmicro.com/en_us/research/19/l/why-running-a-privileged-container-in-docker-is-a-bad-idea.html">Why A Privileged Container in Docker Is a Bad Idea</a></li>
</ul>
</div>
</div>
<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks">
<a href="../Special:Categories.html" title="Special:Categories">Categories</a>: <ul>
<li><a href="../en/Category:Virtualization.html" title="Category:Virtualization">Virtualization</a></li>
<li><a href="../en/Category:Sandboxing.html" title="Category:Sandboxing">Sandboxing</a></li>
</ul>
</div></div>
	</div>
</div>

<footer id="footer" class="mw-footer" role="contentinfo" style="margin: 0">
	<ul id="footer-info">
		<li>Retrieved from "<a dir="ltr" href="https://wiki.archlinux.org/index.php?title=Docker&amp;oldid=657776">https://wiki.archlinux.org/index.php?title=Docker&amp;oldid=657776</a>"</li>
		<li id="footer-info-lastmod"> This page was last edited on 5 April 2021, at 20:43.</li>
		<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3 or later</a> unless otherwise noted.</li>
	<br>
</ul>
	<ul id="footer-places">
		<li id="footer-places-privacy"><a href="../en/ArchWiki:Privacy_policy.html" title="ArchWiki:Privacy policy">Privacy policy</a></li>
		<li id="footer-places-about"><a href="../en/ArchWiki:About.html" title="ArchWiki:About">About ArchWiki</a></li>
		<li id="footer-places-disclaimer"><a href="../en/ArchWiki:General_disclaimer.html" title="ArchWiki:General disclaimer">Disclaimers</a></li>
	</ul>
	<ul id="footer-icons" class="noprint">
		<li id="footer-copyrightico">
	</ul>
	<div style="clear: both;"></div>
</footer>



</body>
</html>
